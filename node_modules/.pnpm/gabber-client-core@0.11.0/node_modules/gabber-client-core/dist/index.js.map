{"version":3,"sources":["../src/index.ts","../src/session.ts","../src/TrackVolumeVisualizer.ts","../src/generated/api/credit-api.ts","../src/generated/base.ts","../src/generated/common.ts","../src/generated/api/inference-api.ts","../src/generated/api/llmapi.ts","../src/generated/api/persona-api.ts","../src/generated/api/realtime-api.ts","../src/generated/api/scenario-api.ts","../src/generated/api/session-api.ts","../src/generated/api/usage-api.ts","../src/generated/api/voice-api.ts","../src/generated/configuration.ts","../src/generated/model/chat-completion-request-message.ts","../src/generated/model/chat-completion-request-message-content-part-audio.ts","../src/generated/model/chat-completion-request-message-content-part-audio-input-audio.ts","../src/generated/model/chat-completion-request-message-content-part-text.ts","../src/generated/model/chat-completion-response-gabber-message-data-inner.ts","../src/generated/model/chat-completion-response-message.ts","../src/generated/model/chat-completion-stream-response.ts","../src/generated/model/chat-completion-stream-response-choices-inner.ts","../src/generated/model/chat-completion-stream-response-delta.ts","../src/generated/model/chat-completion-stream-response-gabber-message-data-inner.ts","../src/generated/model/context-create-request-messages-inner.ts","../src/generated/model/context-message-create-params.ts","../src/generated/model/create-persona-request.ts","../src/generated/model/history-message.ts","../src/generated/model/persona.ts","../src/generated/model/realtime-session.ts","../src/generated/model/realtime-session-timeline-item.ts","../src/generated/model/sdkagent-state.ts","../src/generated/model/sdkconnection-state.ts","../src/generated/model/session.ts","../src/generated/model/session-timeline-item.ts","../src/generated/model/update-persona-request.ts","../src/generated/model/usage-type.ts","../src/generated/model/webhook-message-usage-tracked.ts","../src/api.ts"],"sourcesContent":["export * from \"./session\";\nexport * from \"./api\";","import { RealtimeSessionConnectionDetails, SDKAgentState, SDKConnectionState, SDKConnectOptions, SDKSendChatMessageParams, SDKSessionTranscription } from \"./generated\";\nimport {\n  Room,\n  RemoteParticipant,\n  RemoteTrackPublication,\n  RemoteTrack,\n  RemoteAudioTrack,\n  DataPacket_Kind,\n  TrackPublication,\n  Track,\n  LocalTrackPublication,\n  LocalParticipant,\n  Participant,\n  LocalAudioTrack,\n} from \"livekit-client\";\nimport { TrackVolumeVisualizer } from \"./TrackVolumeVisualizer\";\nimport { Api } from \"./api\";\n\nexport class RealtimeSessionEngine {\n  private livekitRoom: Room;\n  private agentParticipant: RemoteParticipant | null = null;\n  private agentTrack: RemoteAudioTrack | null = null;\n  private _microphoneEnabledState: boolean = false;\n  private transcriptions: SDKSessionTranscription[] = [];\n  private agentVolumeVisualizer: TrackVolumeVisualizer;\n  private userVolumeVisualizer: TrackVolumeVisualizer;\n  private onConnectionStateChanged: ConnectionStateChangedCallback;\n  private onMessagesChanged: OnTranscriptionsChangedCallback;\n  private onMicrophoneChanged: OnMicrophoneCallback;\n  private onAgentVolumeChanged: OnVolumeCallback;\n  private onUserVolumeChanged: OnVolumeCallback;\n  private onAgentStateChanged: OnAgentStateChanged;\n  private onRemainingSecondsChanged: OnRemainingSecondsChanged;\n  private onAgentError: OnAgentErrorCallback;\n  private onCanPlayAudioChanged: OnCanPlayAudioChanged;\n  private _agentState: SDKAgentState = \"warmup\";\n  private _remainingSeconds: number | null = null;\n  private divElement: HTMLDivElement;\n  public id: string | null = null;\n\n  constructor({\n    onConnectionStateChanged: onConnectionStateChanged,\n    onMessagesChanged,\n    onMicrophoneChanged,\n    onAgentVolumeChanged,\n    onUserVolumeChanged,\n    onAgentStateChanged,\n    onRemainingSecondsChanged: onRemainingSecondsChanged,\n    onAgentError,\n    onCanPlayAudioChanged,\n  }: SessionEngineParams) {\n    this.livekitRoom = new Room();\n    this.livekitRoom.on(\"connected\", this.onRoomConnected.bind(this));\n    this.livekitRoom.on(\"disconnected\", this.onRoomDisconnected.bind(this));\n    this.livekitRoom.on(\"trackSubscribed\", this.onTrackSubscribed.bind(this));\n    this.livekitRoom.on(\n      \"trackUnsubscribed\",\n      this.onTrackUnsubscribed.bind(this)\n    );\n    this.livekitRoom.on(\"dataReceived\", this.onDataReceived.bind(this));\n    this.livekitRoom.on(\n      \"participantMetadataChanged\",\n      this.onParticipantMetadataChanged.bind(this)\n    );\n    this.livekitRoom.on(\n      \"localTrackPublished\",\n      this.onLocalTrackPublished.bind(this)\n    );\n    this.livekitRoom.on(\n      \"localTrackUnpublished\",\n      this.onLocalTrackUnpublished.bind(this)\n    );\n    this.livekitRoom.on(\"trackMuted\", this.onTrackMuted.bind(this));\n    this.livekitRoom.on(\"trackUnmuted\", this.onTrackUnmuted.bind(this));\n    this.livekitRoom.on(\n      \"audioPlaybackChanged\",\n      this.onAudioPlaybackChangaed.bind(this)\n    );\n\n    this.divElement = document.createElement(\"div\");\n    document.body.appendChild(this.divElement);\n    this.onConnectionStateChanged = onConnectionStateChanged;\n    this.onMessagesChanged = onMessagesChanged;\n    this.onMicrophoneChanged = onMicrophoneChanged;\n    this.onAgentVolumeChanged = onAgentVolumeChanged;\n    this.onUserVolumeChanged = onUserVolumeChanged;\n    this.onAgentStateChanged = onAgentStateChanged;\n    this.onRemainingSecondsChanged = onRemainingSecondsChanged;\n    this.onAgentError = onAgentError;\n    this.onCanPlayAudioChanged = onCanPlayAudioChanged;\n\n    this.agentVolumeVisualizer = new TrackVolumeVisualizer({\n      onTick: this.onAgentVolumeChanged.bind(this),\n      bands: 10,\n    });\n\n    this.userVolumeVisualizer = new TrackVolumeVisualizer({\n      onTick: this.onUserVolumeChanged.bind(this),\n      bands: 10,\n    });\n  }\n\n  async connect(opts: SDKConnectOptions) {\n    let connectionDetails: RealtimeSessionConnectionDetails | undefined = undefined;\n    if ('connection_details' in opts) {\n      connectionDetails = opts.connection_details;\n    } else if ('token' in opts && 'config' in opts) {\n      const api = new Api(opts.token);\n      const res = await api.realtime.startRealtimeSession(opts);\n      connectionDetails = {\n        url: res.data.connection_details.url!,\n        token: res.data.connection_details.token!,\n      };\n    }\n    if (!connectionDetails) {\n      throw new Error(\"No connection details provided\");\n    }\n    await this.livekitRoom.connect(\n      connectionDetails.url,\n      connectionDetails.token,\n      {\n        autoSubscribe: true,\n      }\n    );\n\n\n    this.onCanPlayAudioChanged(this.livekitRoom.canPlaybackAudio);\n  }\n\n  async disconnect() {\n    await this.livekitRoom.disconnect();\n  }\n\n  async startAudio() {\n    try {\n      await this.livekitRoom.startAudio();\n    } catch (e) {\n      console.error(\"Error starting audio\");\n    }\n  }\n\n  async setMicrophoneEnabled(enabled: boolean) {\n    await this.livekitRoom.localParticipant.setMicrophoneEnabled(enabled);\n  }\n\n  async sendChatMessage({ text }: SDKSendChatMessageParams) {\n    const te = new TextEncoder();\n    const encoded = te.encode(JSON.stringify({ text }));\n    await this.livekitRoom.localParticipant.publishData(encoded, {\n      topic: \"chat_input\",\n    });\n  }\n\n  private set agentState(value: SDKAgentState) {\n    if (value == this._agentState) {\n      return;\n    }\n    this._agentState = value;\n    this.onAgentStateChanged(value);\n  }\n\n  private set remainingSeconds(value: number) {\n    if (value === this._remainingSeconds) {\n      return;\n    }\n\n    this._remainingSeconds = value;\n    this.onRemainingSecondsChanged(value);\n  }\n\n  destroy() {\n    document.body.removeChild(this.divElement);\n    try {\n      this.livekitRoom.removeAllListeners();\n      this.livekitRoom.disconnect(true);\n    } catch (e) {\n      console.error(\"Error destroying session\", e);\n    }\n  }\n\n  private set microphoneEnabledState(value: boolean) {\n    if (this._microphoneEnabledState !== value) {\n      this._microphoneEnabledState = value;\n      this.onMicrophoneChanged(value);\n    }\n  }\n\n  private resolveMicrophoneState() {\n    if (!this.livekitRoom.localParticipant) {\n      this.microphoneEnabledState = false;\n    }\n    this.microphoneEnabledState =\n      this.livekitRoom.localParticipant.isMicrophoneEnabled;\n  }\n\n  private onTrackUnmuted(\n    publication: TrackPublication,\n    participant: Participant\n  ) {\n    console.log(\"Local track unmuted\", publication, participant);\n    if (!participant.isLocal) {\n      return;\n    }\n    if (publication.kind === Track.Kind.Audio) {\n      this.resolveMicrophoneState();\n    }\n  }\n\n  private onTrackMuted(\n    publication: TrackPublication,\n    participant: Participant\n  ) {\n    console.log(\"Local track muted\", publication, participant);\n    if (!participant.isLocal) {\n      return;\n    }\n    if (publication.kind === Track.Kind.Audio) {\n      this.resolveMicrophoneState();\n    }\n  }\n\n  private onLocalTrackPublished(\n    publication: LocalTrackPublication,\n    participant: LocalParticipant\n  ) {\n    console.log(\"Local track published\", publication, participant);\n    if (publication.kind === Track.Kind.Audio) {\n      this.userVolumeVisualizer.setTrack(\n        publication.audioTrack as LocalAudioTrack\n      );\n      this.resolveMicrophoneState();\n    }\n  }\n\n  private onLocalTrackUnpublished(\n    publication: LocalTrackPublication,\n    participant: LocalParticipant\n  ) {\n    console.log(\"Local track unpublished\", publication, participant);\n    if (publication.kind === Track.Kind.Audio) {\n      this.resolveMicrophoneState();\n    }\n  }\n\n  private onAudioPlaybackChangaed(_: boolean) {\n    this.onCanPlayAudioChanged(this.livekitRoom.canPlaybackAudio);\n  }\n\n  private onRoomConnected() {\n    console.log(\"Room connected\");\n    this.resolveMicrophoneState();\n\n    // Kind of a hack because session id isn't available through the connection details flow\n    const metadataString = this.livekitRoom.metadata || \"{}\";\n    this.id = (JSON.parse(metadataString))[\"session\"] || null;\n\n    this.onConnectionStateChanged(\"waiting_for_agent\");\n  }\n\n  private onRoomDisconnected() {\n    console.log(\"Room disconnected\");\n    this.id = null;\n    this.resolveMicrophoneState();\n    this.onConnectionStateChanged(\"not_connected\");\n  }\n\n  private onTrackSubscribed(\n    track: RemoteTrack,\n    pub: RemoteTrackPublication,\n    participant: RemoteParticipant\n  ) {\n    console.log(\"Track subscribed\", track, pub, participant);\n    if (track.kind !== \"audio\") {\n      return;\n    }\n    if (this.agentParticipant) {\n      console.error(\"Already subscribed to an agent\");\n      return;\n    }\n    this.divElement.appendChild(track.attach());\n    this.agentParticipant = participant;\n    this.agentTrack = track as RemoteAudioTrack;\n    this.agentVolumeVisualizer.setTrack(track as RemoteAudioTrack);\n    this.onConnectionStateChanged(\"connected\");\n  }\n\n  private onTrackUnsubscribed(\n    track: RemoteTrack,\n    pub: RemoteTrackPublication,\n    participant: RemoteParticipant\n  ) {\n    console.log(\"Track unsubscribed\", track, pub, participant);\n    if (track.kind !== \"audio\") {\n      return;\n    }\n    track.attachedElements.forEach((el) => {\n      el.remove();\n    });\n    if (track !== this.agentTrack) {\n      console.error(\"Unsubscribed from unknown track\");\n      return;\n    }\n    this.agentParticipant = null;\n    this.agentTrack = null;\n    if (this.livekitRoom.state === \"connected\") {\n      this.onConnectionStateChanged(\"waiting_for_agent\");\n    }\n  }\n\n  private onDataReceived(\n    data: Uint8Array,\n    participant: RemoteParticipant | undefined,\n    _: DataPacket_Kind | undefined,\n    topic: string | undefined\n  ) {\n    if (participant !== this.agentParticipant) {\n      return;\n    }\n\n    const decoded = new TextDecoder().decode(data);\n    console.log(\"Data received\", decoded, participant, topic);\n    if (topic === \"message\") {\n      const message = JSON.parse(decoded) as SDKSessionTranscription;\n      for (let i = 0; i < this.transcriptions.length; i++) {\n        if (this.transcriptions[i].id === message.id && this.transcriptions[i].agent == message.agent) {\n          this.transcriptions[i] = message;\n          this.onMessagesChanged(this.transcriptions);\n          return;\n        }\n      }\n\n      this.transcriptions.push(message);\n      this.onMessagesChanged(this.transcriptions);\n    } else if (topic === \"error\") {\n      const payload = JSON.parse(decoded);\n      this.onAgentError(payload.message);\n    }\n  }\n\n  private onParticipantMetadataChanged(\n    _: string | undefined,\n    participant: RemoteParticipant | LocalParticipant\n  ) {\n    if (!participant.metadata || !participant.isAgent) {\n      return;\n    }\n    try {\n      const md = JSON.parse(participant.metadata);\n      if (md.remaining_seconds) {\n        this.remainingSeconds = md.remaining_seconds;\n      }\n      const { agent_state } = md;\n      if (\n        agent_state != \"speaking\" &&\n        agent_state != \"listening\" &&\n        agent_state != \"thinking\" &&\n        agent_state != \"warmup\" &&\n        agent_state != \"time_limit_exceeded\"\n      ) {\n        console.error(\"Unrecognized agent_state\", agent_state);\n        return;\n      }\n      this.agentState = agent_state;\n    } catch (e) {\n      console.error(\"Error on participant metadata cb\", e);\n    }\n  }\n}\n\ntype ConnectionStateChangedCallback = (state: SDKConnectionState) => void;\ntype OnTranscriptionsChangedCallback = (transcriptions: SDKSessionTranscription[]) => void;\ntype OnMicrophoneCallback = (enabled: boolean) => void;\ntype OnVolumeCallback = (values: number[], volume: number) => void;\ntype OnAgentStateChanged = (state: SDKAgentState) => void;\ntype OnRemainingSecondsChanged = (seconds: number) => void;\ntype OnAgentErrorCallback = (msg: string) => void;\ntype OnCanPlayAudioChanged = (allowed: boolean) => void;\n\nexport type SessionEngineParams = {\n  onConnectionStateChanged: ConnectionStateChangedCallback;\n  onMessagesChanged: OnTranscriptionsChangedCallback;\n  onMicrophoneChanged: OnMicrophoneCallback;\n  onAgentStateChanged: OnAgentStateChanged;\n  onRemainingSecondsChanged: OnRemainingSecondsChanged;\n  onAgentVolumeChanged: OnVolumeCallback;\n  onUserVolumeChanged: OnVolumeCallback;\n  onAgentError: OnAgentErrorCallback;\n  onCanPlayAudioChanged: OnCanPlayAudioChanged;\n};","import {\n  createAudioAnalyser,\n  LocalAudioTrack,\n  RemoteAudioTrack,\n} from \"livekit-client\";\n\nexport class TrackVolumeVisualizer {\n  private interval: any;\n  private callback: (values: number[], volume: number) => void;\n  private bands: number;\n  private cleanup: (() => Promise<void>) | null = null;\n\n  constructor({ bands, onTick }: TrackVolumeVisualizerParams) {\n    this.bands = bands;\n    this.callback = onTick;\n  }\n\n  setTrack(track: LocalAudioTrack | RemoteAudioTrack) {\n    if (this.interval) {\n      clearInterval(this.interval);\n    }\n    if (this.cleanup) {\n      this.cleanup();\n    }\n    const { analyser, cleanup, calculateVolume } = createAudioAnalyser(track, {\n      fftSize: 256,\n      smoothingTimeConstant: 0.7,\n    });\n    this.cleanup = cleanup;\n    const dataArray = new Float32Array(this.bands);\n\n    this.interval = setInterval(() => {\n      analyser.getFloatFrequencyData(dataArray);\n      const result: number[] = [];\n      for (let i = 0; i < dataArray.length; i++) {\n        result.push(Math.max(0, (dataArray[i] + 140)) / 140);\n      }\n      this.callback(result, calculateVolume());\n    }, 1000 / 100);\n  }\n}\n\ntype TrackVolumeVisualizerParams = {\n  bands: number;\n  onTick: (values: number[], volume: number) => void;\n};","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nimport type { Configuration } from '../configuration';\nimport type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';\nimport globalAxios from 'axios';\n// Some imports not used depending on template conditions\n// @ts-ignore\nimport { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';\n// @ts-ignore\nimport type { CreateCreditLedgerEntryRequest } from '../model';\n// @ts-ignore\nimport type { CreateCreditRequest } from '../model';\n// @ts-ignore\nimport type { Credit } from '../model';\n// @ts-ignore\nimport type { CreditLedgerEntry } from '../model';\n// @ts-ignore\nimport type { ListCredits200Response } from '../model';\n/**\n * CreditApi - axios parameter creator\n * @export\n */\nexport const CreditApiAxiosParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * Creates a new credit based on the input request data. \n         * @summary Create a new credit type\n         * @param {CreateCreditRequest} createCreditRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createCredit: async (createCreditRequest: CreateCreditRequest, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'createCreditRequest' is not null or undefined\n            assertParamExists('createCredit', 'createCreditRequest', createCreditRequest)\n            const localVarPath = `/api/v1/credit`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(createCreditRequest, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Creates a new credit ledger entry for human. Requires a human id.\n         * @summary Create a new credit ledger entry\n         * @param {string} credit \n         * @param {CreateCreditLedgerEntryRequest} createCreditLedgerEntryRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createCreditLedgerEntry: async (credit: string, createCreditLedgerEntryRequest: CreateCreditLedgerEntryRequest, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'credit' is not null or undefined\n            assertParamExists('createCreditLedgerEntry', 'credit', credit)\n            // verify required parameter 'createCreditLedgerEntryRequest' is not null or undefined\n            assertParamExists('createCreditLedgerEntry', 'createCreditLedgerEntryRequest', createCreditLedgerEntryRequest)\n            const localVarPath = `/api/v1/credit/{credit}/ledger`\n                .replace(`{${\"credit\"}}`, encodeURIComponent(String(credit)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(createCreditLedgerEntryRequest, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get a single credit object\n         * @param {string} credit \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getCredit: async (credit: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'credit' is not null or undefined\n            assertParamExists('getCredit', 'credit', credit)\n            const localVarPath = `/api/v1/credit/{credit}`\n                .replace(`{${\"credit\"}}`, encodeURIComponent(String(credit)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get the latest credit ledger entry for a human. Requires a human id.\n         * @param {string} credit \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getLatestCreditLedgerEntry: async (credit: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'credit' is not null or undefined\n            assertParamExists('getLatestCreditLedgerEntry', 'credit', credit)\n            const localVarPath = `/api/v1/credit/{credit}/ledger/latest`\n                .replace(`{${\"credit\"}}`, encodeURIComponent(String(credit)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get a list of credits\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listCredits: async (xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            const localVarPath = `/api/v1/credit/list`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * CreditApi - functional programming interface\n * @export\n */\nexport const CreditApiFp = function(configuration?: Configuration) {\n    const localVarAxiosParamCreator = CreditApiAxiosParamCreator(configuration)\n    return {\n        /**\n         * Creates a new credit based on the input request data. \n         * @summary Create a new credit type\n         * @param {CreateCreditRequest} createCreditRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createCredit(createCreditRequest: CreateCreditRequest, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credit>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createCredit(createCreditRequest, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['CreditApi.createCredit']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Creates a new credit ledger entry for human. Requires a human id.\n         * @summary Create a new credit ledger entry\n         * @param {string} credit \n         * @param {CreateCreditLedgerEntryRequest} createCreditLedgerEntryRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createCreditLedgerEntry(credit: string, createCreditLedgerEntryRequest: CreateCreditLedgerEntryRequest, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditLedgerEntry>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createCreditLedgerEntry(credit, createCreditLedgerEntryRequest, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['CreditApi.createCreditLedgerEntry']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * \n         * @summary Get a single credit object\n         * @param {string} credit \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getCredit(credit: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credit>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getCredit(credit, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['CreditApi.getCredit']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * \n         * @summary Get the latest credit ledger entry for a human. Requires a human id.\n         * @param {string} credit \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getLatestCreditLedgerEntry(credit: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditLedgerEntry>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestCreditLedgerEntry(credit, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['CreditApi.getLatestCreditLedgerEntry']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * \n         * @summary Get a list of credits\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listCredits(xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCredits200Response>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listCredits(xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['CreditApi.listCredits']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    }\n};\n\n/**\n * CreditApi - factory interface\n * @export\n */\nexport const CreditApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\n    const localVarFp = CreditApiFp(configuration)\n    return {\n        /**\n         * Creates a new credit based on the input request data. \n         * @summary Create a new credit type\n         * @param {CreateCreditRequest} createCreditRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createCredit(createCreditRequest: CreateCreditRequest, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Credit> {\n            return localVarFp.createCredit(createCreditRequest, xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Creates a new credit ledger entry for human. Requires a human id.\n         * @summary Create a new credit ledger entry\n         * @param {string} credit \n         * @param {CreateCreditLedgerEntryRequest} createCreditLedgerEntryRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createCreditLedgerEntry(credit: string, createCreditLedgerEntryRequest: CreateCreditLedgerEntryRequest, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CreditLedgerEntry> {\n            return localVarFp.createCreditLedgerEntry(credit, createCreditLedgerEntryRequest, xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get a single credit object\n         * @param {string} credit \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getCredit(credit: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Credit> {\n            return localVarFp.getCredit(credit, xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get the latest credit ledger entry for a human. Requires a human id.\n         * @param {string} credit \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getLatestCreditLedgerEntry(credit: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CreditLedgerEntry> {\n            return localVarFp.getLatestCreditLedgerEntry(credit, xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get a list of credits\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listCredits(xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListCredits200Response> {\n            return localVarFp.listCredits(xHumanId, options).then((request) => request(axios, basePath));\n        },\n    };\n};\n\n/**\n * CreditApi - object-oriented interface\n * @export\n * @class CreditApi\n * @extends {BaseAPI}\n */\nexport class CreditApi extends BaseAPI {\n    /**\n     * Creates a new credit based on the input request data. \n     * @summary Create a new credit type\n     * @param {CreateCreditRequest} createCreditRequest \n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof CreditApi\n     */\n    public createCredit(createCreditRequest: CreateCreditRequest, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return CreditApiFp(this.configuration).createCredit(createCreditRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * Creates a new credit ledger entry for human. Requires a human id.\n     * @summary Create a new credit ledger entry\n     * @param {string} credit \n     * @param {CreateCreditLedgerEntryRequest} createCreditLedgerEntryRequest \n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof CreditApi\n     */\n    public createCreditLedgerEntry(credit: string, createCreditLedgerEntryRequest: CreateCreditLedgerEntryRequest, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return CreditApiFp(this.configuration).createCreditLedgerEntry(credit, createCreditLedgerEntryRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get a single credit object\n     * @param {string} credit \n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof CreditApi\n     */\n    public getCredit(credit: string, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return CreditApiFp(this.configuration).getCredit(credit, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get the latest credit ledger entry for a human. Requires a human id.\n     * @param {string} credit \n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof CreditApi\n     */\n    public getLatestCreditLedgerEntry(credit: string, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return CreditApiFp(this.configuration).getLatestCreditLedgerEntry(credit, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get a list of credits\n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof CreditApi\n     */\n    public listCredits(xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return CreditApiFp(this.configuration).listCredits(xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nimport type { Configuration } from './configuration';\n// Some imports not used depending on template conditions\n// @ts-ignore\nimport type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';\nimport globalAxios from 'axios';\n\nexport const BASE_PATH = \"https://app.gabber.dev\".replace(/\\/+$/, \"\");\n\n/**\n *\n * @export\n */\nexport const COLLECTION_FORMATS = {\n    csv: \",\",\n    ssv: \" \",\n    tsv: \"\\t\",\n    pipes: \"|\",\n};\n\n/**\n *\n * @export\n * @interface RequestArgs\n */\nexport interface RequestArgs {\n    url: string;\n    options: RawAxiosRequestConfig;\n}\n\n/**\n *\n * @export\n * @class BaseAPI\n */\nexport class BaseAPI {\n    protected configuration: Configuration | undefined;\n\n    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {\n        if (configuration) {\n            this.configuration = configuration;\n            this.basePath = configuration.basePath ?? basePath;\n        }\n    }\n};\n\n/**\n *\n * @export\n * @class RequiredError\n * @extends {Error}\n */\nexport class RequiredError extends Error {\n    constructor(public field: string, msg?: string) {\n        super(msg);\n        this.name = \"RequiredError\"\n    }\n}\n\ninterface ServerMap {\n    [key: string]: {\n        url: string,\n        description: string,\n    }[];\n}\n\n/**\n *\n * @export\n */\nexport const operationServerMap: ServerMap = {\n}\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nimport type { Configuration } from \"./configuration\";\nimport type { RequestArgs } from \"./base\";\nimport type { AxiosInstance, AxiosResponse } from 'axios';\nimport { RequiredError } from \"./base\";\n\n/**\n *\n * @export\n */\nexport const DUMMY_BASE_URL = 'https://example.com'\n\n/**\n *\n * @throws {RequiredError}\n * @export\n */\nexport const assertParamExists = function (functionName: string, paramName: string, paramValue: unknown) {\n    if (paramValue === null || paramValue === undefined) {\n        throw new RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);\n    }\n}\n\n/**\n *\n * @export\n */\nexport const setApiKeyToObject = async function (object: any, keyParamName: string, configuration?: Configuration) {\n    if (configuration && configuration.apiKey) {\n        const localVarApiKeyValue = typeof configuration.apiKey === 'function'\n            ? await configuration.apiKey(keyParamName)\n            : await configuration.apiKey;\n        object[keyParamName] = localVarApiKeyValue;\n    }\n}\n\n/**\n *\n * @export\n */\nexport const setBasicAuthToObject = function (object: any, configuration?: Configuration) {\n    if (configuration && (configuration.username || configuration.password)) {\n        object[\"auth\"] = { username: configuration.username, password: configuration.password };\n    }\n}\n\n/**\n *\n * @export\n */\nexport const setBearerAuthToObject = async function (object: any, configuration?: Configuration) {\n    if (configuration && configuration.accessToken) {\n        const accessToken = typeof configuration.accessToken === 'function'\n            ? await configuration.accessToken()\n            : await configuration.accessToken;\n        object[\"Authorization\"] = \"Bearer \" + accessToken;\n    }\n}\n\n/**\n *\n * @export\n */\nexport const setOAuthToObject = async function (object: any, name: string, scopes: string[], configuration?: Configuration) {\n    if (configuration && configuration.accessToken) {\n        const localVarAccessTokenValue = typeof configuration.accessToken === 'function'\n            ? await configuration.accessToken(name, scopes)\n            : await configuration.accessToken;\n        object[\"Authorization\"] = \"Bearer \" + localVarAccessTokenValue;\n    }\n}\n\nfunction setFlattenedQueryParams(urlSearchParams: URLSearchParams, parameter: any, key: string = \"\"): void {\n    if (parameter == null) return;\n    if (typeof parameter === \"object\") {\n        if (Array.isArray(parameter)) {\n            (parameter as any[]).forEach(item => setFlattenedQueryParams(urlSearchParams, item, key));\n        } \n        else {\n            Object.keys(parameter).forEach(currentKey => \n                setFlattenedQueryParams(urlSearchParams, parameter[currentKey], `${key}${key !== '' ? '.' : ''}${currentKey}`)\n            );\n        }\n    } \n    else {\n        if (urlSearchParams.has(key)) {\n            urlSearchParams.append(key, parameter);\n        } \n        else {\n            urlSearchParams.set(key, parameter);\n        }\n    }\n}\n\n/**\n *\n * @export\n */\nexport const setSearchParams = function (url: URL, ...objects: any[]) {\n    const searchParams = new URLSearchParams(url.search);\n    setFlattenedQueryParams(searchParams, objects);\n    url.search = searchParams.toString();\n}\n\n/**\n *\n * @export\n */\nexport const serializeDataIfNeeded = function (value: any, requestOptions: any, configuration?: Configuration) {\n    const nonString = typeof value !== 'string';\n    const needsSerialization = nonString && configuration && configuration.isJsonMime\n        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])\n        : nonString;\n    return needsSerialization\n        ? JSON.stringify(value !== undefined ? value : {})\n        : (value || \"\");\n}\n\n/**\n *\n * @export\n */\nexport const toPathString = function (url: URL) {\n    return url.pathname + url.search + url.hash\n}\n\n/**\n *\n * @export\n */\nexport const createRequestFunction = function (axiosArgs: RequestArgs, globalAxios: AxiosInstance, BASE_PATH: string, configuration?: Configuration) {\n    return <T = unknown, R = AxiosResponse<T>>(axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {\n        const axiosRequestArgs = {...axiosArgs.options, url: (axios.defaults.baseURL ? '' : configuration?.basePath ?? basePath) + axiosArgs.url};\n        return axios.request<T, R>(axiosRequestArgs);\n    };\n}\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nimport type { Configuration } from '../configuration';\nimport type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';\nimport globalAxios from 'axios';\n// Some imports not used depending on template conditions\n// @ts-ignore\nimport { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';\n// @ts-ignore\nimport type { ChatCompletionRequest } from '../model';\n// @ts-ignore\nimport type { ChatCompletionResponse } from '../model';\n// @ts-ignore\nimport type { ChatCompletionStreamResponse } from '../model';\n/**\n * InferenceApi - axios parameter creator\n * @export\n */\nexport const InferenceApiAxiosParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * Given messages, generates LLM output text and optionally speech\n         * @summary Chat Completions (+ Voice)\n         * @param {ChatCompletionRequest} chatCompletionRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        chatCompletions: async (chatCompletionRequest: ChatCompletionRequest, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'chatCompletionRequest' is not null or undefined\n            assertParamExists('chatCompletions', 'chatCompletionRequest', chatCompletionRequest)\n            const localVarPath = `/api/v1/chat/completions`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(chatCompletionRequest, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * InferenceApi - functional programming interface\n * @export\n */\nexport const InferenceApiFp = function(configuration?: Configuration) {\n    const localVarAxiosParamCreator = InferenceApiAxiosParamCreator(configuration)\n    return {\n        /**\n         * Given messages, generates LLM output text and optionally speech\n         * @summary Chat Completions (+ Voice)\n         * @param {ChatCompletionRequest} chatCompletionRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async chatCompletions(chatCompletionRequest: ChatCompletionRequest, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatCompletionResponse>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.chatCompletions(chatCompletionRequest, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['InferenceApi.chatCompletions']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    }\n};\n\n/**\n * InferenceApi - factory interface\n * @export\n */\nexport const InferenceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\n    const localVarFp = InferenceApiFp(configuration)\n    return {\n        /**\n         * Given messages, generates LLM output text and optionally speech\n         * @summary Chat Completions (+ Voice)\n         * @param {ChatCompletionRequest} chatCompletionRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        chatCompletions(chatCompletionRequest: ChatCompletionRequest, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ChatCompletionResponse> {\n            return localVarFp.chatCompletions(chatCompletionRequest, xHumanId, options).then((request) => request(axios, basePath));\n        },\n    };\n};\n\n/**\n * InferenceApi - object-oriented interface\n * @export\n * @class InferenceApi\n * @extends {BaseAPI}\n */\nexport class InferenceApi extends BaseAPI {\n    /**\n     * Given messages, generates LLM output text and optionally speech\n     * @summary Chat Completions (+ Voice)\n     * @param {ChatCompletionRequest} chatCompletionRequest \n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof InferenceApi\n     */\n    public chatCompletions(chatCompletionRequest: ChatCompletionRequest, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return InferenceApiFp(this.configuration).chatCompletions(chatCompletionRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nimport type { Configuration } from '../configuration';\nimport type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';\nimport globalAxios from 'axios';\n// Some imports not used depending on template conditions\n// @ts-ignore\nimport { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';\n// @ts-ignore\nimport type { Context } from '../model';\n// @ts-ignore\nimport type { ContextCreateRequest } from '../model';\n// @ts-ignore\nimport type { ContextMessage } from '../model';\n// @ts-ignore\nimport type { ContextMessageCreateParams } from '../model';\n// @ts-ignore\nimport type { LLM } from '../model';\n// @ts-ignore\nimport type { ListContextMessages200Response } from '../model';\n// @ts-ignore\nimport type { ListLLMs200Response } from '../model';\n/**\n * LLMApi - axios parameter creator\n * @export\n */\nexport const LLMApiAxiosParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * Create a new Context with the given configuration. \n         * @summary Create a new Context.\n         * @param {ContextCreateRequest} contextCreateRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createContext: async (contextCreateRequest: ContextCreateRequest, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'contextCreateRequest' is not null or undefined\n            assertParamExists('createContext', 'contextCreateRequest', contextCreateRequest)\n            const localVarPath = `/api/v1/llm/context`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(contextCreateRequest, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new ContextMessage with the given configuration. \n         * @summary Create a new ContextMessage.\n         * @param {string} context The unique identifier of the Context.\n         * @param {ContextMessageCreateParams} contextMessageCreateParams \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createContextMessage: async (context: string, contextMessageCreateParams: ContextMessageCreateParams, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'context' is not null or undefined\n            assertParamExists('createContextMessage', 'context', context)\n            // verify required parameter 'contextMessageCreateParams' is not null or undefined\n            assertParamExists('createContextMessage', 'contextMessageCreateParams', contextMessageCreateParams)\n            const localVarPath = `/api/v1/llm/context/{context}/message`\n                .replace(`{${\"context\"}}`, encodeURIComponent(String(context)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(contextMessageCreateParams, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Retrieve the Context with the given identifier. \n         * @summary Retrieve a Context.\n         * @param {string} context The unique identifier of the Context.\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getContext: async (context: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'context' is not null or undefined\n            assertParamExists('getContext', 'context', context)\n            const localVarPath = `/api/v1/llm/context/{context}`\n                .replace(`{${\"context\"}}`, encodeURIComponent(String(context)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Retrieve the ContextMessage with the given identifier. \n         * @summary Retrieve a ContextMessage.\n         * @param {string} context The unique identifier of the Context.\n         * @param {string} message The unique identifier of the ContextMessage.\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getContextMessage: async (context: string, message: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'context' is not null or undefined\n            assertParamExists('getContextMessage', 'context', context)\n            // verify required parameter 'message' is not null or undefined\n            assertParamExists('getContextMessage', 'message', message)\n            const localVarPath = `/api/v1/llm/context/{context}/message/{message}`\n                .replace(`{${\"context\"}}`, encodeURIComponent(String(context)))\n                .replace(`{${\"message\"}}`, encodeURIComponent(String(message)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get a list of llms\n         * @param {string} llm \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getLLM: async (llm: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'llm' is not null or undefined\n            assertParamExists('getLLM', 'llm', llm)\n            const localVarPath = `/api/v1/llm/{llm}`\n                .replace(`{${\"llm\"}}`, encodeURIComponent(String(llm)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List all ContextMessages associated with the given Context. \n         * @summary List ContextMessages.\n         * @param {string} context The unique identifier of the Context.\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listContextMessages: async (context: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'context' is not null or undefined\n            assertParamExists('listContextMessages', 'context', context)\n            const localVarPath = `/api/v1/llm/context/{context}/message/list`\n                .replace(`{${\"context\"}}`, encodeURIComponent(String(context)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get a list of llms\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listLLMs: async (xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            const localVarPath = `/api/v1/llm/list`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * LLMApi - functional programming interface\n * @export\n */\nexport const LLMApiFp = function(configuration?: Configuration) {\n    const localVarAxiosParamCreator = LLMApiAxiosParamCreator(configuration)\n    return {\n        /**\n         * Create a new Context with the given configuration. \n         * @summary Create a new Context.\n         * @param {ContextCreateRequest} contextCreateRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createContext(contextCreateRequest: ContextCreateRequest, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Context>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createContext(contextCreateRequest, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['LLMApi.createContext']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new ContextMessage with the given configuration. \n         * @summary Create a new ContextMessage.\n         * @param {string} context The unique identifier of the Context.\n         * @param {ContextMessageCreateParams} contextMessageCreateParams \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createContextMessage(context: string, contextMessageCreateParams: ContextMessageCreateParams, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextMessage>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createContextMessage(context, contextMessageCreateParams, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['LLMApi.createContextMessage']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Retrieve the Context with the given identifier. \n         * @summary Retrieve a Context.\n         * @param {string} context The unique identifier of the Context.\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getContext(context: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Context>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getContext(context, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['LLMApi.getContext']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Retrieve the ContextMessage with the given identifier. \n         * @summary Retrieve a ContextMessage.\n         * @param {string} context The unique identifier of the Context.\n         * @param {string} message The unique identifier of the ContextMessage.\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getContextMessage(context: string, message: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextMessage>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getContextMessage(context, message, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['LLMApi.getContextMessage']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * \n         * @summary Get a list of llms\n         * @param {string} llm \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getLLM(llm: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LLM>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getLLM(llm, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['LLMApi.getLLM']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List all ContextMessages associated with the given Context. \n         * @summary List ContextMessages.\n         * @param {string} context The unique identifier of the Context.\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listContextMessages(context: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListContextMessages200Response>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listContextMessages(context, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['LLMApi.listContextMessages']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * \n         * @summary Get a list of llms\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listLLMs(xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListLLMs200Response>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listLLMs(xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['LLMApi.listLLMs']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    }\n};\n\n/**\n * LLMApi - factory interface\n * @export\n */\nexport const LLMApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\n    const localVarFp = LLMApiFp(configuration)\n    return {\n        /**\n         * Create a new Context with the given configuration. \n         * @summary Create a new Context.\n         * @param {ContextCreateRequest} contextCreateRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createContext(contextCreateRequest: ContextCreateRequest, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Context> {\n            return localVarFp.createContext(contextCreateRequest, xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new ContextMessage with the given configuration. \n         * @summary Create a new ContextMessage.\n         * @param {string} context The unique identifier of the Context.\n         * @param {ContextMessageCreateParams} contextMessageCreateParams \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createContextMessage(context: string, contextMessageCreateParams: ContextMessageCreateParams, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContextMessage> {\n            return localVarFp.createContextMessage(context, contextMessageCreateParams, xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Retrieve the Context with the given identifier. \n         * @summary Retrieve a Context.\n         * @param {string} context The unique identifier of the Context.\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getContext(context: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Context> {\n            return localVarFp.getContext(context, xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Retrieve the ContextMessage with the given identifier. \n         * @summary Retrieve a ContextMessage.\n         * @param {string} context The unique identifier of the Context.\n         * @param {string} message The unique identifier of the ContextMessage.\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getContextMessage(context: string, message: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ContextMessage> {\n            return localVarFp.getContextMessage(context, message, xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get a list of llms\n         * @param {string} llm \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getLLM(llm: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<LLM> {\n            return localVarFp.getLLM(llm, xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List all ContextMessages associated with the given Context. \n         * @summary List ContextMessages.\n         * @param {string} context The unique identifier of the Context.\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listContextMessages(context: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListContextMessages200Response> {\n            return localVarFp.listContextMessages(context, xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get a list of llms\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listLLMs(xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListLLMs200Response> {\n            return localVarFp.listLLMs(xHumanId, options).then((request) => request(axios, basePath));\n        },\n    };\n};\n\n/**\n * LLMApi - object-oriented interface\n * @export\n * @class LLMApi\n * @extends {BaseAPI}\n */\nexport class LLMApi extends BaseAPI {\n    /**\n     * Create a new Context with the given configuration. \n     * @summary Create a new Context.\n     * @param {ContextCreateRequest} contextCreateRequest \n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof LLMApi\n     */\n    public createContext(contextCreateRequest: ContextCreateRequest, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return LLMApiFp(this.configuration).createContext(contextCreateRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * Create a new ContextMessage with the given configuration. \n     * @summary Create a new ContextMessage.\n     * @param {string} context The unique identifier of the Context.\n     * @param {ContextMessageCreateParams} contextMessageCreateParams \n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof LLMApi\n     */\n    public createContextMessage(context: string, contextMessageCreateParams: ContextMessageCreateParams, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return LLMApiFp(this.configuration).createContextMessage(context, contextMessageCreateParams, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * Retrieve the Context with the given identifier. \n     * @summary Retrieve a Context.\n     * @param {string} context The unique identifier of the Context.\n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof LLMApi\n     */\n    public getContext(context: string, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return LLMApiFp(this.configuration).getContext(context, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * Retrieve the ContextMessage with the given identifier. \n     * @summary Retrieve a ContextMessage.\n     * @param {string} context The unique identifier of the Context.\n     * @param {string} message The unique identifier of the ContextMessage.\n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof LLMApi\n     */\n    public getContextMessage(context: string, message: string, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return LLMApiFp(this.configuration).getContextMessage(context, message, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get a list of llms\n     * @param {string} llm \n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof LLMApi\n     */\n    public getLLM(llm: string, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return LLMApiFp(this.configuration).getLLM(llm, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * List all ContextMessages associated with the given Context. \n     * @summary List ContextMessages.\n     * @param {string} context The unique identifier of the Context.\n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof LLMApi\n     */\n    public listContextMessages(context: string, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return LLMApiFp(this.configuration).listContextMessages(context, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get a list of llms\n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof LLMApi\n     */\n    public listLLMs(xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return LLMApiFp(this.configuration).listLLMs(xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nimport type { Configuration } from '../configuration';\nimport type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';\nimport globalAxios from 'axios';\n// Some imports not used depending on template conditions\n// @ts-ignore\nimport { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';\n// @ts-ignore\nimport type { CreatePersonaRequest } from '../model';\n// @ts-ignore\nimport type { DeletePersona200Response } from '../model';\n// @ts-ignore\nimport type { ListPersonas200Response } from '../model';\n// @ts-ignore\nimport type { Persona } from '../model';\n// @ts-ignore\nimport type { UpdatePersonaRequest } from '../model';\n/**\n * PersonaApi - axios parameter creator\n * @export\n */\nexport const PersonaApiAxiosParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * \n         * @summary Get a persona\n         * @param {CreatePersonaRequest} createPersonaRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createPersona: async (createPersonaRequest: CreatePersonaRequest, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'createPersonaRequest' is not null or undefined\n            assertParamExists('createPersona', 'createPersonaRequest', createPersonaRequest)\n            const localVarPath = `/api/v1/persona`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(createPersonaRequest, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Delete a persona\n         * @param {string} personaId \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deletePersona: async (personaId: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'personaId' is not null or undefined\n            assertParamExists('deletePersona', 'personaId', personaId)\n            const localVarPath = `/api/v1/persona/{persona_id}`\n                .replace(`{${\"persona_id\"}}`, encodeURIComponent(String(personaId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get a persona\n         * @param {string} personaId \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getPersona: async (personaId: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'personaId' is not null or undefined\n            assertParamExists('getPersona', 'personaId', personaId)\n            const localVarPath = `/api/v1/persona/{persona_id}`\n                .replace(`{${\"persona_id\"}}`, encodeURIComponent(String(personaId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get a list of personas\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listPersonas: async (xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            const localVarPath = `/api/v1/persona/list`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Update a persona\n         * @param {string} personaId \n         * @param {UpdatePersonaRequest} updatePersonaRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updatePersona: async (personaId: string, updatePersonaRequest: UpdatePersonaRequest, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'personaId' is not null or undefined\n            assertParamExists('updatePersona', 'personaId', personaId)\n            // verify required parameter 'updatePersonaRequest' is not null or undefined\n            assertParamExists('updatePersona', 'updatePersonaRequest', updatePersonaRequest)\n            const localVarPath = `/api/v1/persona/{persona_id}`\n                .replace(`{${\"persona_id\"}}`, encodeURIComponent(String(personaId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(updatePersonaRequest, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * PersonaApi - functional programming interface\n * @export\n */\nexport const PersonaApiFp = function(configuration?: Configuration) {\n    const localVarAxiosParamCreator = PersonaApiAxiosParamCreator(configuration)\n    return {\n        /**\n         * \n         * @summary Get a persona\n         * @param {CreatePersonaRequest} createPersonaRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createPersona(createPersonaRequest: CreatePersonaRequest, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createPersona(createPersonaRequest, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['PersonaApi.createPersona']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * \n         * @summary Delete a persona\n         * @param {string} personaId \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async deletePersona(personaId: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletePersona200Response>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePersona(personaId, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['PersonaApi.deletePersona']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * \n         * @summary Get a persona\n         * @param {string} personaId \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getPersona(personaId: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersona(personaId, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['PersonaApi.getPersona']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * \n         * @summary Get a list of personas\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listPersonas(xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPersonas200Response>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listPersonas(xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['PersonaApi.listPersonas']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * \n         * @summary Update a persona\n         * @param {string} personaId \n         * @param {UpdatePersonaRequest} updatePersonaRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async updatePersona(personaId: string, updatePersonaRequest: UpdatePersonaRequest, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Persona>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePersona(personaId, updatePersonaRequest, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['PersonaApi.updatePersona']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    }\n};\n\n/**\n * PersonaApi - factory interface\n * @export\n */\nexport const PersonaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\n    const localVarFp = PersonaApiFp(configuration)\n    return {\n        /**\n         * \n         * @summary Get a persona\n         * @param {CreatePersonaRequest} createPersonaRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createPersona(createPersonaRequest: CreatePersonaRequest, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Persona> {\n            return localVarFp.createPersona(createPersonaRequest, xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Delete a persona\n         * @param {string} personaId \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deletePersona(personaId: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<DeletePersona200Response> {\n            return localVarFp.deletePersona(personaId, xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get a persona\n         * @param {string} personaId \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getPersona(personaId: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Persona> {\n            return localVarFp.getPersona(personaId, xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get a list of personas\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listPersonas(xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListPersonas200Response> {\n            return localVarFp.listPersonas(xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Update a persona\n         * @param {string} personaId \n         * @param {UpdatePersonaRequest} updatePersonaRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updatePersona(personaId: string, updatePersonaRequest: UpdatePersonaRequest, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Persona> {\n            return localVarFp.updatePersona(personaId, updatePersonaRequest, xHumanId, options).then((request) => request(axios, basePath));\n        },\n    };\n};\n\n/**\n * PersonaApi - object-oriented interface\n * @export\n * @class PersonaApi\n * @extends {BaseAPI}\n */\nexport class PersonaApi extends BaseAPI {\n    /**\n     * \n     * @summary Get a persona\n     * @param {CreatePersonaRequest} createPersonaRequest \n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof PersonaApi\n     */\n    public createPersona(createPersonaRequest: CreatePersonaRequest, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return PersonaApiFp(this.configuration).createPersona(createPersonaRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Delete a persona\n     * @param {string} personaId \n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof PersonaApi\n     */\n    public deletePersona(personaId: string, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return PersonaApiFp(this.configuration).deletePersona(personaId, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get a persona\n     * @param {string} personaId \n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof PersonaApi\n     */\n    public getPersona(personaId: string, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return PersonaApiFp(this.configuration).getPersona(personaId, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get a list of personas\n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof PersonaApi\n     */\n    public listPersonas(xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return PersonaApiFp(this.configuration).listPersonas(xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Update a persona\n     * @param {string} personaId \n     * @param {UpdatePersonaRequest} updatePersonaRequest \n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof PersonaApi\n     */\n    public updatePersona(personaId: string, updatePersonaRequest: UpdatePersonaRequest, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return PersonaApiFp(this.configuration).updatePersona(personaId, updatePersonaRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nimport type { Configuration } from '../configuration';\nimport type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';\nimport globalAxios from 'axios';\n// Some imports not used depending on template conditions\n// @ts-ignore\nimport { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';\n// @ts-ignore\nimport type { GetRealtimeSessionMessages200Response } from '../model';\n// @ts-ignore\nimport type { GetRealtimeSessionTimeline200Response } from '../model';\n// @ts-ignore\nimport type { ListRealtimeSessions200Response } from '../model';\n// @ts-ignore\nimport type { RealtimeSession } from '../model';\n// @ts-ignore\nimport type { RealtimeSessionConfigUpdate } from '../model';\n// @ts-ignore\nimport type { RealtimeSessionStartResponse } from '../model';\n// @ts-ignore\nimport type { StartRealtimeSessionRequest } from '../model';\n/**\n * RealtimeApi - axios parameter creator\n * @export\n */\nexport const RealtimeApiAxiosParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * End the RealtimeSession with the given identifier. \n         * @summary End a RealtimeSession.\n         * @param {string} session The unique identifier of the RealtimeSession.\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        endRealtimeSession: async (session: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'session' is not null or undefined\n            assertParamExists('endRealtimeSession', 'session', session)\n            const localVarPath = `/api/v1/realtime/{session}/end`\n                .replace(`{${\"session\"}}`, encodeURIComponent(String(session)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * End the RealtimeSession with the given identifier. \n         * @summary Get a RealtimeSession.\n         * @param {string} session The unique identifier of the RealtimeSession.\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getRealtimeSession: async (session: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'session' is not null or undefined\n            assertParamExists('getRealtimeSession', 'session', session)\n            const localVarPath = `/api/v1/realtime/{session}`\n                .replace(`{${\"session\"}}`, encodeURIComponent(String(session)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get all ContextMessages associated with the given RealtimeSession. \n         * @summary Get a RealtimeSession messages.\n         * @param {string} session The unique identifier of the RealtimeSession.\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getRealtimeSessionMessages: async (session: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'session' is not null or undefined\n            assertParamExists('getRealtimeSessionMessages', 'session', session)\n            const localVarPath = `/api/v1/realtime/{session}/messages`\n                .replace(`{${\"session\"}}`, encodeURIComponent(String(session)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get the timeline of the RealtimeSession with the given identifier. \n         * @summary Get a RealtimeSession timeline.\n         * @param {string} session The unique identifier of the RealtimeSession.\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getRealtimeSessionTimeline: async (session: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'session' is not null or undefined\n            assertParamExists('getRealtimeSessionTimeline', 'session', session)\n            const localVarPath = `/api/v1/realtime/{session}/timeline`\n                .replace(`{${\"session\"}}`, encodeURIComponent(String(session)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List all Realtime Sessions. \n         * @summary List Realtime Sessions.\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listRealtimeSessions: async (xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            const localVarPath = `/api/v1/realtime/list`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Start a new RealtimeSession with the given configuration. \n         * @summary Start a new RealtimeSession.\n         * @param {StartRealtimeSessionRequest} startRealtimeSessionRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        startRealtimeSession: async (startRealtimeSessionRequest: StartRealtimeSessionRequest, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'startRealtimeSessionRequest' is not null or undefined\n            assertParamExists('startRealtimeSession', 'startRealtimeSessionRequest', startRealtimeSessionRequest)\n            const localVarPath = `/api/v1/realtime/start`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(startRealtimeSessionRequest, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Update the RealtimeSession with the given identifier. \n         * @summary Update a RealtimeSession.\n         * @param {string} session The unique identifier of the RealtimeSession.\n         * @param {RealtimeSessionConfigUpdate} realtimeSessionConfigUpdate \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateRealtimeSession: async (session: string, realtimeSessionConfigUpdate: RealtimeSessionConfigUpdate, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'session' is not null or undefined\n            assertParamExists('updateRealtimeSession', 'session', session)\n            // verify required parameter 'realtimeSessionConfigUpdate' is not null or undefined\n            assertParamExists('updateRealtimeSession', 'realtimeSessionConfigUpdate', realtimeSessionConfigUpdate)\n            const localVarPath = `/api/v1/realtime/{session}/update`\n                .replace(`{${\"session\"}}`, encodeURIComponent(String(session)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(realtimeSessionConfigUpdate, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * RealtimeApi - functional programming interface\n * @export\n */\nexport const RealtimeApiFp = function(configuration?: Configuration) {\n    const localVarAxiosParamCreator = RealtimeApiAxiosParamCreator(configuration)\n    return {\n        /**\n         * End the RealtimeSession with the given identifier. \n         * @summary End a RealtimeSession.\n         * @param {string} session The unique identifier of the RealtimeSession.\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async endRealtimeSession(session: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RealtimeSession>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.endRealtimeSession(session, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['RealtimeApi.endRealtimeSession']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * End the RealtimeSession with the given identifier. \n         * @summary Get a RealtimeSession.\n         * @param {string} session The unique identifier of the RealtimeSession.\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getRealtimeSession(session: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RealtimeSession>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getRealtimeSession(session, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['RealtimeApi.getRealtimeSession']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get all ContextMessages associated with the given RealtimeSession. \n         * @summary Get a RealtimeSession messages.\n         * @param {string} session The unique identifier of the RealtimeSession.\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getRealtimeSessionMessages(session: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRealtimeSessionMessages200Response>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getRealtimeSessionMessages(session, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['RealtimeApi.getRealtimeSessionMessages']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get the timeline of the RealtimeSession with the given identifier. \n         * @summary Get a RealtimeSession timeline.\n         * @param {string} session The unique identifier of the RealtimeSession.\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getRealtimeSessionTimeline(session: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRealtimeSessionTimeline200Response>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getRealtimeSessionTimeline(session, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['RealtimeApi.getRealtimeSessionTimeline']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List all Realtime Sessions. \n         * @summary List Realtime Sessions.\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listRealtimeSessions(xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListRealtimeSessions200Response>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listRealtimeSessions(xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['RealtimeApi.listRealtimeSessions']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Start a new RealtimeSession with the given configuration. \n         * @summary Start a new RealtimeSession.\n         * @param {StartRealtimeSessionRequest} startRealtimeSessionRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async startRealtimeSession(startRealtimeSessionRequest: StartRealtimeSessionRequest, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RealtimeSessionStartResponse>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.startRealtimeSession(startRealtimeSessionRequest, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['RealtimeApi.startRealtimeSession']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Update the RealtimeSession with the given identifier. \n         * @summary Update a RealtimeSession.\n         * @param {string} session The unique identifier of the RealtimeSession.\n         * @param {RealtimeSessionConfigUpdate} realtimeSessionConfigUpdate \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async updateRealtimeSession(session: string, realtimeSessionConfigUpdate: RealtimeSessionConfigUpdate, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RealtimeSession>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRealtimeSession(session, realtimeSessionConfigUpdate, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['RealtimeApi.updateRealtimeSession']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    }\n};\n\n/**\n * RealtimeApi - factory interface\n * @export\n */\nexport const RealtimeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\n    const localVarFp = RealtimeApiFp(configuration)\n    return {\n        /**\n         * End the RealtimeSession with the given identifier. \n         * @summary End a RealtimeSession.\n         * @param {string} session The unique identifier of the RealtimeSession.\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        endRealtimeSession(session: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<RealtimeSession> {\n            return localVarFp.endRealtimeSession(session, xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * End the RealtimeSession with the given identifier. \n         * @summary Get a RealtimeSession.\n         * @param {string} session The unique identifier of the RealtimeSession.\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getRealtimeSession(session: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<RealtimeSession> {\n            return localVarFp.getRealtimeSession(session, xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get all ContextMessages associated with the given RealtimeSession. \n         * @summary Get a RealtimeSession messages.\n         * @param {string} session The unique identifier of the RealtimeSession.\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getRealtimeSessionMessages(session: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRealtimeSessionMessages200Response> {\n            return localVarFp.getRealtimeSessionMessages(session, xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get the timeline of the RealtimeSession with the given identifier. \n         * @summary Get a RealtimeSession timeline.\n         * @param {string} session The unique identifier of the RealtimeSession.\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getRealtimeSessionTimeline(session: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRealtimeSessionTimeline200Response> {\n            return localVarFp.getRealtimeSessionTimeline(session, xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List all Realtime Sessions. \n         * @summary List Realtime Sessions.\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listRealtimeSessions(xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListRealtimeSessions200Response> {\n            return localVarFp.listRealtimeSessions(xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Start a new RealtimeSession with the given configuration. \n         * @summary Start a new RealtimeSession.\n         * @param {StartRealtimeSessionRequest} startRealtimeSessionRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        startRealtimeSession(startRealtimeSessionRequest: StartRealtimeSessionRequest, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<RealtimeSessionStartResponse> {\n            return localVarFp.startRealtimeSession(startRealtimeSessionRequest, xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Update the RealtimeSession with the given identifier. \n         * @summary Update a RealtimeSession.\n         * @param {string} session The unique identifier of the RealtimeSession.\n         * @param {RealtimeSessionConfigUpdate} realtimeSessionConfigUpdate \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateRealtimeSession(session: string, realtimeSessionConfigUpdate: RealtimeSessionConfigUpdate, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<RealtimeSession> {\n            return localVarFp.updateRealtimeSession(session, realtimeSessionConfigUpdate, xHumanId, options).then((request) => request(axios, basePath));\n        },\n    };\n};\n\n/**\n * RealtimeApi - object-oriented interface\n * @export\n * @class RealtimeApi\n * @extends {BaseAPI}\n */\nexport class RealtimeApi extends BaseAPI {\n    /**\n     * End the RealtimeSession with the given identifier. \n     * @summary End a RealtimeSession.\n     * @param {string} session The unique identifier of the RealtimeSession.\n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof RealtimeApi\n     */\n    public endRealtimeSession(session: string, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return RealtimeApiFp(this.configuration).endRealtimeSession(session, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * End the RealtimeSession with the given identifier. \n     * @summary Get a RealtimeSession.\n     * @param {string} session The unique identifier of the RealtimeSession.\n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof RealtimeApi\n     */\n    public getRealtimeSession(session: string, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return RealtimeApiFp(this.configuration).getRealtimeSession(session, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * Get all ContextMessages associated with the given RealtimeSession. \n     * @summary Get a RealtimeSession messages.\n     * @param {string} session The unique identifier of the RealtimeSession.\n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof RealtimeApi\n     */\n    public getRealtimeSessionMessages(session: string, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return RealtimeApiFp(this.configuration).getRealtimeSessionMessages(session, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * Get the timeline of the RealtimeSession with the given identifier. \n     * @summary Get a RealtimeSession timeline.\n     * @param {string} session The unique identifier of the RealtimeSession.\n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof RealtimeApi\n     */\n    public getRealtimeSessionTimeline(session: string, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return RealtimeApiFp(this.configuration).getRealtimeSessionTimeline(session, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * List all Realtime Sessions. \n     * @summary List Realtime Sessions.\n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof RealtimeApi\n     */\n    public listRealtimeSessions(xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return RealtimeApiFp(this.configuration).listRealtimeSessions(xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * Start a new RealtimeSession with the given configuration. \n     * @summary Start a new RealtimeSession.\n     * @param {StartRealtimeSessionRequest} startRealtimeSessionRequest \n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof RealtimeApi\n     */\n    public startRealtimeSession(startRealtimeSessionRequest: StartRealtimeSessionRequest, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return RealtimeApiFp(this.configuration).startRealtimeSession(startRealtimeSessionRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * Update the RealtimeSession with the given identifier. \n     * @summary Update a RealtimeSession.\n     * @param {string} session The unique identifier of the RealtimeSession.\n     * @param {RealtimeSessionConfigUpdate} realtimeSessionConfigUpdate \n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof RealtimeApi\n     */\n    public updateRealtimeSession(session: string, realtimeSessionConfigUpdate: RealtimeSessionConfigUpdate, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return RealtimeApiFp(this.configuration).updateRealtimeSession(session, realtimeSessionConfigUpdate, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nimport type { Configuration } from '../configuration';\nimport type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';\nimport globalAxios from 'axios';\n// Some imports not used depending on template conditions\n// @ts-ignore\nimport { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';\n// @ts-ignore\nimport type { CreateScenarioRequest } from '../model';\n// @ts-ignore\nimport type { DeleteScenario200Response } from '../model';\n// @ts-ignore\nimport type { ListScenarios200Response } from '../model';\n// @ts-ignore\nimport type { Scenario } from '../model';\n// @ts-ignore\nimport type { UpdateScenarioRequest } from '../model';\n/**\n * ScenarioApi - axios parameter creator\n * @export\n */\nexport const ScenarioApiAxiosParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * \n         * @summary Create a scenario\n         * @param {CreateScenarioRequest} createScenarioRequest \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createScenario: async (createScenarioRequest: CreateScenarioRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'createScenarioRequest' is not null or undefined\n            assertParamExists('createScenario', 'createScenarioRequest', createScenarioRequest)\n            const localVarPath = `/api/v1/scenario`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(createScenarioRequest, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Delete a scenario\n         * @param {string} scenarioId \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteScenario: async (scenarioId: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'scenarioId' is not null or undefined\n            assertParamExists('deleteScenario', 'scenarioId', scenarioId)\n            const localVarPath = `/api/v1/scenario/{scenario_id}`\n                .replace(`{${\"scenario_id\"}}`, encodeURIComponent(String(scenarioId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get a scenario\n         * @param {string} scenarioId \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getScenario: async (scenarioId: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'scenarioId' is not null or undefined\n            assertParamExists('getScenario', 'scenarioId', scenarioId)\n            const localVarPath = `/api/v1/scenario/{scenario_id}`\n                .replace(`{${\"scenario_id\"}}`, encodeURIComponent(String(scenarioId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get a list of scenarios\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listScenarios: async (xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            const localVarPath = `/api/v1/scenario/list`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Update a scenario\n         * @param {string} scenarioId \n         * @param {UpdateScenarioRequest} updateScenarioRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateScenario: async (scenarioId: string, updateScenarioRequest: UpdateScenarioRequest, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'scenarioId' is not null or undefined\n            assertParamExists('updateScenario', 'scenarioId', scenarioId)\n            // verify required parameter 'updateScenarioRequest' is not null or undefined\n            assertParamExists('updateScenario', 'updateScenarioRequest', updateScenarioRequest)\n            const localVarPath = `/api/v1/scenario/{scenario_id}`\n                .replace(`{${\"scenario_id\"}}`, encodeURIComponent(String(scenarioId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(updateScenarioRequest, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * ScenarioApi - functional programming interface\n * @export\n */\nexport const ScenarioApiFp = function(configuration?: Configuration) {\n    const localVarAxiosParamCreator = ScenarioApiAxiosParamCreator(configuration)\n    return {\n        /**\n         * \n         * @summary Create a scenario\n         * @param {CreateScenarioRequest} createScenarioRequest \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createScenario(createScenarioRequest: CreateScenarioRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createScenario(createScenarioRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.createScenario']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * \n         * @summary Delete a scenario\n         * @param {string} scenarioId \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async deleteScenario(scenarioId: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteScenario200Response>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScenario(scenarioId, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.deleteScenario']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * \n         * @summary Get a scenario\n         * @param {string} scenarioId \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getScenario(scenarioId: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenario(scenarioId, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.getScenario']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * \n         * @summary Get a list of scenarios\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listScenarios(xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListScenarios200Response>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listScenarios(xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.listScenarios']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * \n         * @summary Update a scenario\n         * @param {string} scenarioId \n         * @param {UpdateScenarioRequest} updateScenarioRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async updateScenario(scenarioId: string, updateScenarioRequest: UpdateScenarioRequest, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScenario(scenarioId, updateScenarioRequest, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.updateScenario']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    }\n};\n\n/**\n * ScenarioApi - factory interface\n * @export\n */\nexport const ScenarioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\n    const localVarFp = ScenarioApiFp(configuration)\n    return {\n        /**\n         * \n         * @summary Create a scenario\n         * @param {CreateScenarioRequest} createScenarioRequest \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createScenario(createScenarioRequest: CreateScenarioRequest, options?: RawAxiosRequestConfig): AxiosPromise<Scenario> {\n            return localVarFp.createScenario(createScenarioRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Delete a scenario\n         * @param {string} scenarioId \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteScenario(scenarioId: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteScenario200Response> {\n            return localVarFp.deleteScenario(scenarioId, xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get a scenario\n         * @param {string} scenarioId \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getScenario(scenarioId: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Scenario> {\n            return localVarFp.getScenario(scenarioId, xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get a list of scenarios\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listScenarios(xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListScenarios200Response> {\n            return localVarFp.listScenarios(xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Update a scenario\n         * @param {string} scenarioId \n         * @param {UpdateScenarioRequest} updateScenarioRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateScenario(scenarioId: string, updateScenarioRequest: UpdateScenarioRequest, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Scenario> {\n            return localVarFp.updateScenario(scenarioId, updateScenarioRequest, xHumanId, options).then((request) => request(axios, basePath));\n        },\n    };\n};\n\n/**\n * ScenarioApi - object-oriented interface\n * @export\n * @class ScenarioApi\n * @extends {BaseAPI}\n */\nexport class ScenarioApi extends BaseAPI {\n    /**\n     * \n     * @summary Create a scenario\n     * @param {CreateScenarioRequest} createScenarioRequest \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ScenarioApi\n     */\n    public createScenario(createScenarioRequest: CreateScenarioRequest, options?: RawAxiosRequestConfig) {\n        return ScenarioApiFp(this.configuration).createScenario(createScenarioRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Delete a scenario\n     * @param {string} scenarioId \n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ScenarioApi\n     */\n    public deleteScenario(scenarioId: string, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return ScenarioApiFp(this.configuration).deleteScenario(scenarioId, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get a scenario\n     * @param {string} scenarioId \n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ScenarioApi\n     */\n    public getScenario(scenarioId: string, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return ScenarioApiFp(this.configuration).getScenario(scenarioId, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get a list of scenarios\n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ScenarioApi\n     */\n    public listScenarios(xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return ScenarioApiFp(this.configuration).listScenarios(xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Update a scenario\n     * @param {string} scenarioId \n     * @param {UpdateScenarioRequest} updateScenarioRequest \n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ScenarioApi\n     */\n    public updateScenario(scenarioId: string, updateScenarioRequest: UpdateScenarioRequest, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return ScenarioApiFp(this.configuration).updateScenario(scenarioId, updateScenarioRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nimport type { Configuration } from '../configuration';\nimport type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';\nimport globalAxios from 'axios';\n// Some imports not used depending on template conditions\n// @ts-ignore\nimport { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';\n// @ts-ignore\nimport type { ApiV1SessionListGet200Response } from '../model';\n// @ts-ignore\nimport type { ApiV1SessionSessionIdMessagesGet200Response } from '../model';\n// @ts-ignore\nimport type { ApiV1SessionSessionIdTimelineGet200Response } from '../model';\n// @ts-ignore\nimport type { Session } from '../model';\n// @ts-ignore\nimport type { SessionStartRequest } from '../model';\n// @ts-ignore\nimport type { SessionStartResponse } from '../model';\n// @ts-ignore\nimport type { UpdateSessionRequest } from '../model';\n/**\n * SessionApi - axios parameter creator\n * @export\n */\nexport const SessionApiAxiosParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * This endpoint is deprecated. Use Realtime Apis instead.\n         * @summary Get a list of sessions\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {string} [human] \n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        apiV1SessionListGet: async (xHumanId?: string, human?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            const localVarPath = `/api/v1/session/list`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (human !== undefined) {\n                localVarQueryParameter['human'] = human;\n            }\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary End a session\n         * @param {string} sessionId \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        apiV1SessionSessionIdEndPost: async (sessionId: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'sessionId' is not null or undefined\n            assertParamExists('apiV1SessionSessionIdEndPost', 'sessionId', sessionId)\n            const localVarPath = `/api/v1/session/{session_id}/end`\n                .replace(`{${\"session_id\"}}`, encodeURIComponent(String(sessionId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * This endpoint is deprecated. Use Realtime Apis instead.\n         * @summary Get a session by id\n         * @param {string} sessionId \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        apiV1SessionSessionIdGet: async (sessionId: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'sessionId' is not null or undefined\n            assertParamExists('apiV1SessionSessionIdGet', 'sessionId', sessionId)\n            const localVarPath = `/api/v1/session/{session_id}`\n                .replace(`{${\"session_id\"}}`, encodeURIComponent(String(sessionId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * This endpoint is deprecated. Use Realtime Apis instead.\n         * @summary Get session messages\n         * @param {string} sessionId \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        apiV1SessionSessionIdMessagesGet: async (sessionId: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'sessionId' is not null or undefined\n            assertParamExists('apiV1SessionSessionIdMessagesGet', 'sessionId', sessionId)\n            const localVarPath = `/api/v1/session/{session_id}/messages`\n                .replace(`{${\"session_id\"}}`, encodeURIComponent(String(sessionId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * This endpoint is deprecated. Use Realtime Apis instead.\n         * @summary Update a session by id\n         * @param {string} sessionId \n         * @param {UpdateSessionRequest} updateSessionRequest \n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        apiV1SessionSessionIdPut: async (sessionId: string, updateSessionRequest: UpdateSessionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'sessionId' is not null or undefined\n            assertParamExists('apiV1SessionSessionIdPut', 'sessionId', sessionId)\n            // verify required parameter 'updateSessionRequest' is not null or undefined\n            assertParamExists('apiV1SessionSessionIdPut', 'updateSessionRequest', updateSessionRequest)\n            const localVarPath = `/api/v1/session/{session_id}`\n                .replace(`{${\"session_id\"}}`, encodeURIComponent(String(sessionId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(updateSessionRequest, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * This endpoint is deprecated. Use Realtime Apis instead.\n         * @summary Get a session timeline\n         * @param {string} sessionId \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        apiV1SessionSessionIdTimelineGet: async (sessionId: string, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'sessionId' is not null or undefined\n            assertParamExists('apiV1SessionSessionIdTimelineGet', 'sessionId', sessionId)\n            const localVarPath = `/api/v1/session/{session_id}/timeline`\n                .replace(`{${\"session_id\"}}`, encodeURIComponent(String(sessionId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * This endpoint is deprecated. Use Realtime Apis instead.\n         * @summary Create a new session\n         * @param {SessionStartRequest} sessionStartRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        apiV1SessionStartPost: async (sessionStartRequest: SessionStartRequest, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'sessionStartRequest' is not null or undefined\n            assertParamExists('apiV1SessionStartPost', 'sessionStartRequest', sessionStartRequest)\n            const localVarPath = `/api/v1/session/start`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(sessionStartRequest, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * SessionApi - functional programming interface\n * @export\n */\nexport const SessionApiFp = function(configuration?: Configuration) {\n    const localVarAxiosParamCreator = SessionApiAxiosParamCreator(configuration)\n    return {\n        /**\n         * This endpoint is deprecated. Use Realtime Apis instead.\n         * @summary Get a list of sessions\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {string} [human] \n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        async apiV1SessionListGet(xHumanId?: string, human?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1SessionListGet200Response>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionListGet(xHumanId, human, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionListGet']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * \n         * @summary End a session\n         * @param {string} sessionId \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async apiV1SessionSessionIdEndPost(sessionId: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdEndPost(sessionId, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionSessionIdEndPost']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * This endpoint is deprecated. Use Realtime Apis instead.\n         * @summary Get a session by id\n         * @param {string} sessionId \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        async apiV1SessionSessionIdGet(sessionId: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdGet(sessionId, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionSessionIdGet']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * This endpoint is deprecated. Use Realtime Apis instead.\n         * @summary Get session messages\n         * @param {string} sessionId \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        async apiV1SessionSessionIdMessagesGet(sessionId: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1SessionSessionIdMessagesGet200Response>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdMessagesGet(sessionId, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionSessionIdMessagesGet']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * This endpoint is deprecated. Use Realtime Apis instead.\n         * @summary Update a session by id\n         * @param {string} sessionId \n         * @param {UpdateSessionRequest} updateSessionRequest \n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        async apiV1SessionSessionIdPut(sessionId: string, updateSessionRequest: UpdateSessionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdPut(sessionId, updateSessionRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionSessionIdPut']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * This endpoint is deprecated. Use Realtime Apis instead.\n         * @summary Get a session timeline\n         * @param {string} sessionId \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        async apiV1SessionSessionIdTimelineGet(sessionId: string, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1SessionSessionIdTimelineGet200Response>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdTimelineGet(sessionId, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionSessionIdTimelineGet']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * This endpoint is deprecated. Use Realtime Apis instead.\n         * @summary Create a new session\n         * @param {SessionStartRequest} sessionStartRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        async apiV1SessionStartPost(sessionStartRequest: SessionStartRequest, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionStartResponse>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionStartPost(sessionStartRequest, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['SessionApi.apiV1SessionStartPost']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    }\n};\n\n/**\n * SessionApi - factory interface\n * @export\n */\nexport const SessionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\n    const localVarFp = SessionApiFp(configuration)\n    return {\n        /**\n         * This endpoint is deprecated. Use Realtime Apis instead.\n         * @summary Get a list of sessions\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {string} [human] \n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        apiV1SessionListGet(xHumanId?: string, human?: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1SessionListGet200Response> {\n            return localVarFp.apiV1SessionListGet(xHumanId, human, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary End a session\n         * @param {string} sessionId \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        apiV1SessionSessionIdEndPost(sessionId: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Session> {\n            return localVarFp.apiV1SessionSessionIdEndPost(sessionId, xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * This endpoint is deprecated. Use Realtime Apis instead.\n         * @summary Get a session by id\n         * @param {string} sessionId \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        apiV1SessionSessionIdGet(sessionId: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Session> {\n            return localVarFp.apiV1SessionSessionIdGet(sessionId, xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * This endpoint is deprecated. Use Realtime Apis instead.\n         * @summary Get session messages\n         * @param {string} sessionId \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        apiV1SessionSessionIdMessagesGet(sessionId: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1SessionSessionIdMessagesGet200Response> {\n            return localVarFp.apiV1SessionSessionIdMessagesGet(sessionId, xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * This endpoint is deprecated. Use Realtime Apis instead.\n         * @summary Update a session by id\n         * @param {string} sessionId \n         * @param {UpdateSessionRequest} updateSessionRequest \n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        apiV1SessionSessionIdPut(sessionId: string, updateSessionRequest: UpdateSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {\n            return localVarFp.apiV1SessionSessionIdPut(sessionId, updateSessionRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * This endpoint is deprecated. Use Realtime Apis instead.\n         * @summary Get a session timeline\n         * @param {string} sessionId \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        apiV1SessionSessionIdTimelineGet(sessionId: string, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1SessionSessionIdTimelineGet200Response> {\n            return localVarFp.apiV1SessionSessionIdTimelineGet(sessionId, xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * This endpoint is deprecated. Use Realtime Apis instead.\n         * @summary Create a new session\n         * @param {SessionStartRequest} sessionStartRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        apiV1SessionStartPost(sessionStartRequest: SessionStartRequest, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<SessionStartResponse> {\n            return localVarFp.apiV1SessionStartPost(sessionStartRequest, xHumanId, options).then((request) => request(axios, basePath));\n        },\n    };\n};\n\n/**\n * SessionApi - object-oriented interface\n * @export\n * @class SessionApi\n * @extends {BaseAPI}\n */\nexport class SessionApi extends BaseAPI {\n    /**\n     * This endpoint is deprecated. Use Realtime Apis instead.\n     * @summary Get a list of sessions\n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {string} [human] \n     * @param {*} [options] Override http request option.\n     * @deprecated\n     * @throws {RequiredError}\n     * @memberof SessionApi\n     */\n    public apiV1SessionListGet(xHumanId?: string, human?: string, options?: RawAxiosRequestConfig) {\n        return SessionApiFp(this.configuration).apiV1SessionListGet(xHumanId, human, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary End a session\n     * @param {string} sessionId \n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SessionApi\n     */\n    public apiV1SessionSessionIdEndPost(sessionId: string, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return SessionApiFp(this.configuration).apiV1SessionSessionIdEndPost(sessionId, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * This endpoint is deprecated. Use Realtime Apis instead.\n     * @summary Get a session by id\n     * @param {string} sessionId \n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @deprecated\n     * @throws {RequiredError}\n     * @memberof SessionApi\n     */\n    public apiV1SessionSessionIdGet(sessionId: string, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return SessionApiFp(this.configuration).apiV1SessionSessionIdGet(sessionId, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * This endpoint is deprecated. Use Realtime Apis instead.\n     * @summary Get session messages\n     * @param {string} sessionId \n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @deprecated\n     * @throws {RequiredError}\n     * @memberof SessionApi\n     */\n    public apiV1SessionSessionIdMessagesGet(sessionId: string, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return SessionApiFp(this.configuration).apiV1SessionSessionIdMessagesGet(sessionId, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * This endpoint is deprecated. Use Realtime Apis instead.\n     * @summary Update a session by id\n     * @param {string} sessionId \n     * @param {UpdateSessionRequest} updateSessionRequest \n     * @param {*} [options] Override http request option.\n     * @deprecated\n     * @throws {RequiredError}\n     * @memberof SessionApi\n     */\n    public apiV1SessionSessionIdPut(sessionId: string, updateSessionRequest: UpdateSessionRequest, options?: RawAxiosRequestConfig) {\n        return SessionApiFp(this.configuration).apiV1SessionSessionIdPut(sessionId, updateSessionRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * This endpoint is deprecated. Use Realtime Apis instead.\n     * @summary Get a session timeline\n     * @param {string} sessionId \n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @deprecated\n     * @throws {RequiredError}\n     * @memberof SessionApi\n     */\n    public apiV1SessionSessionIdTimelineGet(sessionId: string, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return SessionApiFp(this.configuration).apiV1SessionSessionIdTimelineGet(sessionId, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * This endpoint is deprecated. Use Realtime Apis instead.\n     * @summary Create a new session\n     * @param {SessionStartRequest} sessionStartRequest \n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @deprecated\n     * @throws {RequiredError}\n     * @memberof SessionApi\n     */\n    public apiV1SessionStartPost(sessionStartRequest: SessionStartRequest, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return SessionApiFp(this.configuration).apiV1SessionStartPost(sessionStartRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nimport type { Configuration } from '../configuration';\nimport type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';\nimport globalAxios from 'axios';\n// Some imports not used depending on template conditions\n// @ts-ignore\nimport { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';\n// @ts-ignore\nimport type { CreateUsageToken200Response } from '../model';\n// @ts-ignore\nimport type { UpdateUsageLimitsRequest } from '../model';\n// @ts-ignore\nimport type { UsageLimitsInner } from '../model';\n// @ts-ignore\nimport type { UsageTokenRequest } from '../model';\n/**\n * UsageApi - axios parameter creator\n * @export\n */\nexport const UsageApiAxiosParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * Requests a token for a human\n         * @summary Request new human token\n         * @param {UsageTokenRequest} usageTokenRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createUsageToken: async (usageTokenRequest: UsageTokenRequest, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'usageTokenRequest' is not null or undefined\n            assertParamExists('createUsageToken', 'usageTokenRequest', usageTokenRequest)\n            const localVarPath = `/api/v1/usage/token`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(usageTokenRequest, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Gets the usage limits of a token\n         * @summary Get usage limits\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getUsageLimits: async (xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            const localVarPath = `/api/v1/usage/limits`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Updates the usage limits of a human\n         * @summary Update limits on a usage token\n         * @param {UpdateUsageLimitsRequest} updateUsageLimitsRequest \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateUsageToken: async (updateUsageLimitsRequest: UpdateUsageLimitsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'updateUsageLimitsRequest' is not null or undefined\n            assertParamExists('updateUsageToken', 'updateUsageLimitsRequest', updateUsageLimitsRequest)\n            const localVarPath = `/api/v1/usage/token`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(updateUsageLimitsRequest, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * UsageApi - functional programming interface\n * @export\n */\nexport const UsageApiFp = function(configuration?: Configuration) {\n    const localVarAxiosParamCreator = UsageApiAxiosParamCreator(configuration)\n    return {\n        /**\n         * Requests a token for a human\n         * @summary Request new human token\n         * @param {UsageTokenRequest} usageTokenRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createUsageToken(usageTokenRequest: UsageTokenRequest, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUsageToken200Response>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createUsageToken(usageTokenRequest, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['UsageApi.createUsageToken']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Gets the usage limits of a token\n         * @summary Get usage limits\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getUsageLimits(xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UsageLimitsInner>>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsageLimits(xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['UsageApi.getUsageLimits']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Updates the usage limits of a human\n         * @summary Update limits on a usage token\n         * @param {UpdateUsageLimitsRequest} updateUsageLimitsRequest \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async updateUsageToken(updateUsageLimitsRequest: UpdateUsageLimitsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUsageToken(updateUsageLimitsRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['UsageApi.updateUsageToken']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    }\n};\n\n/**\n * UsageApi - factory interface\n * @export\n */\nexport const UsageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\n    const localVarFp = UsageApiFp(configuration)\n    return {\n        /**\n         * Requests a token for a human\n         * @summary Request new human token\n         * @param {UsageTokenRequest} usageTokenRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createUsageToken(usageTokenRequest: UsageTokenRequest, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateUsageToken200Response> {\n            return localVarFp.createUsageToken(usageTokenRequest, xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Gets the usage limits of a token\n         * @summary Get usage limits\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getUsageLimits(xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UsageLimitsInner>> {\n            return localVarFp.getUsageLimits(xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Updates the usage limits of a human\n         * @summary Update limits on a usage token\n         * @param {UpdateUsageLimitsRequest} updateUsageLimitsRequest \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateUsageToken(updateUsageLimitsRequest: UpdateUsageLimitsRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {\n            return localVarFp.updateUsageToken(updateUsageLimitsRequest, options).then((request) => request(axios, basePath));\n        },\n    };\n};\n\n/**\n * UsageApi - object-oriented interface\n * @export\n * @class UsageApi\n * @extends {BaseAPI}\n */\nexport class UsageApi extends BaseAPI {\n    /**\n     * Requests a token for a human\n     * @summary Request new human token\n     * @param {UsageTokenRequest} usageTokenRequest \n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UsageApi\n     */\n    public createUsageToken(usageTokenRequest: UsageTokenRequest, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return UsageApiFp(this.configuration).createUsageToken(usageTokenRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * Gets the usage limits of a token\n     * @summary Get usage limits\n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UsageApi\n     */\n    public getUsageLimits(xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return UsageApiFp(this.configuration).getUsageLimits(xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * Updates the usage limits of a human\n     * @summary Update limits on a usage token\n     * @param {UpdateUsageLimitsRequest} updateUsageLimitsRequest \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UsageApi\n     */\n    public updateUsageToken(updateUsageLimitsRequest: UpdateUsageLimitsRequest, options?: RawAxiosRequestConfig) {\n        return UsageApiFp(this.configuration).updateUsageToken(updateUsageLimitsRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nimport type { Configuration } from '../configuration';\nimport type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';\nimport globalAxios from 'axios';\n// Some imports not used depending on template conditions\n// @ts-ignore\nimport { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';\n// @ts-ignore\nimport type { CloneVoice200Response } from '../model';\n// @ts-ignore\nimport type { DeleteVoice200Response } from '../model';\n// @ts-ignore\nimport type { GenerateVoiceRequest } from '../model';\n// @ts-ignore\nimport type { ListVoices200Response } from '../model';\n// @ts-ignore\nimport type { UpdateVoiceRequest } from '../model';\n// @ts-ignore\nimport type { Voice } from '../model';\n/**\n * VoiceApi - axios parameter creator\n * @export\n */\nexport const VoiceApiAxiosParamCreator = function (configuration?: Configuration) {\n    return {\n        /**\n         * Creates a new cloned voice based on the input audio file\n         * @summary Clone a voice\n         * @param {string} name Name of the new voice\n         * @param {string} language Language of the voice (e.g., \\\\\\&#39;en\\\\\\&#39;, \\\\\\&#39;es\\\\\\&#39;, \\\\\\&#39;fr\\\\\\&#39;)\n         * @param {File} file Audio file for voice cloning (MP3 format)\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        cloneVoice: async (name: string, language: string, file: File, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'name' is not null or undefined\n            assertParamExists('cloneVoice', 'name', name)\n            // verify required parameter 'language' is not null or undefined\n            assertParamExists('cloneVoice', 'language', language)\n            // verify required parameter 'file' is not null or undefined\n            assertParamExists('cloneVoice', 'file', file)\n            const localVarPath = `/api/v1/voice/clone`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n            if (name !== undefined) { \n                localVarFormParams.append('name', name as any);\n            }\n    \n            if (language !== undefined) { \n                localVarFormParams.append('language', language as any);\n            }\n    \n            if (file !== undefined) { \n                localVarFormParams.append('file', file as any);\n            }\n    \n    \n            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = localVarFormParams;\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Delete a voice\n         * @param {string} voiceId \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteVoice: async (voiceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'voiceId' is not null or undefined\n            assertParamExists('deleteVoice', 'voiceId', voiceId)\n            const localVarPath = `/api/v1/voice/{voice_id}`\n                .replace(`{${\"voice_id\"}}`, encodeURIComponent(String(voiceId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Generates speech from input text and specified voice\n         * @summary Generate voice\n         * @param {GenerateVoiceRequest} generateVoiceRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        generateVoice: async (generateVoiceRequest: GenerateVoiceRequest, xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'generateVoiceRequest' is not null or undefined\n            assertParamExists('generateVoice', 'generateVoiceRequest', generateVoiceRequest)\n            const localVarPath = `/api/v1/voice/generate`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(generateVoiceRequest, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get a voice\n         * @param {string} voiceId \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getVoice: async (voiceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'voiceId' is not null or undefined\n            assertParamExists('getVoice', 'voiceId', voiceId)\n            const localVarPath = `/api/v1/voice/{voice_id}`\n                .replace(`{${\"voice_id\"}}`, encodeURIComponent(String(voiceId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * \n         * @summary Get a list of voices\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listVoices: async (xHumanId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            const localVarPath = `/api/v1/voice/list`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n            if (xHumanId != null) {\n                localVarHeaderParameter['x-human-id'] = String(xHumanId);\n            }\n\n\n    \n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Updates a voice based on the input request data\n         * @summary Update a voice\n         * @param {string} voiceId \n         * @param {UpdateVoiceRequest} updateVoiceRequest \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateVoice: async (voiceId: string, updateVoiceRequest: UpdateVoiceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {\n            // verify required parameter 'voiceId' is not null or undefined\n            assertParamExists('updateVoice', 'voiceId', voiceId)\n            // verify required parameter 'updateVoiceRequest' is not null or undefined\n            assertParamExists('updateVoice', 'updateVoiceRequest', updateVoiceRequest)\n            const localVarPath = `/api/v1/voice/{voice_id}`\n                .replace(`{${\"voice_id\"}}`, encodeURIComponent(String(voiceId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n\n            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};\n            const localVarHeaderParameter = {} as any;\n            const localVarQueryParameter = {} as any;\n\n            // authentication ApiKeyAuth required\n            await setApiKeyToObject(localVarHeaderParameter, \"x-api-key\", configuration)\n\n            // authentication BearerAuth required\n            // http bearer authentication required\n            await setBearerAuthToObject(localVarHeaderParameter, configuration)\n\n\n    \n            localVarHeaderParameter['Content-Type'] = 'application/json';\n\n            setSearchParams(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};\n            localVarRequestOptions.data = serializeDataIfNeeded(updateVoiceRequest, localVarRequestOptions, configuration)\n\n            return {\n                url: toPathString(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    }\n};\n\n/**\n * VoiceApi - functional programming interface\n * @export\n */\nexport const VoiceApiFp = function(configuration?: Configuration) {\n    const localVarAxiosParamCreator = VoiceApiAxiosParamCreator(configuration)\n    return {\n        /**\n         * Creates a new cloned voice based on the input audio file\n         * @summary Clone a voice\n         * @param {string} name Name of the new voice\n         * @param {string} language Language of the voice (e.g., \\\\\\&#39;en\\\\\\&#39;, \\\\\\&#39;es\\\\\\&#39;, \\\\\\&#39;fr\\\\\\&#39;)\n         * @param {File} file Audio file for voice cloning (MP3 format)\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async cloneVoice(name: string, language: string, file: File, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloneVoice200Response>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneVoice(name, language, file, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['VoiceApi.cloneVoice']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * \n         * @summary Delete a voice\n         * @param {string} voiceId \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async deleteVoice(voiceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteVoice200Response>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVoice(voiceId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['VoiceApi.deleteVoice']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Generates speech from input text and specified voice\n         * @summary Generate voice\n         * @param {GenerateVoiceRequest} generateVoiceRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async generateVoice(generateVoiceRequest: GenerateVoiceRequest, xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.generateVoice(generateVoiceRequest, xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['VoiceApi.generateVoice']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * \n         * @summary Get a voice\n         * @param {string} voiceId \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getVoice(voiceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Voice>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getVoice(voiceId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['VoiceApi.getVoice']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * \n         * @summary Get a list of voices\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listVoices(xHumanId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListVoices200Response>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listVoices(xHumanId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['VoiceApi.listVoices']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Updates a voice based on the input request data\n         * @summary Update a voice\n         * @param {string} voiceId \n         * @param {UpdateVoiceRequest} updateVoiceRequest \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async updateVoice(voiceId: string, updateVoiceRequest: UpdateVoiceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Voice>> {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVoice(voiceId, updateVoiceRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = operationServerMap['VoiceApi.updateVoice']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    }\n};\n\n/**\n * VoiceApi - factory interface\n * @export\n */\nexport const VoiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {\n    const localVarFp = VoiceApiFp(configuration)\n    return {\n        /**\n         * Creates a new cloned voice based on the input audio file\n         * @summary Clone a voice\n         * @param {string} name Name of the new voice\n         * @param {string} language Language of the voice (e.g., \\\\\\&#39;en\\\\\\&#39;, \\\\\\&#39;es\\\\\\&#39;, \\\\\\&#39;fr\\\\\\&#39;)\n         * @param {File} file Audio file for voice cloning (MP3 format)\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        cloneVoice(name: string, language: string, file: File, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CloneVoice200Response> {\n            return localVarFp.cloneVoice(name, language, file, xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Delete a voice\n         * @param {string} voiceId \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteVoice(voiceId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteVoice200Response> {\n            return localVarFp.deleteVoice(voiceId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Generates speech from input text and specified voice\n         * @summary Generate voice\n         * @param {GenerateVoiceRequest} generateVoiceRequest \n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        generateVoice(generateVoiceRequest: GenerateVoiceRequest, xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {\n            return localVarFp.generateVoice(generateVoiceRequest, xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get a voice\n         * @param {string} voiceId \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getVoice(voiceId: string, options?: RawAxiosRequestConfig): AxiosPromise<Voice> {\n            return localVarFp.getVoice(voiceId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * \n         * @summary Get a list of voices\n         * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listVoices(xHumanId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListVoices200Response> {\n            return localVarFp.listVoices(xHumanId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Updates a voice based on the input request data\n         * @summary Update a voice\n         * @param {string} voiceId \n         * @param {UpdateVoiceRequest} updateVoiceRequest \n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateVoice(voiceId: string, updateVoiceRequest: UpdateVoiceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Voice> {\n            return localVarFp.updateVoice(voiceId, updateVoiceRequest, options).then((request) => request(axios, basePath));\n        },\n    };\n};\n\n/**\n * VoiceApi - object-oriented interface\n * @export\n * @class VoiceApi\n * @extends {BaseAPI}\n */\nexport class VoiceApi extends BaseAPI {\n    /**\n     * Creates a new cloned voice based on the input audio file\n     * @summary Clone a voice\n     * @param {string} name Name of the new voice\n     * @param {string} language Language of the voice (e.g., \\\\\\&#39;en\\\\\\&#39;, \\\\\\&#39;es\\\\\\&#39;, \\\\\\&#39;fr\\\\\\&#39;)\n     * @param {File} file Audio file for voice cloning (MP3 format)\n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof VoiceApi\n     */\n    public cloneVoice(name: string, language: string, file: File, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return VoiceApiFp(this.configuration).cloneVoice(name, language, file, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Delete a voice\n     * @param {string} voiceId \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof VoiceApi\n     */\n    public deleteVoice(voiceId: string, options?: RawAxiosRequestConfig) {\n        return VoiceApiFp(this.configuration).deleteVoice(voiceId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * Generates speech from input text and specified voice\n     * @summary Generate voice\n     * @param {GenerateVoiceRequest} generateVoiceRequest \n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof VoiceApi\n     */\n    public generateVoice(generateVoiceRequest: GenerateVoiceRequest, xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return VoiceApiFp(this.configuration).generateVoice(generateVoiceRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get a voice\n     * @param {string} voiceId \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof VoiceApi\n     */\n    public getVoice(voiceId: string, options?: RawAxiosRequestConfig) {\n        return VoiceApiFp(this.configuration).getVoice(voiceId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * \n     * @summary Get a list of voices\n     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof VoiceApi\n     */\n    public listVoices(xHumanId?: string, options?: RawAxiosRequestConfig) {\n        return VoiceApiFp(this.configuration).listVoices(xHumanId, options).then((request) => request(this.axios, this.basePath));\n    }\n\n    /**\n     * Updates a voice based on the input request data\n     * @summary Update a voice\n     * @param {string} voiceId \n     * @param {UpdateVoiceRequest} updateVoiceRequest \n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof VoiceApi\n     */\n    public updateVoice(voiceId: string, updateVoiceRequest: UpdateVoiceRequest, options?: RawAxiosRequestConfig) {\n        return VoiceApiFp(this.configuration).updateVoice(voiceId, updateVoiceRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface ConfigurationParameters {\n    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);\n    username?: string;\n    password?: string;\n    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);\n    basePath?: string;\n    serverIndex?: number;\n    baseOptions?: any;\n    formDataCtor?: new () => any;\n}\n\nexport class Configuration {\n    /**\n     * parameter for apiKey security\n     * @param name security name\n     * @memberof Configuration\n     */\n    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);\n    /**\n     * parameter for basic security\n     *\n     * @type {string}\n     * @memberof Configuration\n     */\n    username?: string;\n    /**\n     * parameter for basic security\n     *\n     * @type {string}\n     * @memberof Configuration\n     */\n    password?: string;\n    /**\n     * parameter for oauth2 security\n     * @param name security name\n     * @param scopes oauth2 scope\n     * @memberof Configuration\n     */\n    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);\n    /**\n     * override base path\n     *\n     * @type {string}\n     * @memberof Configuration\n     */\n    basePath?: string;\n    /**\n     * override server index\n     *\n     * @type {number}\n     * @memberof Configuration\n     */\n    serverIndex?: number;\n    /**\n     * base options for axios calls\n     *\n     * @type {any}\n     * @memberof Configuration\n     */\n    baseOptions?: any;\n    /**\n     * The FormData constructor that will be used to create multipart form data\n     * requests. You can inject this here so that execution environments that\n     * do not support the FormData class can still run the generated client.\n     *\n     * @type {new () => FormData}\n     */\n    formDataCtor?: new () => any;\n\n    constructor(param: ConfigurationParameters = {}) {\n        this.apiKey = param.apiKey;\n        this.username = param.username;\n        this.password = param.password;\n        this.accessToken = param.accessToken;\n        this.basePath = param.basePath;\n        this.serverIndex = param.serverIndex;\n        this.baseOptions = param.baseOptions;\n        this.formDataCtor = param.formDataCtor;\n    }\n\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    public isJsonMime(mime: string): boolean {\n        const jsonMime: RegExp = new RegExp('^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$', 'i');\n        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');\n    }\n}\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n// May contain unused imports in some cases\n// @ts-ignore\nimport type { ChatCompletionRequestMessageContent } from './chat-completion-request-message-content';\n\n/**\n * \n * @export\n * @interface ChatCompletionRequestMessage\n */\nexport interface ChatCompletionRequestMessage {\n    /**\n     * \n     * @type {ChatCompletionRequestMessageContent}\n     * @memberof ChatCompletionRequestMessage\n     */\n    'content': ChatCompletionRequestMessageContent;\n    /**\n     * The role of the messages author.\n     * @type {string}\n     * @memberof ChatCompletionRequestMessage\n     */\n    'role': ChatCompletionRequestMessageRoleEnum;\n}\n\nexport const ChatCompletionRequestMessageRoleEnum = {\n    User: 'user',\n    Assistant: 'assistant',\n    System: 'system'\n} as const;\n\nexport type ChatCompletionRequestMessageRoleEnum = typeof ChatCompletionRequestMessageRoleEnum[keyof typeof ChatCompletionRequestMessageRoleEnum];\n\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n// May contain unused imports in some cases\n// @ts-ignore\nimport type { ChatCompletionRequestMessageContentPartAudioInputAudio } from './chat-completion-request-message-content-part-audio-input-audio';\n\n/**\n * \n * @export\n * @interface ChatCompletionRequestMessageContentPartAudio\n */\nexport interface ChatCompletionRequestMessageContentPartAudio {\n    /**\n     * Audio content type.\n     * @type {string}\n     * @memberof ChatCompletionRequestMessageContentPartAudio\n     */\n    'type': ChatCompletionRequestMessageContentPartAudioTypeEnum;\n    /**\n     * \n     * @type {ChatCompletionRequestMessageContentPartAudioInputAudio}\n     * @memberof ChatCompletionRequestMessageContentPartAudio\n     */\n    'input_audio': ChatCompletionRequestMessageContentPartAudioInputAudio;\n}\n\nexport const ChatCompletionRequestMessageContentPartAudioTypeEnum = {\n    InputAudio: 'input_audio'\n} as const;\n\nexport type ChatCompletionRequestMessageContentPartAudioTypeEnum = typeof ChatCompletionRequestMessageContentPartAudioTypeEnum[keyof typeof ChatCompletionRequestMessageContentPartAudioTypeEnum];\n\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n\n/**\n * \n * @export\n * @interface ChatCompletionRequestMessageContentPartAudioInputAudio\n */\nexport interface ChatCompletionRequestMessageContentPartAudioInputAudio {\n    /**\n     * Base64 encoded audio data.\n     * @type {string}\n     * @memberof ChatCompletionRequestMessageContentPartAudioInputAudio\n     */\n    'data': string;\n    /**\n     * The format of the audio data.\n     * @type {string}\n     * @memberof ChatCompletionRequestMessageContentPartAudioInputAudio\n     */\n    'format': ChatCompletionRequestMessageContentPartAudioInputAudioFormatEnum;\n}\n\nexport const ChatCompletionRequestMessageContentPartAudioInputAudioFormatEnum = {\n    Wav: 'wav',\n    Mp3: 'mp3',\n    Ogg: 'ogg'\n} as const;\n\nexport type ChatCompletionRequestMessageContentPartAudioInputAudioFormatEnum = typeof ChatCompletionRequestMessageContentPartAudioInputAudioFormatEnum[keyof typeof ChatCompletionRequestMessageContentPartAudioInputAudioFormatEnum];\n\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n\n/**\n * Text content\n * @export\n * @interface ChatCompletionRequestMessageContentPartText\n */\nexport interface ChatCompletionRequestMessageContentPartText {\n    /**\n     * The type of the content part.\n     * @type {string}\n     * @memberof ChatCompletionRequestMessageContentPartText\n     */\n    'type': ChatCompletionRequestMessageContentPartTextTypeEnum;\n    /**\n     * The text content.\n     * @type {string}\n     * @memberof ChatCompletionRequestMessageContentPartText\n     */\n    'text': string;\n}\n\nexport const ChatCompletionRequestMessageContentPartTextTypeEnum = {\n    Text: 'text'\n} as const;\n\nexport type ChatCompletionRequestMessageContentPartTextTypeEnum = typeof ChatCompletionRequestMessageContentPartTextTypeEnum[keyof typeof ChatCompletionRequestMessageContentPartTextTypeEnum];\n\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n// May contain unused imports in some cases\n// @ts-ignore\nimport type { ChatCompletionResponseGabberMessageDataInnerData } from './chat-completion-response-gabber-message-data-inner-data';\n\n/**\n * \n * @export\n * @interface ChatCompletionResponseGabberMessageDataInner\n */\nexport interface ChatCompletionResponseGabberMessageDataInner {\n    /**\n     * \n     * @type {number}\n     * @memberof ChatCompletionResponseGabberMessageDataInner\n     */\n    'message_index': number;\n    /**\n     * \n     * @type {number}\n     * @memberof ChatCompletionResponseGabberMessageDataInner\n     */\n    'content_index': number;\n    /**\n     * \n     * @type {string}\n     * @memberof ChatCompletionResponseGabberMessageDataInner\n     */\n    'type': ChatCompletionResponseGabberMessageDataInnerTypeEnum;\n    /**\n     * \n     * @type {ChatCompletionResponseGabberMessageDataInnerData}\n     * @memberof ChatCompletionResponseGabberMessageDataInner\n     */\n    'data': ChatCompletionResponseGabberMessageDataInnerData;\n}\n\nexport const ChatCompletionResponseGabberMessageDataInnerTypeEnum = {\n    AudioTranscript: 'audio_transcript'\n} as const;\n\nexport type ChatCompletionResponseGabberMessageDataInnerTypeEnum = typeof ChatCompletionResponseGabberMessageDataInnerTypeEnum[keyof typeof ChatCompletionResponseGabberMessageDataInnerTypeEnum];\n\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n// May contain unused imports in some cases\n// @ts-ignore\nimport type { ChatCompletionStreamResponseDeltaGabber } from './chat-completion-stream-response-delta-gabber';\n\n/**\n * A chat completion message generated by the model.\n * @export\n * @interface ChatCompletionResponseMessage\n */\nexport interface ChatCompletionResponseMessage {\n    /**\n     * The contents of the message.\n     * @type {string}\n     * @memberof ChatCompletionResponseMessage\n     */\n    'content': string;\n    /**\n     * The refusal message generated by the model.\n     * @type {string}\n     * @memberof ChatCompletionResponseMessage\n     */\n    'refusal': string;\n    /**\n     * The role of the author of this message.\n     * @type {string}\n     * @memberof ChatCompletionResponseMessage\n     */\n    'role': ChatCompletionResponseMessageRoleEnum;\n    /**\n     * \n     * @type {ChatCompletionStreamResponseDeltaGabber}\n     * @memberof ChatCompletionResponseMessage\n     */\n    'gabber'?: ChatCompletionStreamResponseDeltaGabber;\n}\n\nexport const ChatCompletionResponseMessageRoleEnum = {\n    Assistant: 'assistant'\n} as const;\n\nexport type ChatCompletionResponseMessageRoleEnum = typeof ChatCompletionResponseMessageRoleEnum[keyof typeof ChatCompletionResponseMessageRoleEnum];\n\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n// May contain unused imports in some cases\n// @ts-ignore\nimport type { ChatCompletionStreamResponseChoicesInner } from './chat-completion-stream-response-choices-inner';\n// May contain unused imports in some cases\n// @ts-ignore\nimport type { ChatCompletionStreamResponseGabber } from './chat-completion-stream-response-gabber';\n\n/**\n * Represents a streamed chunk of a chat completion response returned by model, based on the provided input.\n * @export\n * @interface ChatCompletionStreamResponse\n */\nexport interface ChatCompletionStreamResponse {\n    /**\n     * A unique identifier for the chat completion. Each chunk has the same ID.\n     * @type {string}\n     * @memberof ChatCompletionStreamResponse\n     */\n    'id': string;\n    /**\n     * A list of chat completion choices. Can contain more than one elements if `n` is greater than 1. Can also be empty for the last chunk if you set `stream_options: {\\\"include_usage\\\": true}`. \n     * @type {Array<ChatCompletionStreamResponseChoicesInner>}\n     * @memberof ChatCompletionStreamResponse\n     */\n    'choices': Array<ChatCompletionStreamResponseChoicesInner>;\n    /**\n     * The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.\n     * @type {number}\n     * @memberof ChatCompletionStreamResponse\n     */\n    'created': number;\n    /**\n     * The model to generate the completion.\n     * @type {string}\n     * @memberof ChatCompletionStreamResponse\n     */\n    'model': string;\n    /**\n     * The object type, which is always `chat.completion.chunk`.\n     * @type {string}\n     * @memberof ChatCompletionStreamResponse\n     */\n    'object': ChatCompletionStreamResponseObjectEnum;\n    /**\n     * \n     * @type {ChatCompletionStreamResponseGabber}\n     * @memberof ChatCompletionStreamResponse\n     */\n    'gabber'?: ChatCompletionStreamResponseGabber;\n}\n\nexport const ChatCompletionStreamResponseObjectEnum = {\n    ChatCompletionChunk: 'chat.completion.chunk'\n} as const;\n\nexport type ChatCompletionStreamResponseObjectEnum = typeof ChatCompletionStreamResponseObjectEnum[keyof typeof ChatCompletionStreamResponseObjectEnum];\n\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n// May contain unused imports in some cases\n// @ts-ignore\nimport type { ChatCompletionStreamResponseDelta } from './chat-completion-stream-response-delta';\n\n/**\n * \n * @export\n * @interface ChatCompletionStreamResponseChoicesInner\n */\nexport interface ChatCompletionStreamResponseChoicesInner {\n    /**\n     * \n     * @type {ChatCompletionStreamResponseDelta}\n     * @memberof ChatCompletionStreamResponseChoicesInner\n     */\n    'delta': ChatCompletionStreamResponseDelta;\n    /**\n     * The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, `content_filter` if content was omitted due to a flag from our content filters, `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function. \n     * @type {string}\n     * @memberof ChatCompletionStreamResponseChoicesInner\n     */\n    'finish_reason': ChatCompletionStreamResponseChoicesInnerFinishReasonEnum;\n    /**\n     * The index of the choice in the list of choices.\n     * @type {number}\n     * @memberof ChatCompletionStreamResponseChoicesInner\n     */\n    'index': number;\n}\n\nexport const ChatCompletionStreamResponseChoicesInnerFinishReasonEnum = {\n    Stop: 'stop',\n    Length: 'length',\n    ToolCalls: 'tool_calls',\n    ContentFilter: 'content_filter',\n    FunctionCall: 'function_call'\n} as const;\n\nexport type ChatCompletionStreamResponseChoicesInnerFinishReasonEnum = typeof ChatCompletionStreamResponseChoicesInnerFinishReasonEnum[keyof typeof ChatCompletionStreamResponseChoicesInnerFinishReasonEnum];\n\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n// May contain unused imports in some cases\n// @ts-ignore\nimport type { ChatCompletionStreamResponseDeltaGabber } from './chat-completion-stream-response-delta-gabber';\n\n/**\n * A chat completion delta generated by streamed model responses.\n * @export\n * @interface ChatCompletionStreamResponseDelta\n */\nexport interface ChatCompletionStreamResponseDelta {\n    /**\n     * The contents of the chunk message.\n     * @type {string}\n     * @memberof ChatCompletionStreamResponseDelta\n     */\n    'content'?: string;\n    /**\n     * The role of the author of this message.\n     * @type {string}\n     * @memberof ChatCompletionStreamResponseDelta\n     */\n    'role'?: ChatCompletionStreamResponseDeltaRoleEnum;\n    /**\n     * The refusal message generated by the model.\n     * @type {string}\n     * @memberof ChatCompletionStreamResponseDelta\n     */\n    'refusal'?: string;\n    /**\n     * \n     * @type {ChatCompletionStreamResponseDeltaGabber}\n     * @memberof ChatCompletionStreamResponseDelta\n     */\n    'gabber'?: ChatCompletionStreamResponseDeltaGabber;\n}\n\nexport const ChatCompletionStreamResponseDeltaRoleEnum = {\n    System: 'system',\n    User: 'user',\n    Assistant: 'assistant'\n} as const;\n\nexport type ChatCompletionStreamResponseDeltaRoleEnum = typeof ChatCompletionStreamResponseDeltaRoleEnum[keyof typeof ChatCompletionStreamResponseDeltaRoleEnum];\n\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n// May contain unused imports in some cases\n// @ts-ignore\nimport type { ChatCompletionStreamResponseGabberMessageDataInnerData } from './chat-completion-stream-response-gabber-message-data-inner-data';\n\n/**\n * \n * @export\n * @interface ChatCompletionStreamResponseGabberMessageDataInner\n */\nexport interface ChatCompletionStreamResponseGabberMessageDataInner {\n    /**\n     * \n     * @type {number}\n     * @memberof ChatCompletionStreamResponseGabberMessageDataInner\n     */\n    'message_index': number;\n    /**\n     * \n     * @type {number}\n     * @memberof ChatCompletionStreamResponseGabberMessageDataInner\n     */\n    'content_index': number;\n    /**\n     * \n     * @type {string}\n     * @memberof ChatCompletionStreamResponseGabberMessageDataInner\n     */\n    'type': ChatCompletionStreamResponseGabberMessageDataInnerTypeEnum;\n    /**\n     * \n     * @type {ChatCompletionStreamResponseGabberMessageDataInnerData}\n     * @memberof ChatCompletionStreamResponseGabberMessageDataInner\n     */\n    'data': ChatCompletionStreamResponseGabberMessageDataInnerData;\n}\n\nexport const ChatCompletionStreamResponseGabberMessageDataInnerTypeEnum = {\n    AudioTranscript: 'audio_transcript'\n} as const;\n\nexport type ChatCompletionStreamResponseGabberMessageDataInnerTypeEnum = typeof ChatCompletionStreamResponseGabberMessageDataInnerTypeEnum[keyof typeof ChatCompletionStreamResponseGabberMessageDataInnerTypeEnum];\n\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n\n/**\n * \n * @export\n * @interface ContextCreateRequestMessagesInner\n */\nexport interface ContextCreateRequestMessagesInner {\n    /**\n     * \n     * @type {string}\n     * @memberof ContextCreateRequestMessagesInner\n     */\n    'role': ContextCreateRequestMessagesInnerRoleEnum;\n    /**\n     * \n     * @type {string}\n     * @memberof ContextCreateRequestMessagesInner\n     */\n    'content': string;\n}\n\nexport const ContextCreateRequestMessagesInnerRoleEnum = {\n    Assistant: 'assistant',\n    System: 'system',\n    User: 'user'\n} as const;\n\nexport type ContextCreateRequestMessagesInnerRoleEnum = typeof ContextCreateRequestMessagesInnerRoleEnum[keyof typeof ContextCreateRequestMessagesInnerRoleEnum];\n\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n\n/**\n * \n * @export\n * @interface ContextMessageCreateParams\n */\nexport interface ContextMessageCreateParams {\n    /**\n     * \n     * @type {string}\n     * @memberof ContextMessageCreateParams\n     */\n    'speaking_ended_at'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof ContextMessageCreateParams\n     */\n    'speaking_started_at'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof ContextMessageCreateParams\n     */\n    'role': ContextMessageCreateParamsRoleEnum;\n    /**\n     * \n     * @type {string}\n     * @memberof ContextMessageCreateParams\n     */\n    'content': string;\n}\n\nexport const ContextMessageCreateParamsRoleEnum = {\n    Assistant: 'assistant',\n    System: 'system',\n    User: 'user'\n} as const;\n\nexport type ContextMessageCreateParamsRoleEnum = typeof ContextMessageCreateParamsRoleEnum[keyof typeof ContextMessageCreateParamsRoleEnum];\n\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n\n/**\n * \n * @export\n * @interface CreatePersonaRequest\n */\nexport interface CreatePersonaRequest {\n    /**\n     * \n     * @type {string}\n     * @memberof CreatePersonaRequest\n     */\n    'description': string;\n    /**\n     * \n     * @type {string}\n     * @memberof CreatePersonaRequest\n     */\n    'image_url'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof CreatePersonaRequest\n     */\n    'name': string;\n    /**\n     * \n     * @type {string}\n     * @memberof CreatePersonaRequest\n     */\n    'gender'?: CreatePersonaRequestGenderEnum;\n    /**\n     * \n     * @type {string}\n     * @memberof CreatePersonaRequest\n     */\n    'voice': string;\n}\n\nexport const CreatePersonaRequestGenderEnum = {\n    Male: 'male',\n    Female: 'female'\n} as const;\n\nexport type CreatePersonaRequestGenderEnum = typeof CreatePersonaRequestGenderEnum[keyof typeof CreatePersonaRequestGenderEnum];\n\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n\n/**\n * \n * @export\n * @interface HistoryMessage\n */\nexport interface HistoryMessage {\n    /**\n     * \n     * @type {string}\n     * @memberof HistoryMessage\n     */\n    'content': string;\n    /**\n     * \n     * @type {string}\n     * @memberof HistoryMessage\n     */\n    'import_id'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof HistoryMessage\n     */\n    'role': HistoryMessageRoleEnum;\n}\n\nexport const HistoryMessageRoleEnum = {\n    Assistant: 'assistant',\n    System: 'system',\n    User: 'user'\n} as const;\n\nexport type HistoryMessageRoleEnum = typeof HistoryMessageRoleEnum[keyof typeof HistoryMessageRoleEnum];\n\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n// May contain unused imports in some cases\n// @ts-ignore\nimport type { PersonaTagsInner } from './persona-tags-inner';\n\n/**\n * \n * @export\n * @interface Persona\n */\nexport interface Persona {\n    /**\n     * \n     * @type {string}\n     * @memberof Persona\n     */\n    'created_at': string;\n    /**\n     * \n     * @type {string}\n     * @memberof Persona\n     */\n    'description': string;\n    /**\n     * \n     * @type {string}\n     * @memberof Persona\n     */\n    'id': string;\n    /**\n     * \n     * @type {string}\n     * @memberof Persona\n     */\n    'image_url'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Persona\n     */\n    'name': string;\n    /**\n     * \n     * @type {string}\n     * @memberof Persona\n     */\n    'project': string;\n    /**\n     * \n     * @type {string}\n     * @memberof Persona\n     */\n    'gender'?: PersonaGenderEnum;\n    /**\n     * \n     * @type {Array<PersonaTagsInner>}\n     * @memberof Persona\n     */\n    'tags'?: Array<PersonaTagsInner>;\n    /**\n     * \n     * @type {string}\n     * @memberof Persona\n     */\n    'voice': string;\n}\n\nexport const PersonaGenderEnum = {\n    Male: 'male',\n    Female: 'female'\n} as const;\n\nexport type PersonaGenderEnum = typeof PersonaGenderEnum[keyof typeof PersonaGenderEnum];\n\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n// May contain unused imports in some cases\n// @ts-ignore\nimport type { RealtimeSessionConfig } from './realtime-session-config';\n\n/**\n * \n * @export\n * @interface RealtimeSession\n */\nexport interface RealtimeSession {\n    /**\n     * The unique identifier of the RealtimeSession.\n     * @type {string}\n     * @memberof RealtimeSession\n     */\n    'id': string;\n    /**\n     * The current state of the RealtimeSession.\n     * @type {string}\n     * @memberof RealtimeSession\n     */\n    'state': RealtimeSessionStateEnum;\n    /**\n     * The time the RealtimeSession was created.\n     * @type {string}\n     * @memberof RealtimeSession\n     */\n    'created_at': string;\n    /**\n     * The time the RealtimeSession ended.\n     * @type {string}\n     * @memberof RealtimeSession\n     */\n    'ended_at'?: string;\n    /**\n     * The project identifier.\n     * @type {string}\n     * @memberof RealtimeSession\n     */\n    'project': string;\n    /**\n     * The human identifier.\n     * @type {string}\n     * @memberof RealtimeSession\n     */\n    'human'?: string;\n    /**\n     * Whether the session is simulated or not.\n     * @type {boolean}\n     * @memberof RealtimeSession\n     */\n    'simulated': boolean;\n    /**\n     * \n     * @type {RealtimeSessionConfig}\n     * @memberof RealtimeSession\n     */\n    'config': RealtimeSessionConfig;\n}\n\nexport const RealtimeSessionStateEnum = {\n    Ended: 'ended',\n    InProgress: 'in_progress',\n    NotStarted: 'not_started'\n} as const;\n\nexport type RealtimeSessionStateEnum = typeof RealtimeSessionStateEnum[keyof typeof RealtimeSessionStateEnum];\n\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n\n/**\n * \n * @export\n * @interface RealtimeSessionTimelineItem\n */\nexport interface RealtimeSessionTimelineItem {\n    /**\n     * \n     * @type {number}\n     * @memberof RealtimeSessionTimelineItem\n     */\n    'seconds'?: number;\n    /**\n     * \n     * @type {string}\n     * @memberof RealtimeSessionTimelineItem\n     */\n    'type'?: RealtimeSessionTimelineItemTypeEnum;\n}\n\nexport const RealtimeSessionTimelineItemTypeEnum = {\n    Silence: 'silence',\n    Agent: 'agent',\n    User: 'user'\n} as const;\n\nexport type RealtimeSessionTimelineItemTypeEnum = typeof RealtimeSessionTimelineItemTypeEnum[keyof typeof RealtimeSessionTimelineItemTypeEnum];\n\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n\n/**\n * \n * @export\n * @enum {string}\n */\n\nexport const SDKAgentState = {\n    Warmup: 'warmup',\n    Listening: 'listening',\n    Thinking: 'thinking',\n    Speaking: 'speaking',\n    TimeLimitExceeded: 'time_limit_exceeded',\n    UsageLimitExceeded: 'usage_limit_exceeded'\n} as const;\n\nexport type SDKAgentState = typeof SDKAgentState[keyof typeof SDKAgentState];\n\n\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n\n/**\n * \n * @export\n * @enum {string}\n */\n\nexport const SDKConnectionState = {\n    NotConnected: 'not_connected',\n    Connecting: 'connecting',\n    WaitingForAgent: 'waiting_for_agent',\n    Connected: 'connected'\n} as const;\n\nexport type SDKConnectionState = typeof SDKConnectionState[keyof typeof SDKConnectionState];\n\n\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n\n/**\n * \n * @export\n * @interface Session\n */\nexport interface Session {\n    /**\n     * \n     * @type {string}\n     * @memberof Session\n     */\n    'created_at': string;\n    /**\n     * \n     * @type {string}\n     * @memberof Session\n     */\n    'ended_at'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Session\n     */\n    'id': string;\n    /**\n     * \n     * @type {string}\n     * @memberof Session\n     */\n    'livekit_room': string;\n    /**\n     * \n     * @type {any}\n     * @memberof Session\n     */\n    'metadata': any;\n    /**\n     * \n     * @type {string}\n     * @memberof Session\n     */\n    'persona': string;\n    /**\n     * \n     * @type {string}\n     * @memberof Session\n     */\n    'project': string;\n    /**\n     * \n     * @type {string}\n     * @memberof Session\n     */\n    'scenario': string;\n    /**\n     * \n     * @type {string}\n     * @memberof Session\n     */\n    'llm'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Session\n     */\n    'state': SessionStateEnum;\n    /**\n     * \n     * @type {string}\n     * @memberof Session\n     */\n    'voice_override'?: string;\n    /**\n     * \n     * @type {number}\n     * @memberof Session\n     */\n    'time_limit_s': number;\n}\n\nexport const SessionStateEnum = {\n    Ended: 'ended',\n    InProgress: 'in_progress',\n    NotStarted: 'not_started'\n} as const;\n\nexport type SessionStateEnum = typeof SessionStateEnum[keyof typeof SessionStateEnum];\n\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n\n/**\n * \n * @export\n * @interface SessionTimelineItem\n */\nexport interface SessionTimelineItem {\n    /**\n     * \n     * @type {number}\n     * @memberof SessionTimelineItem\n     */\n    'seconds'?: number;\n    /**\n     * \n     * @type {string}\n     * @memberof SessionTimelineItem\n     */\n    'type'?: SessionTimelineItemTypeEnum;\n}\n\nexport const SessionTimelineItemTypeEnum = {\n    Silence: 'silence',\n    Agent: 'agent',\n    User: 'user'\n} as const;\n\nexport type SessionTimelineItemTypeEnum = typeof SessionTimelineItemTypeEnum[keyof typeof SessionTimelineItemTypeEnum];\n\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n\n/**\n * \n * @export\n * @interface UpdatePersonaRequest\n */\nexport interface UpdatePersonaRequest {\n    /**\n     * \n     * @type {string}\n     * @memberof UpdatePersonaRequest\n     */\n    'description'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdatePersonaRequest\n     */\n    'image_url'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdatePersonaRequest\n     */\n    'name'?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdatePersonaRequest\n     */\n    'gender'?: UpdatePersonaRequestGenderEnum;\n    /**\n     * \n     * @type {string}\n     * @memberof UpdatePersonaRequest\n     */\n    'voice'?: string;\n}\n\nexport const UpdatePersonaRequestGenderEnum = {\n    Male: 'male',\n    Female: 'female'\n} as const;\n\nexport type UpdatePersonaRequestGenderEnum = typeof UpdatePersonaRequestGenderEnum[keyof typeof UpdatePersonaRequestGenderEnum];\n\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n\n/**\n * \n * @export\n * @enum {string}\n */\n\nexport const UsageType = {\n    ConversationalSeconds: 'conversational_seconds',\n    VoiceSynthesisSeconds: 'voice_synthesis_seconds',\n    TokenCnt: 'token_cnt'\n} as const;\n\nexport type UsageType = typeof UsageType[keyof typeof UsageType];\n\n\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * Gabber API Reference\n * The Gabber API is a set of APIs that allow you to interact with the Gabber platform.\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n// May contain unused imports in some cases\n// @ts-ignore\nimport type { WebhookMessageUsageTrackedPayload } from './webhook-message-usage-tracked-payload';\n\n/**\n * \n * @export\n * @interface WebhookMessageUsageTracked\n */\nexport interface WebhookMessageUsageTracked {\n    /**\n     * \n     * @type {string}\n     * @memberof WebhookMessageUsageTracked\n     */\n    'type': WebhookMessageUsageTrackedTypeEnum;\n    /**\n     * \n     * @type {WebhookMessageUsageTrackedPayload}\n     * @memberof WebhookMessageUsageTracked\n     */\n    'payload': WebhookMessageUsageTrackedPayload;\n}\n\nexport const WebhookMessageUsageTrackedTypeEnum = {\n    UsageTracked: 'usage.tracked'\n} as const;\n\nexport type WebhookMessageUsageTrackedTypeEnum = typeof WebhookMessageUsageTrackedTypeEnum[keyof typeof WebhookMessageUsageTrackedTypeEnum];\n\n\n","import {\n  Configuration,\n  RealtimeApi,\n  PersonaApi,\n  SessionApi,\n  VoiceApi,\n  ScenarioApi,\n  LLMApi,\n  UsageApi\n} from \"./generated\";\n\nexport * from \"./generated/model\";\n\nexport class Api {\n\n  public realtime: RealtimeApi;\n  public persona: PersonaApi;\n  public session: SessionApi;\n  public voice: VoiceApi;\n  public scenario: ScenarioApi;\n  public llm: LLMApi;\n  public usage: UsageApi;\n\n  constructor(token: string) {\n    const config = new Configuration({ accessToken: token });\n    this.realtime = new RealtimeApi(config);\n    this.persona = new PersonaApi(config);\n    this.session = new SessionApi(config);\n    this.voice = new VoiceApi(config);\n    this.scenario = new ScenarioApi(config);\n    this.llm = new LLMApi(config);\n    this.usage = new UsageApi(config);\n  }\n}\n"],"mappings":"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","names":["import_livekit_client","import_axios","globalAxios","globalAxios","BASE_PATH","import_axios","import_axios","globalAxios","import_axios","globalAxios","import_axios","globalAxios","import_axios","globalAxios","import_axios","globalAxios","import_axios","globalAxios","import_axios","globalAxios"]}
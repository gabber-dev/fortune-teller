"use strict";
var Gabber = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all3) => {
    for (var name in all3)
      __defProp(target, name, { get: all3[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // ../../node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js
  var require_delayed_stream = __commonJS({
    "../../node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js"(exports, module) {
      "use strict";
      var Stream = __require("stream").Stream;
      var util3 = __require("util");
      module.exports = DelayedStream;
      function DelayedStream() {
        this.source = null;
        this.dataSize = 0;
        this.maxDataSize = 1024 * 1024;
        this.pauseStream = true;
        this._maxDataSizeExceeded = false;
        this._released = false;
        this._bufferedEvents = [];
      }
      util3.inherits(DelayedStream, Stream);
      DelayedStream.create = function(source, options) {
        var delayedStream = new this();
        options = options || {};
        for (var option in options) {
          delayedStream[option] = options[option];
        }
        delayedStream.source = source;
        var realEmit = source.emit;
        source.emit = function() {
          delayedStream._handleEmit(arguments);
          return realEmit.apply(source, arguments);
        };
        source.on("error", function() {
        });
        if (delayedStream.pauseStream) {
          source.pause();
        }
        return delayedStream;
      };
      Object.defineProperty(DelayedStream.prototype, "readable", {
        configurable: true,
        enumerable: true,
        get: function() {
          return this.source.readable;
        }
      });
      DelayedStream.prototype.setEncoding = function() {
        return this.source.setEncoding.apply(this.source, arguments);
      };
      DelayedStream.prototype.resume = function() {
        if (!this._released) {
          this.release();
        }
        this.source.resume();
      };
      DelayedStream.prototype.pause = function() {
        this.source.pause();
      };
      DelayedStream.prototype.release = function() {
        this._released = true;
        this._bufferedEvents.forEach(function(args) {
          this.emit.apply(this, args);
        }.bind(this));
        this._bufferedEvents = [];
      };
      DelayedStream.prototype.pipe = function() {
        var r2 = Stream.prototype.pipe.apply(this, arguments);
        this.resume();
        return r2;
      };
      DelayedStream.prototype._handleEmit = function(args) {
        if (this._released) {
          this.emit.apply(this, args);
          return;
        }
        if (args[0] === "data") {
          this.dataSize += args[1].length;
          this._checkIfMaxDataSizeExceeded();
        }
        this._bufferedEvents.push(args);
      };
      DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
        if (this._maxDataSizeExceeded) {
          return;
        }
        if (this.dataSize <= this.maxDataSize) {
          return;
        }
        this._maxDataSizeExceeded = true;
        var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
        this.emit("error", new Error(message));
      };
    }
  });

  // ../../node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js
  var require_combined_stream = __commonJS({
    "../../node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js"(exports, module) {
      "use strict";
      var util3 = __require("util");
      var Stream = __require("stream").Stream;
      var DelayedStream = require_delayed_stream();
      module.exports = CombinedStream;
      function CombinedStream() {
        this.writable = false;
        this.readable = true;
        this.dataSize = 0;
        this.maxDataSize = 2 * 1024 * 1024;
        this.pauseStreams = true;
        this._released = false;
        this._streams = [];
        this._currentStream = null;
        this._insideLoop = false;
        this._pendingNext = false;
      }
      util3.inherits(CombinedStream, Stream);
      CombinedStream.create = function(options) {
        var combinedStream = new this();
        options = options || {};
        for (var option in options) {
          combinedStream[option] = options[option];
        }
        return combinedStream;
      };
      CombinedStream.isStreamLike = function(stream4) {
        return typeof stream4 !== "function" && typeof stream4 !== "string" && typeof stream4 !== "boolean" && typeof stream4 !== "number" && !Buffer.isBuffer(stream4);
      };
      CombinedStream.prototype.append = function(stream4) {
        var isStreamLike = CombinedStream.isStreamLike(stream4);
        if (isStreamLike) {
          if (!(stream4 instanceof DelayedStream)) {
            var newStream = DelayedStream.create(stream4, {
              maxDataSize: Infinity,
              pauseStream: this.pauseStreams
            });
            stream4.on("data", this._checkDataSize.bind(this));
            stream4 = newStream;
          }
          this._handleErrors(stream4);
          if (this.pauseStreams) {
            stream4.pause();
          }
        }
        this._streams.push(stream4);
        return this;
      };
      CombinedStream.prototype.pipe = function(dest, options) {
        Stream.prototype.pipe.call(this, dest, options);
        this.resume();
        return dest;
      };
      CombinedStream.prototype._getNext = function() {
        this._currentStream = null;
        if (this._insideLoop) {
          this._pendingNext = true;
          return;
        }
        this._insideLoop = true;
        try {
          do {
            this._pendingNext = false;
            this._realGetNext();
          } while (this._pendingNext);
        } finally {
          this._insideLoop = false;
        }
      };
      CombinedStream.prototype._realGetNext = function() {
        var stream4 = this._streams.shift();
        if (typeof stream4 == "undefined") {
          this.end();
          return;
        }
        if (typeof stream4 !== "function") {
          this._pipeNext(stream4);
          return;
        }
        var getStream = stream4;
        getStream(function(stream5) {
          var isStreamLike = CombinedStream.isStreamLike(stream5);
          if (isStreamLike) {
            stream5.on("data", this._checkDataSize.bind(this));
            this._handleErrors(stream5);
          }
          this._pipeNext(stream5);
        }.bind(this));
      };
      CombinedStream.prototype._pipeNext = function(stream4) {
        this._currentStream = stream4;
        var isStreamLike = CombinedStream.isStreamLike(stream4);
        if (isStreamLike) {
          stream4.on("end", this._getNext.bind(this));
          stream4.pipe(this, { end: false });
          return;
        }
        var value = stream4;
        this.write(value);
        this._getNext();
      };
      CombinedStream.prototype._handleErrors = function(stream4) {
        var self2 = this;
        stream4.on("error", function(err) {
          self2._emitError(err);
        });
      };
      CombinedStream.prototype.write = function(data) {
        this.emit("data", data);
      };
      CombinedStream.prototype.pause = function() {
        if (!this.pauseStreams) {
          return;
        }
        if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function") this._currentStream.pause();
        this.emit("pause");
      };
      CombinedStream.prototype.resume = function() {
        if (!this._released) {
          this._released = true;
          this.writable = true;
          this._getNext();
        }
        if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function") this._currentStream.resume();
        this.emit("resume");
      };
      CombinedStream.prototype.end = function() {
        this._reset();
        this.emit("end");
      };
      CombinedStream.prototype.destroy = function() {
        this._reset();
        this.emit("close");
      };
      CombinedStream.prototype._reset = function() {
        this.writable = false;
        this._streams = [];
        this._currentStream = null;
      };
      CombinedStream.prototype._checkDataSize = function() {
        this._updateDataSize();
        if (this.dataSize <= this.maxDataSize) {
          return;
        }
        var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
        this._emitError(new Error(message));
      };
      CombinedStream.prototype._updateDataSize = function() {
        this.dataSize = 0;
        var self2 = this;
        this._streams.forEach(function(stream4) {
          if (!stream4.dataSize) {
            return;
          }
          self2.dataSize += stream4.dataSize;
        });
        if (this._currentStream && this._currentStream.dataSize) {
          this.dataSize += this._currentStream.dataSize;
        }
      };
      CombinedStream.prototype._emitError = function(err) {
        this._reset();
        this.emit("error", err);
      };
    }
  });

  // ../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json
  var require_db = __commonJS({
    "../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json"(exports, module) {
      module.exports = {
        "application/1d-interleaved-parityfec": {
          source: "iana"
        },
        "application/3gpdash-qoe-report+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/3gpp-ims+xml": {
          source: "iana",
          compressible: true
        },
        "application/3gpphal+json": {
          source: "iana",
          compressible: true
        },
        "application/3gpphalforms+json": {
          source: "iana",
          compressible: true
        },
        "application/a2l": {
          source: "iana"
        },
        "application/ace+cbor": {
          source: "iana"
        },
        "application/activemessage": {
          source: "iana"
        },
        "application/activity+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-costmap+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-costmapfilter+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-directory+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-endpointcost+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-endpointcostparams+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-endpointprop+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-endpointpropparams+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-error+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-networkmap+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-networkmapfilter+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-updatestreamcontrol+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-updatestreamparams+json": {
          source: "iana",
          compressible: true
        },
        "application/aml": {
          source: "iana"
        },
        "application/andrew-inset": {
          source: "iana",
          extensions: ["ez"]
        },
        "application/applefile": {
          source: "iana"
        },
        "application/applixware": {
          source: "apache",
          extensions: ["aw"]
        },
        "application/at+jwt": {
          source: "iana"
        },
        "application/atf": {
          source: "iana"
        },
        "application/atfx": {
          source: "iana"
        },
        "application/atom+xml": {
          source: "iana",
          compressible: true,
          extensions: ["atom"]
        },
        "application/atomcat+xml": {
          source: "iana",
          compressible: true,
          extensions: ["atomcat"]
        },
        "application/atomdeleted+xml": {
          source: "iana",
          compressible: true,
          extensions: ["atomdeleted"]
        },
        "application/atomicmail": {
          source: "iana"
        },
        "application/atomsvc+xml": {
          source: "iana",
          compressible: true,
          extensions: ["atomsvc"]
        },
        "application/atsc-dwd+xml": {
          source: "iana",
          compressible: true,
          extensions: ["dwd"]
        },
        "application/atsc-dynamic-event-message": {
          source: "iana"
        },
        "application/atsc-held+xml": {
          source: "iana",
          compressible: true,
          extensions: ["held"]
        },
        "application/atsc-rdt+json": {
          source: "iana",
          compressible: true
        },
        "application/atsc-rsat+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rsat"]
        },
        "application/atxml": {
          source: "iana"
        },
        "application/auth-policy+xml": {
          source: "iana",
          compressible: true
        },
        "application/bacnet-xdd+zip": {
          source: "iana",
          compressible: false
        },
        "application/batch-smtp": {
          source: "iana"
        },
        "application/bdoc": {
          compressible: false,
          extensions: ["bdoc"]
        },
        "application/beep+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/calendar+json": {
          source: "iana",
          compressible: true
        },
        "application/calendar+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xcs"]
        },
        "application/call-completion": {
          source: "iana"
        },
        "application/cals-1840": {
          source: "iana"
        },
        "application/captive+json": {
          source: "iana",
          compressible: true
        },
        "application/cbor": {
          source: "iana"
        },
        "application/cbor-seq": {
          source: "iana"
        },
        "application/cccex": {
          source: "iana"
        },
        "application/ccmp+xml": {
          source: "iana",
          compressible: true
        },
        "application/ccxml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["ccxml"]
        },
        "application/cdfx+xml": {
          source: "iana",
          compressible: true,
          extensions: ["cdfx"]
        },
        "application/cdmi-capability": {
          source: "iana",
          extensions: ["cdmia"]
        },
        "application/cdmi-container": {
          source: "iana",
          extensions: ["cdmic"]
        },
        "application/cdmi-domain": {
          source: "iana",
          extensions: ["cdmid"]
        },
        "application/cdmi-object": {
          source: "iana",
          extensions: ["cdmio"]
        },
        "application/cdmi-queue": {
          source: "iana",
          extensions: ["cdmiq"]
        },
        "application/cdni": {
          source: "iana"
        },
        "application/cea": {
          source: "iana"
        },
        "application/cea-2018+xml": {
          source: "iana",
          compressible: true
        },
        "application/cellml+xml": {
          source: "iana",
          compressible: true
        },
        "application/cfw": {
          source: "iana"
        },
        "application/city+json": {
          source: "iana",
          compressible: true
        },
        "application/clr": {
          source: "iana"
        },
        "application/clue+xml": {
          source: "iana",
          compressible: true
        },
        "application/clue_info+xml": {
          source: "iana",
          compressible: true
        },
        "application/cms": {
          source: "iana"
        },
        "application/cnrp+xml": {
          source: "iana",
          compressible: true
        },
        "application/coap-group+json": {
          source: "iana",
          compressible: true
        },
        "application/coap-payload": {
          source: "iana"
        },
        "application/commonground": {
          source: "iana"
        },
        "application/conference-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/cose": {
          source: "iana"
        },
        "application/cose-key": {
          source: "iana"
        },
        "application/cose-key-set": {
          source: "iana"
        },
        "application/cpl+xml": {
          source: "iana",
          compressible: true,
          extensions: ["cpl"]
        },
        "application/csrattrs": {
          source: "iana"
        },
        "application/csta+xml": {
          source: "iana",
          compressible: true
        },
        "application/cstadata+xml": {
          source: "iana",
          compressible: true
        },
        "application/csvm+json": {
          source: "iana",
          compressible: true
        },
        "application/cu-seeme": {
          source: "apache",
          extensions: ["cu"]
        },
        "application/cwt": {
          source: "iana"
        },
        "application/cybercash": {
          source: "iana"
        },
        "application/dart": {
          compressible: true
        },
        "application/dash+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mpd"]
        },
        "application/dash-patch+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mpp"]
        },
        "application/dashdelta": {
          source: "iana"
        },
        "application/davmount+xml": {
          source: "iana",
          compressible: true,
          extensions: ["davmount"]
        },
        "application/dca-rft": {
          source: "iana"
        },
        "application/dcd": {
          source: "iana"
        },
        "application/dec-dx": {
          source: "iana"
        },
        "application/dialog-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/dicom": {
          source: "iana"
        },
        "application/dicom+json": {
          source: "iana",
          compressible: true
        },
        "application/dicom+xml": {
          source: "iana",
          compressible: true
        },
        "application/dii": {
          source: "iana"
        },
        "application/dit": {
          source: "iana"
        },
        "application/dns": {
          source: "iana"
        },
        "application/dns+json": {
          source: "iana",
          compressible: true
        },
        "application/dns-message": {
          source: "iana"
        },
        "application/docbook+xml": {
          source: "apache",
          compressible: true,
          extensions: ["dbk"]
        },
        "application/dots+cbor": {
          source: "iana"
        },
        "application/dskpp+xml": {
          source: "iana",
          compressible: true
        },
        "application/dssc+der": {
          source: "iana",
          extensions: ["dssc"]
        },
        "application/dssc+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xdssc"]
        },
        "application/dvcs": {
          source: "iana"
        },
        "application/ecmascript": {
          source: "iana",
          compressible: true,
          extensions: ["es", "ecma"]
        },
        "application/edi-consent": {
          source: "iana"
        },
        "application/edi-x12": {
          source: "iana",
          compressible: false
        },
        "application/edifact": {
          source: "iana",
          compressible: false
        },
        "application/efi": {
          source: "iana"
        },
        "application/elm+json": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/elm+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.cap+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/emergencycalldata.comment+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.control+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.deviceinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.ecall.msd": {
          source: "iana"
        },
        "application/emergencycalldata.providerinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.serviceinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.subscriberinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.veds+xml": {
          source: "iana",
          compressible: true
        },
        "application/emma+xml": {
          source: "iana",
          compressible: true,
          extensions: ["emma"]
        },
        "application/emotionml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["emotionml"]
        },
        "application/encaprtp": {
          source: "iana"
        },
        "application/epp+xml": {
          source: "iana",
          compressible: true
        },
        "application/epub+zip": {
          source: "iana",
          compressible: false,
          extensions: ["epub"]
        },
        "application/eshop": {
          source: "iana"
        },
        "application/exi": {
          source: "iana",
          extensions: ["exi"]
        },
        "application/expect-ct-report+json": {
          source: "iana",
          compressible: true
        },
        "application/express": {
          source: "iana",
          extensions: ["exp"]
        },
        "application/fastinfoset": {
          source: "iana"
        },
        "application/fastsoap": {
          source: "iana"
        },
        "application/fdt+xml": {
          source: "iana",
          compressible: true,
          extensions: ["fdt"]
        },
        "application/fhir+json": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/fhir+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/fido.trusted-apps+json": {
          compressible: true
        },
        "application/fits": {
          source: "iana"
        },
        "application/flexfec": {
          source: "iana"
        },
        "application/font-sfnt": {
          source: "iana"
        },
        "application/font-tdpfr": {
          source: "iana",
          extensions: ["pfr"]
        },
        "application/font-woff": {
          source: "iana",
          compressible: false
        },
        "application/framework-attributes+xml": {
          source: "iana",
          compressible: true
        },
        "application/geo+json": {
          source: "iana",
          compressible: true,
          extensions: ["geojson"]
        },
        "application/geo+json-seq": {
          source: "iana"
        },
        "application/geopackage+sqlite3": {
          source: "iana"
        },
        "application/geoxacml+xml": {
          source: "iana",
          compressible: true
        },
        "application/gltf-buffer": {
          source: "iana"
        },
        "application/gml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["gml"]
        },
        "application/gpx+xml": {
          source: "apache",
          compressible: true,
          extensions: ["gpx"]
        },
        "application/gxf": {
          source: "apache",
          extensions: ["gxf"]
        },
        "application/gzip": {
          source: "iana",
          compressible: false,
          extensions: ["gz"]
        },
        "application/h224": {
          source: "iana"
        },
        "application/held+xml": {
          source: "iana",
          compressible: true
        },
        "application/hjson": {
          extensions: ["hjson"]
        },
        "application/http": {
          source: "iana"
        },
        "application/hyperstudio": {
          source: "iana",
          extensions: ["stk"]
        },
        "application/ibe-key-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/ibe-pkg-reply+xml": {
          source: "iana",
          compressible: true
        },
        "application/ibe-pp-data": {
          source: "iana"
        },
        "application/iges": {
          source: "iana"
        },
        "application/im-iscomposing+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/index": {
          source: "iana"
        },
        "application/index.cmd": {
          source: "iana"
        },
        "application/index.obj": {
          source: "iana"
        },
        "application/index.response": {
          source: "iana"
        },
        "application/index.vnd": {
          source: "iana"
        },
        "application/inkml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["ink", "inkml"]
        },
        "application/iotp": {
          source: "iana"
        },
        "application/ipfix": {
          source: "iana",
          extensions: ["ipfix"]
        },
        "application/ipp": {
          source: "iana"
        },
        "application/isup": {
          source: "iana"
        },
        "application/its+xml": {
          source: "iana",
          compressible: true,
          extensions: ["its"]
        },
        "application/java-archive": {
          source: "apache",
          compressible: false,
          extensions: ["jar", "war", "ear"]
        },
        "application/java-serialized-object": {
          source: "apache",
          compressible: false,
          extensions: ["ser"]
        },
        "application/java-vm": {
          source: "apache",
          compressible: false,
          extensions: ["class"]
        },
        "application/javascript": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["js", "mjs"]
        },
        "application/jf2feed+json": {
          source: "iana",
          compressible: true
        },
        "application/jose": {
          source: "iana"
        },
        "application/jose+json": {
          source: "iana",
          compressible: true
        },
        "application/jrd+json": {
          source: "iana",
          compressible: true
        },
        "application/jscalendar+json": {
          source: "iana",
          compressible: true
        },
        "application/json": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["json", "map"]
        },
        "application/json-patch+json": {
          source: "iana",
          compressible: true
        },
        "application/json-seq": {
          source: "iana"
        },
        "application/json5": {
          extensions: ["json5"]
        },
        "application/jsonml+json": {
          source: "apache",
          compressible: true,
          extensions: ["jsonml"]
        },
        "application/jwk+json": {
          source: "iana",
          compressible: true
        },
        "application/jwk-set+json": {
          source: "iana",
          compressible: true
        },
        "application/jwt": {
          source: "iana"
        },
        "application/kpml-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/kpml-response+xml": {
          source: "iana",
          compressible: true
        },
        "application/ld+json": {
          source: "iana",
          compressible: true,
          extensions: ["jsonld"]
        },
        "application/lgr+xml": {
          source: "iana",
          compressible: true,
          extensions: ["lgr"]
        },
        "application/link-format": {
          source: "iana"
        },
        "application/load-control+xml": {
          source: "iana",
          compressible: true
        },
        "application/lost+xml": {
          source: "iana",
          compressible: true,
          extensions: ["lostxml"]
        },
        "application/lostsync+xml": {
          source: "iana",
          compressible: true
        },
        "application/lpf+zip": {
          source: "iana",
          compressible: false
        },
        "application/lxf": {
          source: "iana"
        },
        "application/mac-binhex40": {
          source: "iana",
          extensions: ["hqx"]
        },
        "application/mac-compactpro": {
          source: "apache",
          extensions: ["cpt"]
        },
        "application/macwriteii": {
          source: "iana"
        },
        "application/mads+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mads"]
        },
        "application/manifest+json": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["webmanifest"]
        },
        "application/marc": {
          source: "iana",
          extensions: ["mrc"]
        },
        "application/marcxml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mrcx"]
        },
        "application/mathematica": {
          source: "iana",
          extensions: ["ma", "nb", "mb"]
        },
        "application/mathml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mathml"]
        },
        "application/mathml-content+xml": {
          source: "iana",
          compressible: true
        },
        "application/mathml-presentation+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-associated-procedure-description+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-deregister+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-envelope+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-msk+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-msk-response+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-protection-description+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-reception-report+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-register+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-register-response+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-schedule+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-user-service-description+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbox": {
          source: "iana",
          extensions: ["mbox"]
        },
        "application/media-policy-dataset+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mpf"]
        },
        "application/media_control+xml": {
          source: "iana",
          compressible: true
        },
        "application/mediaservercontrol+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mscml"]
        },
        "application/merge-patch+json": {
          source: "iana",
          compressible: true
        },
        "application/metalink+xml": {
          source: "apache",
          compressible: true,
          extensions: ["metalink"]
        },
        "application/metalink4+xml": {
          source: "iana",
          compressible: true,
          extensions: ["meta4"]
        },
        "application/mets+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mets"]
        },
        "application/mf4": {
          source: "iana"
        },
        "application/mikey": {
          source: "iana"
        },
        "application/mipc": {
          source: "iana"
        },
        "application/missing-blocks+cbor-seq": {
          source: "iana"
        },
        "application/mmt-aei+xml": {
          source: "iana",
          compressible: true,
          extensions: ["maei"]
        },
        "application/mmt-usd+xml": {
          source: "iana",
          compressible: true,
          extensions: ["musd"]
        },
        "application/mods+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mods"]
        },
        "application/moss-keys": {
          source: "iana"
        },
        "application/moss-signature": {
          source: "iana"
        },
        "application/mosskey-data": {
          source: "iana"
        },
        "application/mosskey-request": {
          source: "iana"
        },
        "application/mp21": {
          source: "iana",
          extensions: ["m21", "mp21"]
        },
        "application/mp4": {
          source: "iana",
          extensions: ["mp4s", "m4p"]
        },
        "application/mpeg4-generic": {
          source: "iana"
        },
        "application/mpeg4-iod": {
          source: "iana"
        },
        "application/mpeg4-iod-xmt": {
          source: "iana"
        },
        "application/mrb-consumer+xml": {
          source: "iana",
          compressible: true
        },
        "application/mrb-publish+xml": {
          source: "iana",
          compressible: true
        },
        "application/msc-ivr+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/msc-mixer+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/msword": {
          source: "iana",
          compressible: false,
          extensions: ["doc", "dot"]
        },
        "application/mud+json": {
          source: "iana",
          compressible: true
        },
        "application/multipart-core": {
          source: "iana"
        },
        "application/mxf": {
          source: "iana",
          extensions: ["mxf"]
        },
        "application/n-quads": {
          source: "iana",
          extensions: ["nq"]
        },
        "application/n-triples": {
          source: "iana",
          extensions: ["nt"]
        },
        "application/nasdata": {
          source: "iana"
        },
        "application/news-checkgroups": {
          source: "iana",
          charset: "US-ASCII"
        },
        "application/news-groupinfo": {
          source: "iana",
          charset: "US-ASCII"
        },
        "application/news-transmission": {
          source: "iana"
        },
        "application/nlsml+xml": {
          source: "iana",
          compressible: true
        },
        "application/node": {
          source: "iana",
          extensions: ["cjs"]
        },
        "application/nss": {
          source: "iana"
        },
        "application/oauth-authz-req+jwt": {
          source: "iana"
        },
        "application/oblivious-dns-message": {
          source: "iana"
        },
        "application/ocsp-request": {
          source: "iana"
        },
        "application/ocsp-response": {
          source: "iana"
        },
        "application/octet-stream": {
          source: "iana",
          compressible: false,
          extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
        },
        "application/oda": {
          source: "iana",
          extensions: ["oda"]
        },
        "application/odm+xml": {
          source: "iana",
          compressible: true
        },
        "application/odx": {
          source: "iana"
        },
        "application/oebps-package+xml": {
          source: "iana",
          compressible: true,
          extensions: ["opf"]
        },
        "application/ogg": {
          source: "iana",
          compressible: false,
          extensions: ["ogx"]
        },
        "application/omdoc+xml": {
          source: "apache",
          compressible: true,
          extensions: ["omdoc"]
        },
        "application/onenote": {
          source: "apache",
          extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
        },
        "application/opc-nodeset+xml": {
          source: "iana",
          compressible: true
        },
        "application/oscore": {
          source: "iana"
        },
        "application/oxps": {
          source: "iana",
          extensions: ["oxps"]
        },
        "application/p21": {
          source: "iana"
        },
        "application/p21+zip": {
          source: "iana",
          compressible: false
        },
        "application/p2p-overlay+xml": {
          source: "iana",
          compressible: true,
          extensions: ["relo"]
        },
        "application/parityfec": {
          source: "iana"
        },
        "application/passport": {
          source: "iana"
        },
        "application/patch-ops-error+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xer"]
        },
        "application/pdf": {
          source: "iana",
          compressible: false,
          extensions: ["pdf"]
        },
        "application/pdx": {
          source: "iana"
        },
        "application/pem-certificate-chain": {
          source: "iana"
        },
        "application/pgp-encrypted": {
          source: "iana",
          compressible: false,
          extensions: ["pgp"]
        },
        "application/pgp-keys": {
          source: "iana",
          extensions: ["asc"]
        },
        "application/pgp-signature": {
          source: "iana",
          extensions: ["asc", "sig"]
        },
        "application/pics-rules": {
          source: "apache",
          extensions: ["prf"]
        },
        "application/pidf+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/pidf-diff+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/pkcs10": {
          source: "iana",
          extensions: ["p10"]
        },
        "application/pkcs12": {
          source: "iana"
        },
        "application/pkcs7-mime": {
          source: "iana",
          extensions: ["p7m", "p7c"]
        },
        "application/pkcs7-signature": {
          source: "iana",
          extensions: ["p7s"]
        },
        "application/pkcs8": {
          source: "iana",
          extensions: ["p8"]
        },
        "application/pkcs8-encrypted": {
          source: "iana"
        },
        "application/pkix-attr-cert": {
          source: "iana",
          extensions: ["ac"]
        },
        "application/pkix-cert": {
          source: "iana",
          extensions: ["cer"]
        },
        "application/pkix-crl": {
          source: "iana",
          extensions: ["crl"]
        },
        "application/pkix-pkipath": {
          source: "iana",
          extensions: ["pkipath"]
        },
        "application/pkixcmp": {
          source: "iana",
          extensions: ["pki"]
        },
        "application/pls+xml": {
          source: "iana",
          compressible: true,
          extensions: ["pls"]
        },
        "application/poc-settings+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/postscript": {
          source: "iana",
          compressible: true,
          extensions: ["ai", "eps", "ps"]
        },
        "application/ppsp-tracker+json": {
          source: "iana",
          compressible: true
        },
        "application/problem+json": {
          source: "iana",
          compressible: true
        },
        "application/problem+xml": {
          source: "iana",
          compressible: true
        },
        "application/provenance+xml": {
          source: "iana",
          compressible: true,
          extensions: ["provx"]
        },
        "application/prs.alvestrand.titrax-sheet": {
          source: "iana"
        },
        "application/prs.cww": {
          source: "iana",
          extensions: ["cww"]
        },
        "application/prs.cyn": {
          source: "iana",
          charset: "7-BIT"
        },
        "application/prs.hpub+zip": {
          source: "iana",
          compressible: false
        },
        "application/prs.nprend": {
          source: "iana"
        },
        "application/prs.plucker": {
          source: "iana"
        },
        "application/prs.rdf-xml-crypt": {
          source: "iana"
        },
        "application/prs.xsf+xml": {
          source: "iana",
          compressible: true
        },
        "application/pskc+xml": {
          source: "iana",
          compressible: true,
          extensions: ["pskcxml"]
        },
        "application/pvd+json": {
          source: "iana",
          compressible: true
        },
        "application/qsig": {
          source: "iana"
        },
        "application/raml+yaml": {
          compressible: true,
          extensions: ["raml"]
        },
        "application/raptorfec": {
          source: "iana"
        },
        "application/rdap+json": {
          source: "iana",
          compressible: true
        },
        "application/rdf+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rdf", "owl"]
        },
        "application/reginfo+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rif"]
        },
        "application/relax-ng-compact-syntax": {
          source: "iana",
          extensions: ["rnc"]
        },
        "application/remote-printing": {
          source: "iana"
        },
        "application/reputon+json": {
          source: "iana",
          compressible: true
        },
        "application/resource-lists+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rl"]
        },
        "application/resource-lists-diff+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rld"]
        },
        "application/rfc+xml": {
          source: "iana",
          compressible: true
        },
        "application/riscos": {
          source: "iana"
        },
        "application/rlmi+xml": {
          source: "iana",
          compressible: true
        },
        "application/rls-services+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rs"]
        },
        "application/route-apd+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rapd"]
        },
        "application/route-s-tsid+xml": {
          source: "iana",
          compressible: true,
          extensions: ["sls"]
        },
        "application/route-usd+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rusd"]
        },
        "application/rpki-ghostbusters": {
          source: "iana",
          extensions: ["gbr"]
        },
        "application/rpki-manifest": {
          source: "iana",
          extensions: ["mft"]
        },
        "application/rpki-publication": {
          source: "iana"
        },
        "application/rpki-roa": {
          source: "iana",
          extensions: ["roa"]
        },
        "application/rpki-updown": {
          source: "iana"
        },
        "application/rsd+xml": {
          source: "apache",
          compressible: true,
          extensions: ["rsd"]
        },
        "application/rss+xml": {
          source: "apache",
          compressible: true,
          extensions: ["rss"]
        },
        "application/rtf": {
          source: "iana",
          compressible: true,
          extensions: ["rtf"]
        },
        "application/rtploopback": {
          source: "iana"
        },
        "application/rtx": {
          source: "iana"
        },
        "application/samlassertion+xml": {
          source: "iana",
          compressible: true
        },
        "application/samlmetadata+xml": {
          source: "iana",
          compressible: true
        },
        "application/sarif+json": {
          source: "iana",
          compressible: true
        },
        "application/sarif-external-properties+json": {
          source: "iana",
          compressible: true
        },
        "application/sbe": {
          source: "iana"
        },
        "application/sbml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["sbml"]
        },
        "application/scaip+xml": {
          source: "iana",
          compressible: true
        },
        "application/scim+json": {
          source: "iana",
          compressible: true
        },
        "application/scvp-cv-request": {
          source: "iana",
          extensions: ["scq"]
        },
        "application/scvp-cv-response": {
          source: "iana",
          extensions: ["scs"]
        },
        "application/scvp-vp-request": {
          source: "iana",
          extensions: ["spq"]
        },
        "application/scvp-vp-response": {
          source: "iana",
          extensions: ["spp"]
        },
        "application/sdp": {
          source: "iana",
          extensions: ["sdp"]
        },
        "application/secevent+jwt": {
          source: "iana"
        },
        "application/senml+cbor": {
          source: "iana"
        },
        "application/senml+json": {
          source: "iana",
          compressible: true
        },
        "application/senml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["senmlx"]
        },
        "application/senml-etch+cbor": {
          source: "iana"
        },
        "application/senml-etch+json": {
          source: "iana",
          compressible: true
        },
        "application/senml-exi": {
          source: "iana"
        },
        "application/sensml+cbor": {
          source: "iana"
        },
        "application/sensml+json": {
          source: "iana",
          compressible: true
        },
        "application/sensml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["sensmlx"]
        },
        "application/sensml-exi": {
          source: "iana"
        },
        "application/sep+xml": {
          source: "iana",
          compressible: true
        },
        "application/sep-exi": {
          source: "iana"
        },
        "application/session-info": {
          source: "iana"
        },
        "application/set-payment": {
          source: "iana"
        },
        "application/set-payment-initiation": {
          source: "iana",
          extensions: ["setpay"]
        },
        "application/set-registration": {
          source: "iana"
        },
        "application/set-registration-initiation": {
          source: "iana",
          extensions: ["setreg"]
        },
        "application/sgml": {
          source: "iana"
        },
        "application/sgml-open-catalog": {
          source: "iana"
        },
        "application/shf+xml": {
          source: "iana",
          compressible: true,
          extensions: ["shf"]
        },
        "application/sieve": {
          source: "iana",
          extensions: ["siv", "sieve"]
        },
        "application/simple-filter+xml": {
          source: "iana",
          compressible: true
        },
        "application/simple-message-summary": {
          source: "iana"
        },
        "application/simplesymbolcontainer": {
          source: "iana"
        },
        "application/sipc": {
          source: "iana"
        },
        "application/slate": {
          source: "iana"
        },
        "application/smil": {
          source: "iana"
        },
        "application/smil+xml": {
          source: "iana",
          compressible: true,
          extensions: ["smi", "smil"]
        },
        "application/smpte336m": {
          source: "iana"
        },
        "application/soap+fastinfoset": {
          source: "iana"
        },
        "application/soap+xml": {
          source: "iana",
          compressible: true
        },
        "application/sparql-query": {
          source: "iana",
          extensions: ["rq"]
        },
        "application/sparql-results+xml": {
          source: "iana",
          compressible: true,
          extensions: ["srx"]
        },
        "application/spdx+json": {
          source: "iana",
          compressible: true
        },
        "application/spirits-event+xml": {
          source: "iana",
          compressible: true
        },
        "application/sql": {
          source: "iana"
        },
        "application/srgs": {
          source: "iana",
          extensions: ["gram"]
        },
        "application/srgs+xml": {
          source: "iana",
          compressible: true,
          extensions: ["grxml"]
        },
        "application/sru+xml": {
          source: "iana",
          compressible: true,
          extensions: ["sru"]
        },
        "application/ssdl+xml": {
          source: "apache",
          compressible: true,
          extensions: ["ssdl"]
        },
        "application/ssml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["ssml"]
        },
        "application/stix+json": {
          source: "iana",
          compressible: true
        },
        "application/swid+xml": {
          source: "iana",
          compressible: true,
          extensions: ["swidtag"]
        },
        "application/tamp-apex-update": {
          source: "iana"
        },
        "application/tamp-apex-update-confirm": {
          source: "iana"
        },
        "application/tamp-community-update": {
          source: "iana"
        },
        "application/tamp-community-update-confirm": {
          source: "iana"
        },
        "application/tamp-error": {
          source: "iana"
        },
        "application/tamp-sequence-adjust": {
          source: "iana"
        },
        "application/tamp-sequence-adjust-confirm": {
          source: "iana"
        },
        "application/tamp-status-query": {
          source: "iana"
        },
        "application/tamp-status-response": {
          source: "iana"
        },
        "application/tamp-update": {
          source: "iana"
        },
        "application/tamp-update-confirm": {
          source: "iana"
        },
        "application/tar": {
          compressible: true
        },
        "application/taxii+json": {
          source: "iana",
          compressible: true
        },
        "application/td+json": {
          source: "iana",
          compressible: true
        },
        "application/tei+xml": {
          source: "iana",
          compressible: true,
          extensions: ["tei", "teicorpus"]
        },
        "application/tetra_isi": {
          source: "iana"
        },
        "application/thraud+xml": {
          source: "iana",
          compressible: true,
          extensions: ["tfi"]
        },
        "application/timestamp-query": {
          source: "iana"
        },
        "application/timestamp-reply": {
          source: "iana"
        },
        "application/timestamped-data": {
          source: "iana",
          extensions: ["tsd"]
        },
        "application/tlsrpt+gzip": {
          source: "iana"
        },
        "application/tlsrpt+json": {
          source: "iana",
          compressible: true
        },
        "application/tnauthlist": {
          source: "iana"
        },
        "application/token-introspection+jwt": {
          source: "iana"
        },
        "application/toml": {
          compressible: true,
          extensions: ["toml"]
        },
        "application/trickle-ice-sdpfrag": {
          source: "iana"
        },
        "application/trig": {
          source: "iana",
          extensions: ["trig"]
        },
        "application/ttml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["ttml"]
        },
        "application/tve-trigger": {
          source: "iana"
        },
        "application/tzif": {
          source: "iana"
        },
        "application/tzif-leap": {
          source: "iana"
        },
        "application/ubjson": {
          compressible: false,
          extensions: ["ubj"]
        },
        "application/ulpfec": {
          source: "iana"
        },
        "application/urc-grpsheet+xml": {
          source: "iana",
          compressible: true
        },
        "application/urc-ressheet+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rsheet"]
        },
        "application/urc-targetdesc+xml": {
          source: "iana",
          compressible: true,
          extensions: ["td"]
        },
        "application/urc-uisocketdesc+xml": {
          source: "iana",
          compressible: true
        },
        "application/vcard+json": {
          source: "iana",
          compressible: true
        },
        "application/vcard+xml": {
          source: "iana",
          compressible: true
        },
        "application/vemmi": {
          source: "iana"
        },
        "application/vividence.scriptfile": {
          source: "apache"
        },
        "application/vnd.1000minds.decision-model+xml": {
          source: "iana",
          compressible: true,
          extensions: ["1km"]
        },
        "application/vnd.3gpp-prose+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp-prose-pc3ch+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp-v2x-local-service-information": {
          source: "iana"
        },
        "application/vnd.3gpp.5gnas": {
          source: "iana"
        },
        "application/vnd.3gpp.access-transfer-events+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.bsf+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.gmop+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.gtpc": {
          source: "iana"
        },
        "application/vnd.3gpp.interworking-data": {
          source: "iana"
        },
        "application/vnd.3gpp.lpp": {
          source: "iana"
        },
        "application/vnd.3gpp.mc-signalling-ear": {
          source: "iana"
        },
        "application/vnd.3gpp.mcdata-affiliation-command+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcdata-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcdata-payload": {
          source: "iana"
        },
        "application/vnd.3gpp.mcdata-service-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcdata-signalling": {
          source: "iana"
        },
        "application/vnd.3gpp.mcdata-ue-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcdata-user-profile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-affiliation-command+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-floor-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-location-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-service-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-signed+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-ue-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-ue-init-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-user-profile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-location-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-service-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-transmission-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-ue-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-user-profile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mid-call+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.ngap": {
          source: "iana"
        },
        "application/vnd.3gpp.pfcp": {
          source: "iana"
        },
        "application/vnd.3gpp.pic-bw-large": {
          source: "iana",
          extensions: ["plb"]
        },
        "application/vnd.3gpp.pic-bw-small": {
          source: "iana",
          extensions: ["psb"]
        },
        "application/vnd.3gpp.pic-bw-var": {
          source: "iana",
          extensions: ["pvb"]
        },
        "application/vnd.3gpp.s1ap": {
          source: "iana"
        },
        "application/vnd.3gpp.sms": {
          source: "iana"
        },
        "application/vnd.3gpp.sms+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.srvcc-ext+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.srvcc-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.state-and-event-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.ussd+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp2.bcmcsinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp2.sms": {
          source: "iana"
        },
        "application/vnd.3gpp2.tcap": {
          source: "iana",
          extensions: ["tcap"]
        },
        "application/vnd.3lightssoftware.imagescal": {
          source: "iana"
        },
        "application/vnd.3m.post-it-notes": {
          source: "iana",
          extensions: ["pwn"]
        },
        "application/vnd.accpac.simply.aso": {
          source: "iana",
          extensions: ["aso"]
        },
        "application/vnd.accpac.simply.imp": {
          source: "iana",
          extensions: ["imp"]
        },
        "application/vnd.acucobol": {
          source: "iana",
          extensions: ["acu"]
        },
        "application/vnd.acucorp": {
          source: "iana",
          extensions: ["atc", "acutc"]
        },
        "application/vnd.adobe.air-application-installer-package+zip": {
          source: "apache",
          compressible: false,
          extensions: ["air"]
        },
        "application/vnd.adobe.flash.movie": {
          source: "iana"
        },
        "application/vnd.adobe.formscentral.fcdt": {
          source: "iana",
          extensions: ["fcdt"]
        },
        "application/vnd.adobe.fxp": {
          source: "iana",
          extensions: ["fxp", "fxpl"]
        },
        "application/vnd.adobe.partial-upload": {
          source: "iana"
        },
        "application/vnd.adobe.xdp+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xdp"]
        },
        "application/vnd.adobe.xfdf": {
          source: "iana",
          extensions: ["xfdf"]
        },
        "application/vnd.aether.imp": {
          source: "iana"
        },
        "application/vnd.afpc.afplinedata": {
          source: "iana"
        },
        "application/vnd.afpc.afplinedata-pagedef": {
          source: "iana"
        },
        "application/vnd.afpc.cmoca-cmresource": {
          source: "iana"
        },
        "application/vnd.afpc.foca-charset": {
          source: "iana"
        },
        "application/vnd.afpc.foca-codedfont": {
          source: "iana"
        },
        "application/vnd.afpc.foca-codepage": {
          source: "iana"
        },
        "application/vnd.afpc.modca": {
          source: "iana"
        },
        "application/vnd.afpc.modca-cmtable": {
          source: "iana"
        },
        "application/vnd.afpc.modca-formdef": {
          source: "iana"
        },
        "application/vnd.afpc.modca-mediummap": {
          source: "iana"
        },
        "application/vnd.afpc.modca-objectcontainer": {
          source: "iana"
        },
        "application/vnd.afpc.modca-overlay": {
          source: "iana"
        },
        "application/vnd.afpc.modca-pagesegment": {
          source: "iana"
        },
        "application/vnd.age": {
          source: "iana",
          extensions: ["age"]
        },
        "application/vnd.ah-barcode": {
          source: "iana"
        },
        "application/vnd.ahead.space": {
          source: "iana",
          extensions: ["ahead"]
        },
        "application/vnd.airzip.filesecure.azf": {
          source: "iana",
          extensions: ["azf"]
        },
        "application/vnd.airzip.filesecure.azs": {
          source: "iana",
          extensions: ["azs"]
        },
        "application/vnd.amadeus+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.amazon.ebook": {
          source: "apache",
          extensions: ["azw"]
        },
        "application/vnd.amazon.mobi8-ebook": {
          source: "iana"
        },
        "application/vnd.americandynamics.acc": {
          source: "iana",
          extensions: ["acc"]
        },
        "application/vnd.amiga.ami": {
          source: "iana",
          extensions: ["ami"]
        },
        "application/vnd.amundsen.maze+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.android.ota": {
          source: "iana"
        },
        "application/vnd.android.package-archive": {
          source: "apache",
          compressible: false,
          extensions: ["apk"]
        },
        "application/vnd.anki": {
          source: "iana"
        },
        "application/vnd.anser-web-certificate-issue-initiation": {
          source: "iana",
          extensions: ["cii"]
        },
        "application/vnd.anser-web-funds-transfer-initiation": {
          source: "apache",
          extensions: ["fti"]
        },
        "application/vnd.antix.game-component": {
          source: "iana",
          extensions: ["atx"]
        },
        "application/vnd.apache.arrow.file": {
          source: "iana"
        },
        "application/vnd.apache.arrow.stream": {
          source: "iana"
        },
        "application/vnd.apache.thrift.binary": {
          source: "iana"
        },
        "application/vnd.apache.thrift.compact": {
          source: "iana"
        },
        "application/vnd.apache.thrift.json": {
          source: "iana"
        },
        "application/vnd.api+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.aplextor.warrp+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.apothekende.reservation+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.apple.installer+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mpkg"]
        },
        "application/vnd.apple.keynote": {
          source: "iana",
          extensions: ["key"]
        },
        "application/vnd.apple.mpegurl": {
          source: "iana",
          extensions: ["m3u8"]
        },
        "application/vnd.apple.numbers": {
          source: "iana",
          extensions: ["numbers"]
        },
        "application/vnd.apple.pages": {
          source: "iana",
          extensions: ["pages"]
        },
        "application/vnd.apple.pkpass": {
          compressible: false,
          extensions: ["pkpass"]
        },
        "application/vnd.arastra.swi": {
          source: "iana"
        },
        "application/vnd.aristanetworks.swi": {
          source: "iana",
          extensions: ["swi"]
        },
        "application/vnd.artisan+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.artsquare": {
          source: "iana"
        },
        "application/vnd.astraea-software.iota": {
          source: "iana",
          extensions: ["iota"]
        },
        "application/vnd.audiograph": {
          source: "iana",
          extensions: ["aep"]
        },
        "application/vnd.autopackage": {
          source: "iana"
        },
        "application/vnd.avalon+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.avistar+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.balsamiq.bmml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["bmml"]
        },
        "application/vnd.balsamiq.bmpr": {
          source: "iana"
        },
        "application/vnd.banana-accounting": {
          source: "iana"
        },
        "application/vnd.bbf.usp.error": {
          source: "iana"
        },
        "application/vnd.bbf.usp.msg": {
          source: "iana"
        },
        "application/vnd.bbf.usp.msg+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.bekitzur-stech+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.bint.med-content": {
          source: "iana"
        },
        "application/vnd.biopax.rdf+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.blink-idb-value-wrapper": {
          source: "iana"
        },
        "application/vnd.blueice.multipass": {
          source: "iana",
          extensions: ["mpm"]
        },
        "application/vnd.bluetooth.ep.oob": {
          source: "iana"
        },
        "application/vnd.bluetooth.le.oob": {
          source: "iana"
        },
        "application/vnd.bmi": {
          source: "iana",
          extensions: ["bmi"]
        },
        "application/vnd.bpf": {
          source: "iana"
        },
        "application/vnd.bpf3": {
          source: "iana"
        },
        "application/vnd.businessobjects": {
          source: "iana",
          extensions: ["rep"]
        },
        "application/vnd.byu.uapi+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cab-jscript": {
          source: "iana"
        },
        "application/vnd.canon-cpdl": {
          source: "iana"
        },
        "application/vnd.canon-lips": {
          source: "iana"
        },
        "application/vnd.capasystems-pg+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cendio.thinlinc.clientconf": {
          source: "iana"
        },
        "application/vnd.century-systems.tcp_stream": {
          source: "iana"
        },
        "application/vnd.chemdraw+xml": {
          source: "iana",
          compressible: true,
          extensions: ["cdxml"]
        },
        "application/vnd.chess-pgn": {
          source: "iana"
        },
        "application/vnd.chipnuts.karaoke-mmd": {
          source: "iana",
          extensions: ["mmd"]
        },
        "application/vnd.ciedi": {
          source: "iana"
        },
        "application/vnd.cinderella": {
          source: "iana",
          extensions: ["cdy"]
        },
        "application/vnd.cirpack.isdn-ext": {
          source: "iana"
        },
        "application/vnd.citationstyles.style+xml": {
          source: "iana",
          compressible: true,
          extensions: ["csl"]
        },
        "application/vnd.claymore": {
          source: "iana",
          extensions: ["cla"]
        },
        "application/vnd.cloanto.rp9": {
          source: "iana",
          extensions: ["rp9"]
        },
        "application/vnd.clonk.c4group": {
          source: "iana",
          extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
        },
        "application/vnd.cluetrust.cartomobile-config": {
          source: "iana",
          extensions: ["c11amc"]
        },
        "application/vnd.cluetrust.cartomobile-config-pkg": {
          source: "iana",
          extensions: ["c11amz"]
        },
        "application/vnd.coffeescript": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.document": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.document-template": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.presentation": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.presentation-template": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.spreadsheet": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.spreadsheet-template": {
          source: "iana"
        },
        "application/vnd.collection+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.collection.doc+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.collection.next+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.comicbook+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.comicbook-rar": {
          source: "iana"
        },
        "application/vnd.commerce-battelle": {
          source: "iana"
        },
        "application/vnd.commonspace": {
          source: "iana",
          extensions: ["csp"]
        },
        "application/vnd.contact.cmsg": {
          source: "iana",
          extensions: ["cdbcmsg"]
        },
        "application/vnd.coreos.ignition+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cosmocaller": {
          source: "iana",
          extensions: ["cmc"]
        },
        "application/vnd.crick.clicker": {
          source: "iana",
          extensions: ["clkx"]
        },
        "application/vnd.crick.clicker.keyboard": {
          source: "iana",
          extensions: ["clkk"]
        },
        "application/vnd.crick.clicker.palette": {
          source: "iana",
          extensions: ["clkp"]
        },
        "application/vnd.crick.clicker.template": {
          source: "iana",
          extensions: ["clkt"]
        },
        "application/vnd.crick.clicker.wordbank": {
          source: "iana",
          extensions: ["clkw"]
        },
        "application/vnd.criticaltools.wbs+xml": {
          source: "iana",
          compressible: true,
          extensions: ["wbs"]
        },
        "application/vnd.cryptii.pipe+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.crypto-shade-file": {
          source: "iana"
        },
        "application/vnd.cryptomator.encrypted": {
          source: "iana"
        },
        "application/vnd.cryptomator.vault": {
          source: "iana"
        },
        "application/vnd.ctc-posml": {
          source: "iana",
          extensions: ["pml"]
        },
        "application/vnd.ctct.ws+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cups-pdf": {
          source: "iana"
        },
        "application/vnd.cups-postscript": {
          source: "iana"
        },
        "application/vnd.cups-ppd": {
          source: "iana",
          extensions: ["ppd"]
        },
        "application/vnd.cups-raster": {
          source: "iana"
        },
        "application/vnd.cups-raw": {
          source: "iana"
        },
        "application/vnd.curl": {
          source: "iana"
        },
        "application/vnd.curl.car": {
          source: "apache",
          extensions: ["car"]
        },
        "application/vnd.curl.pcurl": {
          source: "apache",
          extensions: ["pcurl"]
        },
        "application/vnd.cyan.dean.root+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cybank": {
          source: "iana"
        },
        "application/vnd.cyclonedx+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cyclonedx+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.d2l.coursepackage1p0+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.d3m-dataset": {
          source: "iana"
        },
        "application/vnd.d3m-problem": {
          source: "iana"
        },
        "application/vnd.dart": {
          source: "iana",
          compressible: true,
          extensions: ["dart"]
        },
        "application/vnd.data-vision.rdz": {
          source: "iana",
          extensions: ["rdz"]
        },
        "application/vnd.datapackage+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dataresource+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dbf": {
          source: "iana",
          extensions: ["dbf"]
        },
        "application/vnd.debian.binary-package": {
          source: "iana"
        },
        "application/vnd.dece.data": {
          source: "iana",
          extensions: ["uvf", "uvvf", "uvd", "uvvd"]
        },
        "application/vnd.dece.ttml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["uvt", "uvvt"]
        },
        "application/vnd.dece.unspecified": {
          source: "iana",
          extensions: ["uvx", "uvvx"]
        },
        "application/vnd.dece.zip": {
          source: "iana",
          extensions: ["uvz", "uvvz"]
        },
        "application/vnd.denovo.fcselayout-link": {
          source: "iana",
          extensions: ["fe_launch"]
        },
        "application/vnd.desmume.movie": {
          source: "iana"
        },
        "application/vnd.dir-bi.plate-dl-nosuffix": {
          source: "iana"
        },
        "application/vnd.dm.delegation+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dna": {
          source: "iana",
          extensions: ["dna"]
        },
        "application/vnd.document+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dolby.mlp": {
          source: "apache",
          extensions: ["mlp"]
        },
        "application/vnd.dolby.mobile.1": {
          source: "iana"
        },
        "application/vnd.dolby.mobile.2": {
          source: "iana"
        },
        "application/vnd.doremir.scorecloud-binary-document": {
          source: "iana"
        },
        "application/vnd.dpgraph": {
          source: "iana",
          extensions: ["dpg"]
        },
        "application/vnd.dreamfactory": {
          source: "iana",
          extensions: ["dfac"]
        },
        "application/vnd.drive+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ds-keypoint": {
          source: "apache",
          extensions: ["kpxx"]
        },
        "application/vnd.dtg.local": {
          source: "iana"
        },
        "application/vnd.dtg.local.flash": {
          source: "iana"
        },
        "application/vnd.dtg.local.html": {
          source: "iana"
        },
        "application/vnd.dvb.ait": {
          source: "iana",
          extensions: ["ait"]
        },
        "application/vnd.dvb.dvbisl+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.dvbj": {
          source: "iana"
        },
        "application/vnd.dvb.esgcontainer": {
          source: "iana"
        },
        "application/vnd.dvb.ipdcdftnotifaccess": {
          source: "iana"
        },
        "application/vnd.dvb.ipdcesgaccess": {
          source: "iana"
        },
        "application/vnd.dvb.ipdcesgaccess2": {
          source: "iana"
        },
        "application/vnd.dvb.ipdcesgpdd": {
          source: "iana"
        },
        "application/vnd.dvb.ipdcroaming": {
          source: "iana"
        },
        "application/vnd.dvb.iptv.alfec-base": {
          source: "iana"
        },
        "application/vnd.dvb.iptv.alfec-enhancement": {
          source: "iana"
        },
        "application/vnd.dvb.notif-aggregate-root+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-container+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-generic+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-ia-msglist+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-ia-registration-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-ia-registration-response+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-init+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.pfr": {
          source: "iana"
        },
        "application/vnd.dvb.service": {
          source: "iana",
          extensions: ["svc"]
        },
        "application/vnd.dxr": {
          source: "iana"
        },
        "application/vnd.dynageo": {
          source: "iana",
          extensions: ["geo"]
        },
        "application/vnd.dzr": {
          source: "iana"
        },
        "application/vnd.easykaraoke.cdgdownload": {
          source: "iana"
        },
        "application/vnd.ecdis-update": {
          source: "iana"
        },
        "application/vnd.ecip.rlp": {
          source: "iana"
        },
        "application/vnd.eclipse.ditto+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ecowin.chart": {
          source: "iana",
          extensions: ["mag"]
        },
        "application/vnd.ecowin.filerequest": {
          source: "iana"
        },
        "application/vnd.ecowin.fileupdate": {
          source: "iana"
        },
        "application/vnd.ecowin.series": {
          source: "iana"
        },
        "application/vnd.ecowin.seriesrequest": {
          source: "iana"
        },
        "application/vnd.ecowin.seriesupdate": {
          source: "iana"
        },
        "application/vnd.efi.img": {
          source: "iana"
        },
        "application/vnd.efi.iso": {
          source: "iana"
        },
        "application/vnd.emclient.accessrequest+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.enliven": {
          source: "iana",
          extensions: ["nml"]
        },
        "application/vnd.enphase.envoy": {
          source: "iana"
        },
        "application/vnd.eprints.data+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.epson.esf": {
          source: "iana",
          extensions: ["esf"]
        },
        "application/vnd.epson.msf": {
          source: "iana",
          extensions: ["msf"]
        },
        "application/vnd.epson.quickanime": {
          source: "iana",
          extensions: ["qam"]
        },
        "application/vnd.epson.salt": {
          source: "iana",
          extensions: ["slt"]
        },
        "application/vnd.epson.ssf": {
          source: "iana",
          extensions: ["ssf"]
        },
        "application/vnd.ericsson.quickcall": {
          source: "iana"
        },
        "application/vnd.espass-espass+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.eszigno3+xml": {
          source: "iana",
          compressible: true,
          extensions: ["es3", "et3"]
        },
        "application/vnd.etsi.aoc+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.asic-e+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.etsi.asic-s+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.etsi.cug+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvcommand+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvdiscovery+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvprofile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvsad-bc+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvsad-cod+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvsad-npvr+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvservice+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvsync+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvueprofile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.mcid+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.mheg5": {
          source: "iana"
        },
        "application/vnd.etsi.overload-control-policy-dataset+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.pstn+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.sci+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.simservs+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.timestamp-token": {
          source: "iana"
        },
        "application/vnd.etsi.tsl+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.tsl.der": {
          source: "iana"
        },
        "application/vnd.eu.kasparian.car+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.eudora.data": {
          source: "iana"
        },
        "application/vnd.evolv.ecig.profile": {
          source: "iana"
        },
        "application/vnd.evolv.ecig.settings": {
          source: "iana"
        },
        "application/vnd.evolv.ecig.theme": {
          source: "iana"
        },
        "application/vnd.exstream-empower+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.exstream-package": {
          source: "iana"
        },
        "application/vnd.ezpix-album": {
          source: "iana",
          extensions: ["ez2"]
        },
        "application/vnd.ezpix-package": {
          source: "iana",
          extensions: ["ez3"]
        },
        "application/vnd.f-secure.mobile": {
          source: "iana"
        },
        "application/vnd.familysearch.gedcom+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.fastcopy-disk-image": {
          source: "iana"
        },
        "application/vnd.fdf": {
          source: "iana",
          extensions: ["fdf"]
        },
        "application/vnd.fdsn.mseed": {
          source: "iana",
          extensions: ["mseed"]
        },
        "application/vnd.fdsn.seed": {
          source: "iana",
          extensions: ["seed", "dataless"]
        },
        "application/vnd.ffsns": {
          source: "iana"
        },
        "application/vnd.ficlab.flb+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.filmit.zfc": {
          source: "iana"
        },
        "application/vnd.fints": {
          source: "iana"
        },
        "application/vnd.firemonkeys.cloudcell": {
          source: "iana"
        },
        "application/vnd.flographit": {
          source: "iana",
          extensions: ["gph"]
        },
        "application/vnd.fluxtime.clip": {
          source: "iana",
          extensions: ["ftc"]
        },
        "application/vnd.font-fontforge-sfd": {
          source: "iana"
        },
        "application/vnd.framemaker": {
          source: "iana",
          extensions: ["fm", "frame", "maker", "book"]
        },
        "application/vnd.frogans.fnc": {
          source: "iana",
          extensions: ["fnc"]
        },
        "application/vnd.frogans.ltf": {
          source: "iana",
          extensions: ["ltf"]
        },
        "application/vnd.fsc.weblaunch": {
          source: "iana",
          extensions: ["fsc"]
        },
        "application/vnd.fujifilm.fb.docuworks": {
          source: "iana"
        },
        "application/vnd.fujifilm.fb.docuworks.binder": {
          source: "iana"
        },
        "application/vnd.fujifilm.fb.docuworks.container": {
          source: "iana"
        },
        "application/vnd.fujifilm.fb.jfi+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.fujitsu.oasys": {
          source: "iana",
          extensions: ["oas"]
        },
        "application/vnd.fujitsu.oasys2": {
          source: "iana",
          extensions: ["oa2"]
        },
        "application/vnd.fujitsu.oasys3": {
          source: "iana",
          extensions: ["oa3"]
        },
        "application/vnd.fujitsu.oasysgp": {
          source: "iana",
          extensions: ["fg5"]
        },
        "application/vnd.fujitsu.oasysprs": {
          source: "iana",
          extensions: ["bh2"]
        },
        "application/vnd.fujixerox.art-ex": {
          source: "iana"
        },
        "application/vnd.fujixerox.art4": {
          source: "iana"
        },
        "application/vnd.fujixerox.ddd": {
          source: "iana",
          extensions: ["ddd"]
        },
        "application/vnd.fujixerox.docuworks": {
          source: "iana",
          extensions: ["xdw"]
        },
        "application/vnd.fujixerox.docuworks.binder": {
          source: "iana",
          extensions: ["xbd"]
        },
        "application/vnd.fujixerox.docuworks.container": {
          source: "iana"
        },
        "application/vnd.fujixerox.hbpl": {
          source: "iana"
        },
        "application/vnd.fut-misnet": {
          source: "iana"
        },
        "application/vnd.futoin+cbor": {
          source: "iana"
        },
        "application/vnd.futoin+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.fuzzysheet": {
          source: "iana",
          extensions: ["fzs"]
        },
        "application/vnd.genomatix.tuxedo": {
          source: "iana",
          extensions: ["txd"]
        },
        "application/vnd.gentics.grd+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.geo+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.geocube+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.geogebra.file": {
          source: "iana",
          extensions: ["ggb"]
        },
        "application/vnd.geogebra.slides": {
          source: "iana"
        },
        "application/vnd.geogebra.tool": {
          source: "iana",
          extensions: ["ggt"]
        },
        "application/vnd.geometry-explorer": {
          source: "iana",
          extensions: ["gex", "gre"]
        },
        "application/vnd.geonext": {
          source: "iana",
          extensions: ["gxt"]
        },
        "application/vnd.geoplan": {
          source: "iana",
          extensions: ["g2w"]
        },
        "application/vnd.geospace": {
          source: "iana",
          extensions: ["g3w"]
        },
        "application/vnd.gerber": {
          source: "iana"
        },
        "application/vnd.globalplatform.card-content-mgt": {
          source: "iana"
        },
        "application/vnd.globalplatform.card-content-mgt-response": {
          source: "iana"
        },
        "application/vnd.gmx": {
          source: "iana",
          extensions: ["gmx"]
        },
        "application/vnd.google-apps.document": {
          compressible: false,
          extensions: ["gdoc"]
        },
        "application/vnd.google-apps.presentation": {
          compressible: false,
          extensions: ["gslides"]
        },
        "application/vnd.google-apps.spreadsheet": {
          compressible: false,
          extensions: ["gsheet"]
        },
        "application/vnd.google-earth.kml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["kml"]
        },
        "application/vnd.google-earth.kmz": {
          source: "iana",
          compressible: false,
          extensions: ["kmz"]
        },
        "application/vnd.gov.sk.e-form+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.gov.sk.e-form+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.gov.sk.xmldatacontainer+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.grafeq": {
          source: "iana",
          extensions: ["gqf", "gqs"]
        },
        "application/vnd.gridmp": {
          source: "iana"
        },
        "application/vnd.groove-account": {
          source: "iana",
          extensions: ["gac"]
        },
        "application/vnd.groove-help": {
          source: "iana",
          extensions: ["ghf"]
        },
        "application/vnd.groove-identity-message": {
          source: "iana",
          extensions: ["gim"]
        },
        "application/vnd.groove-injector": {
          source: "iana",
          extensions: ["grv"]
        },
        "application/vnd.groove-tool-message": {
          source: "iana",
          extensions: ["gtm"]
        },
        "application/vnd.groove-tool-template": {
          source: "iana",
          extensions: ["tpl"]
        },
        "application/vnd.groove-vcard": {
          source: "iana",
          extensions: ["vcg"]
        },
        "application/vnd.hal+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hal+xml": {
          source: "iana",
          compressible: true,
          extensions: ["hal"]
        },
        "application/vnd.handheld-entertainment+xml": {
          source: "iana",
          compressible: true,
          extensions: ["zmm"]
        },
        "application/vnd.hbci": {
          source: "iana",
          extensions: ["hbci"]
        },
        "application/vnd.hc+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hcl-bireports": {
          source: "iana"
        },
        "application/vnd.hdt": {
          source: "iana"
        },
        "application/vnd.heroku+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hhe.lesson-player": {
          source: "iana",
          extensions: ["les"]
        },
        "application/vnd.hl7cda+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.hl7v2+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.hp-hpgl": {
          source: "iana",
          extensions: ["hpgl"]
        },
        "application/vnd.hp-hpid": {
          source: "iana",
          extensions: ["hpid"]
        },
        "application/vnd.hp-hps": {
          source: "iana",
          extensions: ["hps"]
        },
        "application/vnd.hp-jlyt": {
          source: "iana",
          extensions: ["jlt"]
        },
        "application/vnd.hp-pcl": {
          source: "iana",
          extensions: ["pcl"]
        },
        "application/vnd.hp-pclxl": {
          source: "iana",
          extensions: ["pclxl"]
        },
        "application/vnd.httphone": {
          source: "iana"
        },
        "application/vnd.hydrostatix.sof-data": {
          source: "iana",
          extensions: ["sfd-hdstx"]
        },
        "application/vnd.hyper+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hyper-item+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hyperdrive+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hzn-3d-crossword": {
          source: "iana"
        },
        "application/vnd.ibm.afplinedata": {
          source: "iana"
        },
        "application/vnd.ibm.electronic-media": {
          source: "iana"
        },
        "application/vnd.ibm.minipay": {
          source: "iana",
          extensions: ["mpy"]
        },
        "application/vnd.ibm.modcap": {
          source: "iana",
          extensions: ["afp", "listafp", "list3820"]
        },
        "application/vnd.ibm.rights-management": {
          source: "iana",
          extensions: ["irm"]
        },
        "application/vnd.ibm.secure-container": {
          source: "iana",
          extensions: ["sc"]
        },
        "application/vnd.iccprofile": {
          source: "iana",
          extensions: ["icc", "icm"]
        },
        "application/vnd.ieee.1905": {
          source: "iana"
        },
        "application/vnd.igloader": {
          source: "iana",
          extensions: ["igl"]
        },
        "application/vnd.imagemeter.folder+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.imagemeter.image+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.immervision-ivp": {
          source: "iana",
          extensions: ["ivp"]
        },
        "application/vnd.immervision-ivu": {
          source: "iana",
          extensions: ["ivu"]
        },
        "application/vnd.ims.imsccv1p1": {
          source: "iana"
        },
        "application/vnd.ims.imsccv1p2": {
          source: "iana"
        },
        "application/vnd.ims.imsccv1p3": {
          source: "iana"
        },
        "application/vnd.ims.lis.v2.result+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ims.lti.v2.toolproxy+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ims.lti.v2.toolproxy.id+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ims.lti.v2.toolsettings+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ims.lti.v2.toolsettings.simple+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.informedcontrol.rms+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.informix-visionary": {
          source: "iana"
        },
        "application/vnd.infotech.project": {
          source: "iana"
        },
        "application/vnd.infotech.project+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.innopath.wamp.notification": {
          source: "iana"
        },
        "application/vnd.insors.igm": {
          source: "iana",
          extensions: ["igm"]
        },
        "application/vnd.intercon.formnet": {
          source: "iana",
          extensions: ["xpw", "xpx"]
        },
        "application/vnd.intergeo": {
          source: "iana",
          extensions: ["i2g"]
        },
        "application/vnd.intertrust.digibox": {
          source: "iana"
        },
        "application/vnd.intertrust.nncp": {
          source: "iana"
        },
        "application/vnd.intu.qbo": {
          source: "iana",
          extensions: ["qbo"]
        },
        "application/vnd.intu.qfx": {
          source: "iana",
          extensions: ["qfx"]
        },
        "application/vnd.iptc.g2.catalogitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.conceptitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.knowledgeitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.newsitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.newsmessage+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.packageitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.planningitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ipunplugged.rcprofile": {
          source: "iana",
          extensions: ["rcprofile"]
        },
        "application/vnd.irepository.package+xml": {
          source: "iana",
          compressible: true,
          extensions: ["irp"]
        },
        "application/vnd.is-xpr": {
          source: "iana",
          extensions: ["xpr"]
        },
        "application/vnd.isac.fcs": {
          source: "iana",
          extensions: ["fcs"]
        },
        "application/vnd.iso11783-10+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.jam": {
          source: "iana",
          extensions: ["jam"]
        },
        "application/vnd.japannet-directory-service": {
          source: "iana"
        },
        "application/vnd.japannet-jpnstore-wakeup": {
          source: "iana"
        },
        "application/vnd.japannet-payment-wakeup": {
          source: "iana"
        },
        "application/vnd.japannet-registration": {
          source: "iana"
        },
        "application/vnd.japannet-registration-wakeup": {
          source: "iana"
        },
        "application/vnd.japannet-setstore-wakeup": {
          source: "iana"
        },
        "application/vnd.japannet-verification": {
          source: "iana"
        },
        "application/vnd.japannet-verification-wakeup": {
          source: "iana"
        },
        "application/vnd.jcp.javame.midlet-rms": {
          source: "iana",
          extensions: ["rms"]
        },
        "application/vnd.jisp": {
          source: "iana",
          extensions: ["jisp"]
        },
        "application/vnd.joost.joda-archive": {
          source: "iana",
          extensions: ["joda"]
        },
        "application/vnd.jsk.isdn-ngn": {
          source: "iana"
        },
        "application/vnd.kahootz": {
          source: "iana",
          extensions: ["ktz", "ktr"]
        },
        "application/vnd.kde.karbon": {
          source: "iana",
          extensions: ["karbon"]
        },
        "application/vnd.kde.kchart": {
          source: "iana",
          extensions: ["chrt"]
        },
        "application/vnd.kde.kformula": {
          source: "iana",
          extensions: ["kfo"]
        },
        "application/vnd.kde.kivio": {
          source: "iana",
          extensions: ["flw"]
        },
        "application/vnd.kde.kontour": {
          source: "iana",
          extensions: ["kon"]
        },
        "application/vnd.kde.kpresenter": {
          source: "iana",
          extensions: ["kpr", "kpt"]
        },
        "application/vnd.kde.kspread": {
          source: "iana",
          extensions: ["ksp"]
        },
        "application/vnd.kde.kword": {
          source: "iana",
          extensions: ["kwd", "kwt"]
        },
        "application/vnd.kenameaapp": {
          source: "iana",
          extensions: ["htke"]
        },
        "application/vnd.kidspiration": {
          source: "iana",
          extensions: ["kia"]
        },
        "application/vnd.kinar": {
          source: "iana",
          extensions: ["kne", "knp"]
        },
        "application/vnd.koan": {
          source: "iana",
          extensions: ["skp", "skd", "skt", "skm"]
        },
        "application/vnd.kodak-descriptor": {
          source: "iana",
          extensions: ["sse"]
        },
        "application/vnd.las": {
          source: "iana"
        },
        "application/vnd.las.las+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.las.las+xml": {
          source: "iana",
          compressible: true,
          extensions: ["lasxml"]
        },
        "application/vnd.laszip": {
          source: "iana"
        },
        "application/vnd.leap+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.liberty-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.llamagraphics.life-balance.desktop": {
          source: "iana",
          extensions: ["lbd"]
        },
        "application/vnd.llamagraphics.life-balance.exchange+xml": {
          source: "iana",
          compressible: true,
          extensions: ["lbe"]
        },
        "application/vnd.logipipe.circuit+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.loom": {
          source: "iana"
        },
        "application/vnd.lotus-1-2-3": {
          source: "iana",
          extensions: ["123"]
        },
        "application/vnd.lotus-approach": {
          source: "iana",
          extensions: ["apr"]
        },
        "application/vnd.lotus-freelance": {
          source: "iana",
          extensions: ["pre"]
        },
        "application/vnd.lotus-notes": {
          source: "iana",
          extensions: ["nsf"]
        },
        "application/vnd.lotus-organizer": {
          source: "iana",
          extensions: ["org"]
        },
        "application/vnd.lotus-screencam": {
          source: "iana",
          extensions: ["scm"]
        },
        "application/vnd.lotus-wordpro": {
          source: "iana",
          extensions: ["lwp"]
        },
        "application/vnd.macports.portpkg": {
          source: "iana",
          extensions: ["portpkg"]
        },
        "application/vnd.mapbox-vector-tile": {
          source: "iana",
          extensions: ["mvt"]
        },
        "application/vnd.marlin.drm.actiontoken+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.marlin.drm.conftoken+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.marlin.drm.license+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.marlin.drm.mdcf": {
          source: "iana"
        },
        "application/vnd.mason+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.maxar.archive.3tz+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.maxmind.maxmind-db": {
          source: "iana"
        },
        "application/vnd.mcd": {
          source: "iana",
          extensions: ["mcd"]
        },
        "application/vnd.medcalcdata": {
          source: "iana",
          extensions: ["mc1"]
        },
        "application/vnd.mediastation.cdkey": {
          source: "iana",
          extensions: ["cdkey"]
        },
        "application/vnd.meridian-slingshot": {
          source: "iana"
        },
        "application/vnd.mfer": {
          source: "iana",
          extensions: ["mwf"]
        },
        "application/vnd.mfmp": {
          source: "iana",
          extensions: ["mfm"]
        },
        "application/vnd.micro+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.micrografx.flo": {
          source: "iana",
          extensions: ["flo"]
        },
        "application/vnd.micrografx.igx": {
          source: "iana",
          extensions: ["igx"]
        },
        "application/vnd.microsoft.portable-executable": {
          source: "iana"
        },
        "application/vnd.microsoft.windows.thumbnail-cache": {
          source: "iana"
        },
        "application/vnd.miele+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.mif": {
          source: "iana",
          extensions: ["mif"]
        },
        "application/vnd.minisoft-hp3000-save": {
          source: "iana"
        },
        "application/vnd.mitsubishi.misty-guard.trustweb": {
          source: "iana"
        },
        "application/vnd.mobius.daf": {
          source: "iana",
          extensions: ["daf"]
        },
        "application/vnd.mobius.dis": {
          source: "iana",
          extensions: ["dis"]
        },
        "application/vnd.mobius.mbk": {
          source: "iana",
          extensions: ["mbk"]
        },
        "application/vnd.mobius.mqy": {
          source: "iana",
          extensions: ["mqy"]
        },
        "application/vnd.mobius.msl": {
          source: "iana",
          extensions: ["msl"]
        },
        "application/vnd.mobius.plc": {
          source: "iana",
          extensions: ["plc"]
        },
        "application/vnd.mobius.txf": {
          source: "iana",
          extensions: ["txf"]
        },
        "application/vnd.mophun.application": {
          source: "iana",
          extensions: ["mpn"]
        },
        "application/vnd.mophun.certificate": {
          source: "iana",
          extensions: ["mpc"]
        },
        "application/vnd.motorola.flexsuite": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.adsi": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.fis": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.gotap": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.kmr": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.ttc": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.wem": {
          source: "iana"
        },
        "application/vnd.motorola.iprm": {
          source: "iana"
        },
        "application/vnd.mozilla.xul+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xul"]
        },
        "application/vnd.ms-3mfdocument": {
          source: "iana"
        },
        "application/vnd.ms-artgalry": {
          source: "iana",
          extensions: ["cil"]
        },
        "application/vnd.ms-asf": {
          source: "iana"
        },
        "application/vnd.ms-cab-compressed": {
          source: "iana",
          extensions: ["cab"]
        },
        "application/vnd.ms-color.iccprofile": {
          source: "apache"
        },
        "application/vnd.ms-excel": {
          source: "iana",
          compressible: false,
          extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
        },
        "application/vnd.ms-excel.addin.macroenabled.12": {
          source: "iana",
          extensions: ["xlam"]
        },
        "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
          source: "iana",
          extensions: ["xlsb"]
        },
        "application/vnd.ms-excel.sheet.macroenabled.12": {
          source: "iana",
          extensions: ["xlsm"]
        },
        "application/vnd.ms-excel.template.macroenabled.12": {
          source: "iana",
          extensions: ["xltm"]
        },
        "application/vnd.ms-fontobject": {
          source: "iana",
          compressible: true,
          extensions: ["eot"]
        },
        "application/vnd.ms-htmlhelp": {
          source: "iana",
          extensions: ["chm"]
        },
        "application/vnd.ms-ims": {
          source: "iana",
          extensions: ["ims"]
        },
        "application/vnd.ms-lrm": {
          source: "iana",
          extensions: ["lrm"]
        },
        "application/vnd.ms-office.activex+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ms-officetheme": {
          source: "iana",
          extensions: ["thmx"]
        },
        "application/vnd.ms-opentype": {
          source: "apache",
          compressible: true
        },
        "application/vnd.ms-outlook": {
          compressible: false,
          extensions: ["msg"]
        },
        "application/vnd.ms-package.obfuscated-opentype": {
          source: "apache"
        },
        "application/vnd.ms-pki.seccat": {
          source: "apache",
          extensions: ["cat"]
        },
        "application/vnd.ms-pki.stl": {
          source: "apache",
          extensions: ["stl"]
        },
        "application/vnd.ms-playready.initiator+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ms-powerpoint": {
          source: "iana",
          compressible: false,
          extensions: ["ppt", "pps", "pot"]
        },
        "application/vnd.ms-powerpoint.addin.macroenabled.12": {
          source: "iana",
          extensions: ["ppam"]
        },
        "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
          source: "iana",
          extensions: ["pptm"]
        },
        "application/vnd.ms-powerpoint.slide.macroenabled.12": {
          source: "iana",
          extensions: ["sldm"]
        },
        "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
          source: "iana",
          extensions: ["ppsm"]
        },
        "application/vnd.ms-powerpoint.template.macroenabled.12": {
          source: "iana",
          extensions: ["potm"]
        },
        "application/vnd.ms-printdevicecapabilities+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ms-printing.printticket+xml": {
          source: "apache",
          compressible: true
        },
        "application/vnd.ms-printschematicket+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ms-project": {
          source: "iana",
          extensions: ["mpp", "mpt"]
        },
        "application/vnd.ms-tnef": {
          source: "iana"
        },
        "application/vnd.ms-windows.devicepairing": {
          source: "iana"
        },
        "application/vnd.ms-windows.nwprinting.oob": {
          source: "iana"
        },
        "application/vnd.ms-windows.printerpairing": {
          source: "iana"
        },
        "application/vnd.ms-windows.wsd.oob": {
          source: "iana"
        },
        "application/vnd.ms-wmdrm.lic-chlg-req": {
          source: "iana"
        },
        "application/vnd.ms-wmdrm.lic-resp": {
          source: "iana"
        },
        "application/vnd.ms-wmdrm.meter-chlg-req": {
          source: "iana"
        },
        "application/vnd.ms-wmdrm.meter-resp": {
          source: "iana"
        },
        "application/vnd.ms-word.document.macroenabled.12": {
          source: "iana",
          extensions: ["docm"]
        },
        "application/vnd.ms-word.template.macroenabled.12": {
          source: "iana",
          extensions: ["dotm"]
        },
        "application/vnd.ms-works": {
          source: "iana",
          extensions: ["wps", "wks", "wcm", "wdb"]
        },
        "application/vnd.ms-wpl": {
          source: "iana",
          extensions: ["wpl"]
        },
        "application/vnd.ms-xpsdocument": {
          source: "iana",
          compressible: false,
          extensions: ["xps"]
        },
        "application/vnd.msa-disk-image": {
          source: "iana"
        },
        "application/vnd.mseq": {
          source: "iana",
          extensions: ["mseq"]
        },
        "application/vnd.msign": {
          source: "iana"
        },
        "application/vnd.multiad.creator": {
          source: "iana"
        },
        "application/vnd.multiad.creator.cif": {
          source: "iana"
        },
        "application/vnd.music-niff": {
          source: "iana"
        },
        "application/vnd.musician": {
          source: "iana",
          extensions: ["mus"]
        },
        "application/vnd.muvee.style": {
          source: "iana",
          extensions: ["msty"]
        },
        "application/vnd.mynfc": {
          source: "iana",
          extensions: ["taglet"]
        },
        "application/vnd.nacamar.ybrid+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ncd.control": {
          source: "iana"
        },
        "application/vnd.ncd.reference": {
          source: "iana"
        },
        "application/vnd.nearst.inv+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nebumind.line": {
          source: "iana"
        },
        "application/vnd.nervana": {
          source: "iana"
        },
        "application/vnd.netfpx": {
          source: "iana"
        },
        "application/vnd.neurolanguage.nlu": {
          source: "iana",
          extensions: ["nlu"]
        },
        "application/vnd.nimn": {
          source: "iana"
        },
        "application/vnd.nintendo.nitro.rom": {
          source: "iana"
        },
        "application/vnd.nintendo.snes.rom": {
          source: "iana"
        },
        "application/vnd.nitf": {
          source: "iana",
          extensions: ["ntf", "nitf"]
        },
        "application/vnd.noblenet-directory": {
          source: "iana",
          extensions: ["nnd"]
        },
        "application/vnd.noblenet-sealer": {
          source: "iana",
          extensions: ["nns"]
        },
        "application/vnd.noblenet-web": {
          source: "iana",
          extensions: ["nnw"]
        },
        "application/vnd.nokia.catalogs": {
          source: "iana"
        },
        "application/vnd.nokia.conml+wbxml": {
          source: "iana"
        },
        "application/vnd.nokia.conml+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nokia.iptv.config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nokia.isds-radio-presets": {
          source: "iana"
        },
        "application/vnd.nokia.landmark+wbxml": {
          source: "iana"
        },
        "application/vnd.nokia.landmark+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nokia.landmarkcollection+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nokia.n-gage.ac+xml": {
          source: "iana",
          compressible: true,
          extensions: ["ac"]
        },
        "application/vnd.nokia.n-gage.data": {
          source: "iana",
          extensions: ["ngdat"]
        },
        "application/vnd.nokia.n-gage.symbian.install": {
          source: "iana",
          extensions: ["n-gage"]
        },
        "application/vnd.nokia.ncd": {
          source: "iana"
        },
        "application/vnd.nokia.pcd+wbxml": {
          source: "iana"
        },
        "application/vnd.nokia.pcd+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nokia.radio-preset": {
          source: "iana",
          extensions: ["rpst"]
        },
        "application/vnd.nokia.radio-presets": {
          source: "iana",
          extensions: ["rpss"]
        },
        "application/vnd.novadigm.edm": {
          source: "iana",
          extensions: ["edm"]
        },
        "application/vnd.novadigm.edx": {
          source: "iana",
          extensions: ["edx"]
        },
        "application/vnd.novadigm.ext": {
          source: "iana",
          extensions: ["ext"]
        },
        "application/vnd.ntt-local.content-share": {
          source: "iana"
        },
        "application/vnd.ntt-local.file-transfer": {
          source: "iana"
        },
        "application/vnd.ntt-local.ogw_remote-access": {
          source: "iana"
        },
        "application/vnd.ntt-local.sip-ta_remote": {
          source: "iana"
        },
        "application/vnd.ntt-local.sip-ta_tcp_stream": {
          source: "iana"
        },
        "application/vnd.oasis.opendocument.chart": {
          source: "iana",
          extensions: ["odc"]
        },
        "application/vnd.oasis.opendocument.chart-template": {
          source: "iana",
          extensions: ["otc"]
        },
        "application/vnd.oasis.opendocument.database": {
          source: "iana",
          extensions: ["odb"]
        },
        "application/vnd.oasis.opendocument.formula": {
          source: "iana",
          extensions: ["odf"]
        },
        "application/vnd.oasis.opendocument.formula-template": {
          source: "iana",
          extensions: ["odft"]
        },
        "application/vnd.oasis.opendocument.graphics": {
          source: "iana",
          compressible: false,
          extensions: ["odg"]
        },
        "application/vnd.oasis.opendocument.graphics-template": {
          source: "iana",
          extensions: ["otg"]
        },
        "application/vnd.oasis.opendocument.image": {
          source: "iana",
          extensions: ["odi"]
        },
        "application/vnd.oasis.opendocument.image-template": {
          source: "iana",
          extensions: ["oti"]
        },
        "application/vnd.oasis.opendocument.presentation": {
          source: "iana",
          compressible: false,
          extensions: ["odp"]
        },
        "application/vnd.oasis.opendocument.presentation-template": {
          source: "iana",
          extensions: ["otp"]
        },
        "application/vnd.oasis.opendocument.spreadsheet": {
          source: "iana",
          compressible: false,
          extensions: ["ods"]
        },
        "application/vnd.oasis.opendocument.spreadsheet-template": {
          source: "iana",
          extensions: ["ots"]
        },
        "application/vnd.oasis.opendocument.text": {
          source: "iana",
          compressible: false,
          extensions: ["odt"]
        },
        "application/vnd.oasis.opendocument.text-master": {
          source: "iana",
          extensions: ["odm"]
        },
        "application/vnd.oasis.opendocument.text-template": {
          source: "iana",
          extensions: ["ott"]
        },
        "application/vnd.oasis.opendocument.text-web": {
          source: "iana",
          extensions: ["oth"]
        },
        "application/vnd.obn": {
          source: "iana"
        },
        "application/vnd.ocf+cbor": {
          source: "iana"
        },
        "application/vnd.oci.image.manifest.v1+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oftn.l10n+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.contentaccessdownload+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.contentaccessstreaming+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.cspg-hexbinary": {
          source: "iana"
        },
        "application/vnd.oipf.dae.svg+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.dae.xhtml+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.mippvcontrolmessage+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.pae.gem": {
          source: "iana"
        },
        "application/vnd.oipf.spdiscovery+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.spdlist+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.ueprofile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.userprofile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.olpc-sugar": {
          source: "iana",
          extensions: ["xo"]
        },
        "application/vnd.oma-scws-config": {
          source: "iana"
        },
        "application/vnd.oma-scws-http-request": {
          source: "iana"
        },
        "application/vnd.oma-scws-http-response": {
          source: "iana"
        },
        "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.drm-trigger+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.imd+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.ltkm": {
          source: "iana"
        },
        "application/vnd.oma.bcast.notification+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.provisioningtrigger": {
          source: "iana"
        },
        "application/vnd.oma.bcast.sgboot": {
          source: "iana"
        },
        "application/vnd.oma.bcast.sgdd+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.sgdu": {
          source: "iana"
        },
        "application/vnd.oma.bcast.simple-symbol-container": {
          source: "iana"
        },
        "application/vnd.oma.bcast.smartcard-trigger+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.sprov+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.stkm": {
          source: "iana"
        },
        "application/vnd.oma.cab-address-book+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.cab-feature-handler+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.cab-pcc+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.cab-subs-invite+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.cab-user-prefs+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.dcd": {
          source: "iana"
        },
        "application/vnd.oma.dcdc": {
          source: "iana"
        },
        "application/vnd.oma.dd2+xml": {
          source: "iana",
          compressible: true,
          extensions: ["dd2"]
        },
        "application/vnd.oma.drm.risd+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.group-usage-list+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.lwm2m+cbor": {
          source: "iana"
        },
        "application/vnd.oma.lwm2m+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.lwm2m+tlv": {
          source: "iana"
        },
        "application/vnd.oma.pal+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.poc.detailed-progress-report+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.poc.final-report+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.poc.groups+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.poc.invocation-descriptor+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.poc.optimized-progress-report+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.push": {
          source: "iana"
        },
        "application/vnd.oma.scidm.messages+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.xcap-directory+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.omads-email+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.omads-file+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.omads-folder+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.omaloc-supl-init": {
          source: "iana"
        },
        "application/vnd.onepager": {
          source: "iana"
        },
        "application/vnd.onepagertamp": {
          source: "iana"
        },
        "application/vnd.onepagertamx": {
          source: "iana"
        },
        "application/vnd.onepagertat": {
          source: "iana"
        },
        "application/vnd.onepagertatp": {
          source: "iana"
        },
        "application/vnd.onepagertatx": {
          source: "iana"
        },
        "application/vnd.openblox.game+xml": {
          source: "iana",
          compressible: true,
          extensions: ["obgx"]
        },
        "application/vnd.openblox.game-binary": {
          source: "iana"
        },
        "application/vnd.openeye.oeb": {
          source: "iana"
        },
        "application/vnd.openofficeorg.extension": {
          source: "apache",
          extensions: ["oxt"]
        },
        "application/vnd.openstreetmap.data+xml": {
          source: "iana",
          compressible: true,
          extensions: ["osm"]
        },
        "application/vnd.opentimestamps.ots": {
          source: "iana"
        },
        "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawing+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
          source: "iana",
          compressible: false,
          extensions: ["pptx"]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slide": {
          source: "iana",
          extensions: ["sldx"]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
          source: "iana",
          extensions: ["ppsx"]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.template": {
          source: "iana",
          extensions: ["potx"]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
          source: "iana",
          compressible: false,
          extensions: ["xlsx"]
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
          source: "iana",
          extensions: ["xltx"]
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.theme+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.vmldrawing": {
          source: "iana"
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
          source: "iana",
          compressible: false,
          extensions: ["docx"]
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
          source: "iana",
          extensions: ["dotx"]
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-package.core-properties+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-package.relationships+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oracle.resource+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.orange.indata": {
          source: "iana"
        },
        "application/vnd.osa.netdeploy": {
          source: "iana"
        },
        "application/vnd.osgeo.mapguide.package": {
          source: "iana",
          extensions: ["mgp"]
        },
        "application/vnd.osgi.bundle": {
          source: "iana"
        },
        "application/vnd.osgi.dp": {
          source: "iana",
          extensions: ["dp"]
        },
        "application/vnd.osgi.subsystem": {
          source: "iana",
          extensions: ["esa"]
        },
        "application/vnd.otps.ct-kip+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oxli.countgraph": {
          source: "iana"
        },
        "application/vnd.pagerduty+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.palm": {
          source: "iana",
          extensions: ["pdb", "pqa", "oprc"]
        },
        "application/vnd.panoply": {
          source: "iana"
        },
        "application/vnd.paos.xml": {
          source: "iana"
        },
        "application/vnd.patentdive": {
          source: "iana"
        },
        "application/vnd.patientecommsdoc": {
          source: "iana"
        },
        "application/vnd.pawaafile": {
          source: "iana",
          extensions: ["paw"]
        },
        "application/vnd.pcos": {
          source: "iana"
        },
        "application/vnd.pg.format": {
          source: "iana",
          extensions: ["str"]
        },
        "application/vnd.pg.osasli": {
          source: "iana",
          extensions: ["ei6"]
        },
        "application/vnd.piaccess.application-licence": {
          source: "iana"
        },
        "application/vnd.picsel": {
          source: "iana",
          extensions: ["efif"]
        },
        "application/vnd.pmi.widget": {
          source: "iana",
          extensions: ["wg"]
        },
        "application/vnd.poc.group-advertisement+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.pocketlearn": {
          source: "iana",
          extensions: ["plf"]
        },
        "application/vnd.powerbuilder6": {
          source: "iana",
          extensions: ["pbd"]
        },
        "application/vnd.powerbuilder6-s": {
          source: "iana"
        },
        "application/vnd.powerbuilder7": {
          source: "iana"
        },
        "application/vnd.powerbuilder7-s": {
          source: "iana"
        },
        "application/vnd.powerbuilder75": {
          source: "iana"
        },
        "application/vnd.powerbuilder75-s": {
          source: "iana"
        },
        "application/vnd.preminet": {
          source: "iana"
        },
        "application/vnd.previewsystems.box": {
          source: "iana",
          extensions: ["box"]
        },
        "application/vnd.proteus.magazine": {
          source: "iana",
          extensions: ["mgz"]
        },
        "application/vnd.psfs": {
          source: "iana"
        },
        "application/vnd.publishare-delta-tree": {
          source: "iana",
          extensions: ["qps"]
        },
        "application/vnd.pvi.ptid1": {
          source: "iana",
          extensions: ["ptid"]
        },
        "application/vnd.pwg-multiplexed": {
          source: "iana"
        },
        "application/vnd.pwg-xhtml-print+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.qualcomm.brew-app-res": {
          source: "iana"
        },
        "application/vnd.quarantainenet": {
          source: "iana"
        },
        "application/vnd.quark.quarkxpress": {
          source: "iana",
          extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
        },
        "application/vnd.quobject-quoxdocument": {
          source: "iana"
        },
        "application/vnd.radisys.moml+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-audit+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-audit-conf+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-audit-conn+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-audit-dialog+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-audit-stream+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-conf+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-base+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-fax-detect+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-group+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-speech+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-transform+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.rainstor.data": {
          source: "iana"
        },
        "application/vnd.rapid": {
          source: "iana"
        },
        "application/vnd.rar": {
          source: "iana",
          extensions: ["rar"]
        },
        "application/vnd.realvnc.bed": {
          source: "iana",
          extensions: ["bed"]
        },
        "application/vnd.recordare.musicxml": {
          source: "iana",
          extensions: ["mxl"]
        },
        "application/vnd.recordare.musicxml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["musicxml"]
        },
        "application/vnd.renlearn.rlprint": {
          source: "iana"
        },
        "application/vnd.resilient.logic": {
          source: "iana"
        },
        "application/vnd.restful+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.rig.cryptonote": {
          source: "iana",
          extensions: ["cryptonote"]
        },
        "application/vnd.rim.cod": {
          source: "apache",
          extensions: ["cod"]
        },
        "application/vnd.rn-realmedia": {
          source: "apache",
          extensions: ["rm"]
        },
        "application/vnd.rn-realmedia-vbr": {
          source: "apache",
          extensions: ["rmvb"]
        },
        "application/vnd.route66.link66+xml": {
          source: "iana",
          compressible: true,
          extensions: ["link66"]
        },
        "application/vnd.rs-274x": {
          source: "iana"
        },
        "application/vnd.ruckus.download": {
          source: "iana"
        },
        "application/vnd.s3sms": {
          source: "iana"
        },
        "application/vnd.sailingtracker.track": {
          source: "iana",
          extensions: ["st"]
        },
        "application/vnd.sar": {
          source: "iana"
        },
        "application/vnd.sbm.cid": {
          source: "iana"
        },
        "application/vnd.sbm.mid2": {
          source: "iana"
        },
        "application/vnd.scribus": {
          source: "iana"
        },
        "application/vnd.sealed.3df": {
          source: "iana"
        },
        "application/vnd.sealed.csf": {
          source: "iana"
        },
        "application/vnd.sealed.doc": {
          source: "iana"
        },
        "application/vnd.sealed.eml": {
          source: "iana"
        },
        "application/vnd.sealed.mht": {
          source: "iana"
        },
        "application/vnd.sealed.net": {
          source: "iana"
        },
        "application/vnd.sealed.ppt": {
          source: "iana"
        },
        "application/vnd.sealed.tiff": {
          source: "iana"
        },
        "application/vnd.sealed.xls": {
          source: "iana"
        },
        "application/vnd.sealedmedia.softseal.html": {
          source: "iana"
        },
        "application/vnd.sealedmedia.softseal.pdf": {
          source: "iana"
        },
        "application/vnd.seemail": {
          source: "iana",
          extensions: ["see"]
        },
        "application/vnd.seis+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.sema": {
          source: "iana",
          extensions: ["sema"]
        },
        "application/vnd.semd": {
          source: "iana",
          extensions: ["semd"]
        },
        "application/vnd.semf": {
          source: "iana",
          extensions: ["semf"]
        },
        "application/vnd.shade-save-file": {
          source: "iana"
        },
        "application/vnd.shana.informed.formdata": {
          source: "iana",
          extensions: ["ifm"]
        },
        "application/vnd.shana.informed.formtemplate": {
          source: "iana",
          extensions: ["itp"]
        },
        "application/vnd.shana.informed.interchange": {
          source: "iana",
          extensions: ["iif"]
        },
        "application/vnd.shana.informed.package": {
          source: "iana",
          extensions: ["ipk"]
        },
        "application/vnd.shootproof+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.shopkick+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.shp": {
          source: "iana"
        },
        "application/vnd.shx": {
          source: "iana"
        },
        "application/vnd.sigrok.session": {
          source: "iana"
        },
        "application/vnd.simtech-mindmapper": {
          source: "iana",
          extensions: ["twd", "twds"]
        },
        "application/vnd.siren+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.smaf": {
          source: "iana",
          extensions: ["mmf"]
        },
        "application/vnd.smart.notebook": {
          source: "iana"
        },
        "application/vnd.smart.teacher": {
          source: "iana",
          extensions: ["teacher"]
        },
        "application/vnd.snesdev-page-table": {
          source: "iana"
        },
        "application/vnd.software602.filler.form+xml": {
          source: "iana",
          compressible: true,
          extensions: ["fo"]
        },
        "application/vnd.software602.filler.form-xml-zip": {
          source: "iana"
        },
        "application/vnd.solent.sdkm+xml": {
          source: "iana",
          compressible: true,
          extensions: ["sdkm", "sdkd"]
        },
        "application/vnd.spotfire.dxp": {
          source: "iana",
          extensions: ["dxp"]
        },
        "application/vnd.spotfire.sfs": {
          source: "iana",
          extensions: ["sfs"]
        },
        "application/vnd.sqlite3": {
          source: "iana"
        },
        "application/vnd.sss-cod": {
          source: "iana"
        },
        "application/vnd.sss-dtf": {
          source: "iana"
        },
        "application/vnd.sss-ntf": {
          source: "iana"
        },
        "application/vnd.stardivision.calc": {
          source: "apache",
          extensions: ["sdc"]
        },
        "application/vnd.stardivision.draw": {
          source: "apache",
          extensions: ["sda"]
        },
        "application/vnd.stardivision.impress": {
          source: "apache",
          extensions: ["sdd"]
        },
        "application/vnd.stardivision.math": {
          source: "apache",
          extensions: ["smf"]
        },
        "application/vnd.stardivision.writer": {
          source: "apache",
          extensions: ["sdw", "vor"]
        },
        "application/vnd.stardivision.writer-global": {
          source: "apache",
          extensions: ["sgl"]
        },
        "application/vnd.stepmania.package": {
          source: "iana",
          extensions: ["smzip"]
        },
        "application/vnd.stepmania.stepchart": {
          source: "iana",
          extensions: ["sm"]
        },
        "application/vnd.street-stream": {
          source: "iana"
        },
        "application/vnd.sun.wadl+xml": {
          source: "iana",
          compressible: true,
          extensions: ["wadl"]
        },
        "application/vnd.sun.xml.calc": {
          source: "apache",
          extensions: ["sxc"]
        },
        "application/vnd.sun.xml.calc.template": {
          source: "apache",
          extensions: ["stc"]
        },
        "application/vnd.sun.xml.draw": {
          source: "apache",
          extensions: ["sxd"]
        },
        "application/vnd.sun.xml.draw.template": {
          source: "apache",
          extensions: ["std"]
        },
        "application/vnd.sun.xml.impress": {
          source: "apache",
          extensions: ["sxi"]
        },
        "application/vnd.sun.xml.impress.template": {
          source: "apache",
          extensions: ["sti"]
        },
        "application/vnd.sun.xml.math": {
          source: "apache",
          extensions: ["sxm"]
        },
        "application/vnd.sun.xml.writer": {
          source: "apache",
          extensions: ["sxw"]
        },
        "application/vnd.sun.xml.writer.global": {
          source: "apache",
          extensions: ["sxg"]
        },
        "application/vnd.sun.xml.writer.template": {
          source: "apache",
          extensions: ["stw"]
        },
        "application/vnd.sus-calendar": {
          source: "iana",
          extensions: ["sus", "susp"]
        },
        "application/vnd.svd": {
          source: "iana",
          extensions: ["svd"]
        },
        "application/vnd.swiftview-ics": {
          source: "iana"
        },
        "application/vnd.sycle+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.syft+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.symbian.install": {
          source: "apache",
          extensions: ["sis", "sisx"]
        },
        "application/vnd.syncml+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["xsm"]
        },
        "application/vnd.syncml.dm+wbxml": {
          source: "iana",
          charset: "UTF-8",
          extensions: ["bdm"]
        },
        "application/vnd.syncml.dm+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["xdm"]
        },
        "application/vnd.syncml.dm.notification": {
          source: "iana"
        },
        "application/vnd.syncml.dmddf+wbxml": {
          source: "iana"
        },
        "application/vnd.syncml.dmddf+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["ddf"]
        },
        "application/vnd.syncml.dmtnds+wbxml": {
          source: "iana"
        },
        "application/vnd.syncml.dmtnds+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.syncml.ds.notification": {
          source: "iana"
        },
        "application/vnd.tableschema+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.tao.intent-module-archive": {
          source: "iana",
          extensions: ["tao"]
        },
        "application/vnd.tcpdump.pcap": {
          source: "iana",
          extensions: ["pcap", "cap", "dmp"]
        },
        "application/vnd.think-cell.ppttc+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.tmd.mediaflex.api+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.tml": {
          source: "iana"
        },
        "application/vnd.tmobile-livetv": {
          source: "iana",
          extensions: ["tmo"]
        },
        "application/vnd.tri.onesource": {
          source: "iana"
        },
        "application/vnd.trid.tpt": {
          source: "iana",
          extensions: ["tpt"]
        },
        "application/vnd.triscape.mxs": {
          source: "iana",
          extensions: ["mxs"]
        },
        "application/vnd.trueapp": {
          source: "iana",
          extensions: ["tra"]
        },
        "application/vnd.truedoc": {
          source: "iana"
        },
        "application/vnd.ubisoft.webplayer": {
          source: "iana"
        },
        "application/vnd.ufdl": {
          source: "iana",
          extensions: ["ufd", "ufdl"]
        },
        "application/vnd.uiq.theme": {
          source: "iana",
          extensions: ["utz"]
        },
        "application/vnd.umajin": {
          source: "iana",
          extensions: ["umj"]
        },
        "application/vnd.unity": {
          source: "iana",
          extensions: ["unityweb"]
        },
        "application/vnd.uoml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["uoml"]
        },
        "application/vnd.uplanet.alert": {
          source: "iana"
        },
        "application/vnd.uplanet.alert-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.bearer-choice": {
          source: "iana"
        },
        "application/vnd.uplanet.bearer-choice-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.cacheop": {
          source: "iana"
        },
        "application/vnd.uplanet.cacheop-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.channel": {
          source: "iana"
        },
        "application/vnd.uplanet.channel-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.list": {
          source: "iana"
        },
        "application/vnd.uplanet.list-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.listcmd": {
          source: "iana"
        },
        "application/vnd.uplanet.listcmd-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.signal": {
          source: "iana"
        },
        "application/vnd.uri-map": {
          source: "iana"
        },
        "application/vnd.valve.source.material": {
          source: "iana"
        },
        "application/vnd.vcx": {
          source: "iana",
          extensions: ["vcx"]
        },
        "application/vnd.vd-study": {
          source: "iana"
        },
        "application/vnd.vectorworks": {
          source: "iana"
        },
        "application/vnd.vel+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.verimatrix.vcas": {
          source: "iana"
        },
        "application/vnd.veritone.aion+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.veryant.thin": {
          source: "iana"
        },
        "application/vnd.ves.encrypted": {
          source: "iana"
        },
        "application/vnd.vidsoft.vidconference": {
          source: "iana"
        },
        "application/vnd.visio": {
          source: "iana",
          extensions: ["vsd", "vst", "vss", "vsw"]
        },
        "application/vnd.visionary": {
          source: "iana",
          extensions: ["vis"]
        },
        "application/vnd.vividence.scriptfile": {
          source: "iana"
        },
        "application/vnd.vsf": {
          source: "iana",
          extensions: ["vsf"]
        },
        "application/vnd.wap.sic": {
          source: "iana"
        },
        "application/vnd.wap.slc": {
          source: "iana"
        },
        "application/vnd.wap.wbxml": {
          source: "iana",
          charset: "UTF-8",
          extensions: ["wbxml"]
        },
        "application/vnd.wap.wmlc": {
          source: "iana",
          extensions: ["wmlc"]
        },
        "application/vnd.wap.wmlscriptc": {
          source: "iana",
          extensions: ["wmlsc"]
        },
        "application/vnd.webturbo": {
          source: "iana",
          extensions: ["wtb"]
        },
        "application/vnd.wfa.dpp": {
          source: "iana"
        },
        "application/vnd.wfa.p2p": {
          source: "iana"
        },
        "application/vnd.wfa.wsc": {
          source: "iana"
        },
        "application/vnd.windows.devicepairing": {
          source: "iana"
        },
        "application/vnd.wmc": {
          source: "iana"
        },
        "application/vnd.wmf.bootstrap": {
          source: "iana"
        },
        "application/vnd.wolfram.mathematica": {
          source: "iana"
        },
        "application/vnd.wolfram.mathematica.package": {
          source: "iana"
        },
        "application/vnd.wolfram.player": {
          source: "iana",
          extensions: ["nbp"]
        },
        "application/vnd.wordperfect": {
          source: "iana",
          extensions: ["wpd"]
        },
        "application/vnd.wqd": {
          source: "iana",
          extensions: ["wqd"]
        },
        "application/vnd.wrq-hp3000-labelled": {
          source: "iana"
        },
        "application/vnd.wt.stf": {
          source: "iana",
          extensions: ["stf"]
        },
        "application/vnd.wv.csp+wbxml": {
          source: "iana"
        },
        "application/vnd.wv.csp+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.wv.ssp+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.xacml+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.xara": {
          source: "iana",
          extensions: ["xar"]
        },
        "application/vnd.xfdl": {
          source: "iana",
          extensions: ["xfdl"]
        },
        "application/vnd.xfdl.webform": {
          source: "iana"
        },
        "application/vnd.xmi+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.xmpie.cpkg": {
          source: "iana"
        },
        "application/vnd.xmpie.dpkg": {
          source: "iana"
        },
        "application/vnd.xmpie.plan": {
          source: "iana"
        },
        "application/vnd.xmpie.ppkg": {
          source: "iana"
        },
        "application/vnd.xmpie.xlim": {
          source: "iana"
        },
        "application/vnd.yamaha.hv-dic": {
          source: "iana",
          extensions: ["hvd"]
        },
        "application/vnd.yamaha.hv-script": {
          source: "iana",
          extensions: ["hvs"]
        },
        "application/vnd.yamaha.hv-voice": {
          source: "iana",
          extensions: ["hvp"]
        },
        "application/vnd.yamaha.openscoreformat": {
          source: "iana",
          extensions: ["osf"]
        },
        "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
          source: "iana",
          compressible: true,
          extensions: ["osfpvg"]
        },
        "application/vnd.yamaha.remote-setup": {
          source: "iana"
        },
        "application/vnd.yamaha.smaf-audio": {
          source: "iana",
          extensions: ["saf"]
        },
        "application/vnd.yamaha.smaf-phrase": {
          source: "iana",
          extensions: ["spf"]
        },
        "application/vnd.yamaha.through-ngn": {
          source: "iana"
        },
        "application/vnd.yamaha.tunnel-udpencap": {
          source: "iana"
        },
        "application/vnd.yaoweme": {
          source: "iana"
        },
        "application/vnd.yellowriver-custom-menu": {
          source: "iana",
          extensions: ["cmp"]
        },
        "application/vnd.youtube.yt": {
          source: "iana"
        },
        "application/vnd.zul": {
          source: "iana",
          extensions: ["zir", "zirz"]
        },
        "application/vnd.zzazz.deck+xml": {
          source: "iana",
          compressible: true,
          extensions: ["zaz"]
        },
        "application/voicexml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["vxml"]
        },
        "application/voucher-cms+json": {
          source: "iana",
          compressible: true
        },
        "application/vq-rtcpxr": {
          source: "iana"
        },
        "application/wasm": {
          source: "iana",
          compressible: true,
          extensions: ["wasm"]
        },
        "application/watcherinfo+xml": {
          source: "iana",
          compressible: true,
          extensions: ["wif"]
        },
        "application/webpush-options+json": {
          source: "iana",
          compressible: true
        },
        "application/whoispp-query": {
          source: "iana"
        },
        "application/whoispp-response": {
          source: "iana"
        },
        "application/widget": {
          source: "iana",
          extensions: ["wgt"]
        },
        "application/winhlp": {
          source: "apache",
          extensions: ["hlp"]
        },
        "application/wita": {
          source: "iana"
        },
        "application/wordperfect5.1": {
          source: "iana"
        },
        "application/wsdl+xml": {
          source: "iana",
          compressible: true,
          extensions: ["wsdl"]
        },
        "application/wspolicy+xml": {
          source: "iana",
          compressible: true,
          extensions: ["wspolicy"]
        },
        "application/x-7z-compressed": {
          source: "apache",
          compressible: false,
          extensions: ["7z"]
        },
        "application/x-abiword": {
          source: "apache",
          extensions: ["abw"]
        },
        "application/x-ace-compressed": {
          source: "apache",
          extensions: ["ace"]
        },
        "application/x-amf": {
          source: "apache"
        },
        "application/x-apple-diskimage": {
          source: "apache",
          extensions: ["dmg"]
        },
        "application/x-arj": {
          compressible: false,
          extensions: ["arj"]
        },
        "application/x-authorware-bin": {
          source: "apache",
          extensions: ["aab", "x32", "u32", "vox"]
        },
        "application/x-authorware-map": {
          source: "apache",
          extensions: ["aam"]
        },
        "application/x-authorware-seg": {
          source: "apache",
          extensions: ["aas"]
        },
        "application/x-bcpio": {
          source: "apache",
          extensions: ["bcpio"]
        },
        "application/x-bdoc": {
          compressible: false,
          extensions: ["bdoc"]
        },
        "application/x-bittorrent": {
          source: "apache",
          extensions: ["torrent"]
        },
        "application/x-blorb": {
          source: "apache",
          extensions: ["blb", "blorb"]
        },
        "application/x-bzip": {
          source: "apache",
          compressible: false,
          extensions: ["bz"]
        },
        "application/x-bzip2": {
          source: "apache",
          compressible: false,
          extensions: ["bz2", "boz"]
        },
        "application/x-cbr": {
          source: "apache",
          extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
        },
        "application/x-cdlink": {
          source: "apache",
          extensions: ["vcd"]
        },
        "application/x-cfs-compressed": {
          source: "apache",
          extensions: ["cfs"]
        },
        "application/x-chat": {
          source: "apache",
          extensions: ["chat"]
        },
        "application/x-chess-pgn": {
          source: "apache",
          extensions: ["pgn"]
        },
        "application/x-chrome-extension": {
          extensions: ["crx"]
        },
        "application/x-cocoa": {
          source: "nginx",
          extensions: ["cco"]
        },
        "application/x-compress": {
          source: "apache"
        },
        "application/x-conference": {
          source: "apache",
          extensions: ["nsc"]
        },
        "application/x-cpio": {
          source: "apache",
          extensions: ["cpio"]
        },
        "application/x-csh": {
          source: "apache",
          extensions: ["csh"]
        },
        "application/x-deb": {
          compressible: false
        },
        "application/x-debian-package": {
          source: "apache",
          extensions: ["deb", "udeb"]
        },
        "application/x-dgc-compressed": {
          source: "apache",
          extensions: ["dgc"]
        },
        "application/x-director": {
          source: "apache",
          extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
        },
        "application/x-doom": {
          source: "apache",
          extensions: ["wad"]
        },
        "application/x-dtbncx+xml": {
          source: "apache",
          compressible: true,
          extensions: ["ncx"]
        },
        "application/x-dtbook+xml": {
          source: "apache",
          compressible: true,
          extensions: ["dtb"]
        },
        "application/x-dtbresource+xml": {
          source: "apache",
          compressible: true,
          extensions: ["res"]
        },
        "application/x-dvi": {
          source: "apache",
          compressible: false,
          extensions: ["dvi"]
        },
        "application/x-envoy": {
          source: "apache",
          extensions: ["evy"]
        },
        "application/x-eva": {
          source: "apache",
          extensions: ["eva"]
        },
        "application/x-font-bdf": {
          source: "apache",
          extensions: ["bdf"]
        },
        "application/x-font-dos": {
          source: "apache"
        },
        "application/x-font-framemaker": {
          source: "apache"
        },
        "application/x-font-ghostscript": {
          source: "apache",
          extensions: ["gsf"]
        },
        "application/x-font-libgrx": {
          source: "apache"
        },
        "application/x-font-linux-psf": {
          source: "apache",
          extensions: ["psf"]
        },
        "application/x-font-pcf": {
          source: "apache",
          extensions: ["pcf"]
        },
        "application/x-font-snf": {
          source: "apache",
          extensions: ["snf"]
        },
        "application/x-font-speedo": {
          source: "apache"
        },
        "application/x-font-sunos-news": {
          source: "apache"
        },
        "application/x-font-type1": {
          source: "apache",
          extensions: ["pfa", "pfb", "pfm", "afm"]
        },
        "application/x-font-vfont": {
          source: "apache"
        },
        "application/x-freearc": {
          source: "apache",
          extensions: ["arc"]
        },
        "application/x-futuresplash": {
          source: "apache",
          extensions: ["spl"]
        },
        "application/x-gca-compressed": {
          source: "apache",
          extensions: ["gca"]
        },
        "application/x-glulx": {
          source: "apache",
          extensions: ["ulx"]
        },
        "application/x-gnumeric": {
          source: "apache",
          extensions: ["gnumeric"]
        },
        "application/x-gramps-xml": {
          source: "apache",
          extensions: ["gramps"]
        },
        "application/x-gtar": {
          source: "apache",
          extensions: ["gtar"]
        },
        "application/x-gzip": {
          source: "apache"
        },
        "application/x-hdf": {
          source: "apache",
          extensions: ["hdf"]
        },
        "application/x-httpd-php": {
          compressible: true,
          extensions: ["php"]
        },
        "application/x-install-instructions": {
          source: "apache",
          extensions: ["install"]
        },
        "application/x-iso9660-image": {
          source: "apache",
          extensions: ["iso"]
        },
        "application/x-iwork-keynote-sffkey": {
          extensions: ["key"]
        },
        "application/x-iwork-numbers-sffnumbers": {
          extensions: ["numbers"]
        },
        "application/x-iwork-pages-sffpages": {
          extensions: ["pages"]
        },
        "application/x-java-archive-diff": {
          source: "nginx",
          extensions: ["jardiff"]
        },
        "application/x-java-jnlp-file": {
          source: "apache",
          compressible: false,
          extensions: ["jnlp"]
        },
        "application/x-javascript": {
          compressible: true
        },
        "application/x-keepass2": {
          extensions: ["kdbx"]
        },
        "application/x-latex": {
          source: "apache",
          compressible: false,
          extensions: ["latex"]
        },
        "application/x-lua-bytecode": {
          extensions: ["luac"]
        },
        "application/x-lzh-compressed": {
          source: "apache",
          extensions: ["lzh", "lha"]
        },
        "application/x-makeself": {
          source: "nginx",
          extensions: ["run"]
        },
        "application/x-mie": {
          source: "apache",
          extensions: ["mie"]
        },
        "application/x-mobipocket-ebook": {
          source: "apache",
          extensions: ["prc", "mobi"]
        },
        "application/x-mpegurl": {
          compressible: false
        },
        "application/x-ms-application": {
          source: "apache",
          extensions: ["application"]
        },
        "application/x-ms-shortcut": {
          source: "apache",
          extensions: ["lnk"]
        },
        "application/x-ms-wmd": {
          source: "apache",
          extensions: ["wmd"]
        },
        "application/x-ms-wmz": {
          source: "apache",
          extensions: ["wmz"]
        },
        "application/x-ms-xbap": {
          source: "apache",
          extensions: ["xbap"]
        },
        "application/x-msaccess": {
          source: "apache",
          extensions: ["mdb"]
        },
        "application/x-msbinder": {
          source: "apache",
          extensions: ["obd"]
        },
        "application/x-mscardfile": {
          source: "apache",
          extensions: ["crd"]
        },
        "application/x-msclip": {
          source: "apache",
          extensions: ["clp"]
        },
        "application/x-msdos-program": {
          extensions: ["exe"]
        },
        "application/x-msdownload": {
          source: "apache",
          extensions: ["exe", "dll", "com", "bat", "msi"]
        },
        "application/x-msmediaview": {
          source: "apache",
          extensions: ["mvb", "m13", "m14"]
        },
        "application/x-msmetafile": {
          source: "apache",
          extensions: ["wmf", "wmz", "emf", "emz"]
        },
        "application/x-msmoney": {
          source: "apache",
          extensions: ["mny"]
        },
        "application/x-mspublisher": {
          source: "apache",
          extensions: ["pub"]
        },
        "application/x-msschedule": {
          source: "apache",
          extensions: ["scd"]
        },
        "application/x-msterminal": {
          source: "apache",
          extensions: ["trm"]
        },
        "application/x-mswrite": {
          source: "apache",
          extensions: ["wri"]
        },
        "application/x-netcdf": {
          source: "apache",
          extensions: ["nc", "cdf"]
        },
        "application/x-ns-proxy-autoconfig": {
          compressible: true,
          extensions: ["pac"]
        },
        "application/x-nzb": {
          source: "apache",
          extensions: ["nzb"]
        },
        "application/x-perl": {
          source: "nginx",
          extensions: ["pl", "pm"]
        },
        "application/x-pilot": {
          source: "nginx",
          extensions: ["prc", "pdb"]
        },
        "application/x-pkcs12": {
          source: "apache",
          compressible: false,
          extensions: ["p12", "pfx"]
        },
        "application/x-pkcs7-certificates": {
          source: "apache",
          extensions: ["p7b", "spc"]
        },
        "application/x-pkcs7-certreqresp": {
          source: "apache",
          extensions: ["p7r"]
        },
        "application/x-pki-message": {
          source: "iana"
        },
        "application/x-rar-compressed": {
          source: "apache",
          compressible: false,
          extensions: ["rar"]
        },
        "application/x-redhat-package-manager": {
          source: "nginx",
          extensions: ["rpm"]
        },
        "application/x-research-info-systems": {
          source: "apache",
          extensions: ["ris"]
        },
        "application/x-sea": {
          source: "nginx",
          extensions: ["sea"]
        },
        "application/x-sh": {
          source: "apache",
          compressible: true,
          extensions: ["sh"]
        },
        "application/x-shar": {
          source: "apache",
          extensions: ["shar"]
        },
        "application/x-shockwave-flash": {
          source: "apache",
          compressible: false,
          extensions: ["swf"]
        },
        "application/x-silverlight-app": {
          source: "apache",
          extensions: ["xap"]
        },
        "application/x-sql": {
          source: "apache",
          extensions: ["sql"]
        },
        "application/x-stuffit": {
          source: "apache",
          compressible: false,
          extensions: ["sit"]
        },
        "application/x-stuffitx": {
          source: "apache",
          extensions: ["sitx"]
        },
        "application/x-subrip": {
          source: "apache",
          extensions: ["srt"]
        },
        "application/x-sv4cpio": {
          source: "apache",
          extensions: ["sv4cpio"]
        },
        "application/x-sv4crc": {
          source: "apache",
          extensions: ["sv4crc"]
        },
        "application/x-t3vm-image": {
          source: "apache",
          extensions: ["t3"]
        },
        "application/x-tads": {
          source: "apache",
          extensions: ["gam"]
        },
        "application/x-tar": {
          source: "apache",
          compressible: true,
          extensions: ["tar"]
        },
        "application/x-tcl": {
          source: "apache",
          extensions: ["tcl", "tk"]
        },
        "application/x-tex": {
          source: "apache",
          extensions: ["tex"]
        },
        "application/x-tex-tfm": {
          source: "apache",
          extensions: ["tfm"]
        },
        "application/x-texinfo": {
          source: "apache",
          extensions: ["texinfo", "texi"]
        },
        "application/x-tgif": {
          source: "apache",
          extensions: ["obj"]
        },
        "application/x-ustar": {
          source: "apache",
          extensions: ["ustar"]
        },
        "application/x-virtualbox-hdd": {
          compressible: true,
          extensions: ["hdd"]
        },
        "application/x-virtualbox-ova": {
          compressible: true,
          extensions: ["ova"]
        },
        "application/x-virtualbox-ovf": {
          compressible: true,
          extensions: ["ovf"]
        },
        "application/x-virtualbox-vbox": {
          compressible: true,
          extensions: ["vbox"]
        },
        "application/x-virtualbox-vbox-extpack": {
          compressible: false,
          extensions: ["vbox-extpack"]
        },
        "application/x-virtualbox-vdi": {
          compressible: true,
          extensions: ["vdi"]
        },
        "application/x-virtualbox-vhd": {
          compressible: true,
          extensions: ["vhd"]
        },
        "application/x-virtualbox-vmdk": {
          compressible: true,
          extensions: ["vmdk"]
        },
        "application/x-wais-source": {
          source: "apache",
          extensions: ["src"]
        },
        "application/x-web-app-manifest+json": {
          compressible: true,
          extensions: ["webapp"]
        },
        "application/x-www-form-urlencoded": {
          source: "iana",
          compressible: true
        },
        "application/x-x509-ca-cert": {
          source: "iana",
          extensions: ["der", "crt", "pem"]
        },
        "application/x-x509-ca-ra-cert": {
          source: "iana"
        },
        "application/x-x509-next-ca-cert": {
          source: "iana"
        },
        "application/x-xfig": {
          source: "apache",
          extensions: ["fig"]
        },
        "application/x-xliff+xml": {
          source: "apache",
          compressible: true,
          extensions: ["xlf"]
        },
        "application/x-xpinstall": {
          source: "apache",
          compressible: false,
          extensions: ["xpi"]
        },
        "application/x-xz": {
          source: "apache",
          extensions: ["xz"]
        },
        "application/x-zmachine": {
          source: "apache",
          extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
        },
        "application/x400-bp": {
          source: "iana"
        },
        "application/xacml+xml": {
          source: "iana",
          compressible: true
        },
        "application/xaml+xml": {
          source: "apache",
          compressible: true,
          extensions: ["xaml"]
        },
        "application/xcap-att+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xav"]
        },
        "application/xcap-caps+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xca"]
        },
        "application/xcap-diff+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xdf"]
        },
        "application/xcap-el+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xel"]
        },
        "application/xcap-error+xml": {
          source: "iana",
          compressible: true
        },
        "application/xcap-ns+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xns"]
        },
        "application/xcon-conference-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/xcon-conference-info-diff+xml": {
          source: "iana",
          compressible: true
        },
        "application/xenc+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xenc"]
        },
        "application/xhtml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xhtml", "xht"]
        },
        "application/xhtml-voice+xml": {
          source: "apache",
          compressible: true
        },
        "application/xliff+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xlf"]
        },
        "application/xml": {
          source: "iana",
          compressible: true,
          extensions: ["xml", "xsl", "xsd", "rng"]
        },
        "application/xml-dtd": {
          source: "iana",
          compressible: true,
          extensions: ["dtd"]
        },
        "application/xml-external-parsed-entity": {
          source: "iana"
        },
        "application/xml-patch+xml": {
          source: "iana",
          compressible: true
        },
        "application/xmpp+xml": {
          source: "iana",
          compressible: true
        },
        "application/xop+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xop"]
        },
        "application/xproc+xml": {
          source: "apache",
          compressible: true,
          extensions: ["xpl"]
        },
        "application/xslt+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xsl", "xslt"]
        },
        "application/xspf+xml": {
          source: "apache",
          compressible: true,
          extensions: ["xspf"]
        },
        "application/xv+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mxml", "xhvml", "xvml", "xvm"]
        },
        "application/yang": {
          source: "iana",
          extensions: ["yang"]
        },
        "application/yang-data+json": {
          source: "iana",
          compressible: true
        },
        "application/yang-data+xml": {
          source: "iana",
          compressible: true
        },
        "application/yang-patch+json": {
          source: "iana",
          compressible: true
        },
        "application/yang-patch+xml": {
          source: "iana",
          compressible: true
        },
        "application/yin+xml": {
          source: "iana",
          compressible: true,
          extensions: ["yin"]
        },
        "application/zip": {
          source: "iana",
          compressible: false,
          extensions: ["zip"]
        },
        "application/zlib": {
          source: "iana"
        },
        "application/zstd": {
          source: "iana"
        },
        "audio/1d-interleaved-parityfec": {
          source: "iana"
        },
        "audio/32kadpcm": {
          source: "iana"
        },
        "audio/3gpp": {
          source: "iana",
          compressible: false,
          extensions: ["3gpp"]
        },
        "audio/3gpp2": {
          source: "iana"
        },
        "audio/aac": {
          source: "iana"
        },
        "audio/ac3": {
          source: "iana"
        },
        "audio/adpcm": {
          source: "apache",
          extensions: ["adp"]
        },
        "audio/amr": {
          source: "iana",
          extensions: ["amr"]
        },
        "audio/amr-wb": {
          source: "iana"
        },
        "audio/amr-wb+": {
          source: "iana"
        },
        "audio/aptx": {
          source: "iana"
        },
        "audio/asc": {
          source: "iana"
        },
        "audio/atrac-advanced-lossless": {
          source: "iana"
        },
        "audio/atrac-x": {
          source: "iana"
        },
        "audio/atrac3": {
          source: "iana"
        },
        "audio/basic": {
          source: "iana",
          compressible: false,
          extensions: ["au", "snd"]
        },
        "audio/bv16": {
          source: "iana"
        },
        "audio/bv32": {
          source: "iana"
        },
        "audio/clearmode": {
          source: "iana"
        },
        "audio/cn": {
          source: "iana"
        },
        "audio/dat12": {
          source: "iana"
        },
        "audio/dls": {
          source: "iana"
        },
        "audio/dsr-es201108": {
          source: "iana"
        },
        "audio/dsr-es202050": {
          source: "iana"
        },
        "audio/dsr-es202211": {
          source: "iana"
        },
        "audio/dsr-es202212": {
          source: "iana"
        },
        "audio/dv": {
          source: "iana"
        },
        "audio/dvi4": {
          source: "iana"
        },
        "audio/eac3": {
          source: "iana"
        },
        "audio/encaprtp": {
          source: "iana"
        },
        "audio/evrc": {
          source: "iana"
        },
        "audio/evrc-qcp": {
          source: "iana"
        },
        "audio/evrc0": {
          source: "iana"
        },
        "audio/evrc1": {
          source: "iana"
        },
        "audio/evrcb": {
          source: "iana"
        },
        "audio/evrcb0": {
          source: "iana"
        },
        "audio/evrcb1": {
          source: "iana"
        },
        "audio/evrcnw": {
          source: "iana"
        },
        "audio/evrcnw0": {
          source: "iana"
        },
        "audio/evrcnw1": {
          source: "iana"
        },
        "audio/evrcwb": {
          source: "iana"
        },
        "audio/evrcwb0": {
          source: "iana"
        },
        "audio/evrcwb1": {
          source: "iana"
        },
        "audio/evs": {
          source: "iana"
        },
        "audio/flexfec": {
          source: "iana"
        },
        "audio/fwdred": {
          source: "iana"
        },
        "audio/g711-0": {
          source: "iana"
        },
        "audio/g719": {
          source: "iana"
        },
        "audio/g722": {
          source: "iana"
        },
        "audio/g7221": {
          source: "iana"
        },
        "audio/g723": {
          source: "iana"
        },
        "audio/g726-16": {
          source: "iana"
        },
        "audio/g726-24": {
          source: "iana"
        },
        "audio/g726-32": {
          source: "iana"
        },
        "audio/g726-40": {
          source: "iana"
        },
        "audio/g728": {
          source: "iana"
        },
        "audio/g729": {
          source: "iana"
        },
        "audio/g7291": {
          source: "iana"
        },
        "audio/g729d": {
          source: "iana"
        },
        "audio/g729e": {
          source: "iana"
        },
        "audio/gsm": {
          source: "iana"
        },
        "audio/gsm-efr": {
          source: "iana"
        },
        "audio/gsm-hr-08": {
          source: "iana"
        },
        "audio/ilbc": {
          source: "iana"
        },
        "audio/ip-mr_v2.5": {
          source: "iana"
        },
        "audio/isac": {
          source: "apache"
        },
        "audio/l16": {
          source: "iana"
        },
        "audio/l20": {
          source: "iana"
        },
        "audio/l24": {
          source: "iana",
          compressible: false
        },
        "audio/l8": {
          source: "iana"
        },
        "audio/lpc": {
          source: "iana"
        },
        "audio/melp": {
          source: "iana"
        },
        "audio/melp1200": {
          source: "iana"
        },
        "audio/melp2400": {
          source: "iana"
        },
        "audio/melp600": {
          source: "iana"
        },
        "audio/mhas": {
          source: "iana"
        },
        "audio/midi": {
          source: "apache",
          extensions: ["mid", "midi", "kar", "rmi"]
        },
        "audio/mobile-xmf": {
          source: "iana",
          extensions: ["mxmf"]
        },
        "audio/mp3": {
          compressible: false,
          extensions: ["mp3"]
        },
        "audio/mp4": {
          source: "iana",
          compressible: false,
          extensions: ["m4a", "mp4a"]
        },
        "audio/mp4a-latm": {
          source: "iana"
        },
        "audio/mpa": {
          source: "iana"
        },
        "audio/mpa-robust": {
          source: "iana"
        },
        "audio/mpeg": {
          source: "iana",
          compressible: false,
          extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
        },
        "audio/mpeg4-generic": {
          source: "iana"
        },
        "audio/musepack": {
          source: "apache"
        },
        "audio/ogg": {
          source: "iana",
          compressible: false,
          extensions: ["oga", "ogg", "spx", "opus"]
        },
        "audio/opus": {
          source: "iana"
        },
        "audio/parityfec": {
          source: "iana"
        },
        "audio/pcma": {
          source: "iana"
        },
        "audio/pcma-wb": {
          source: "iana"
        },
        "audio/pcmu": {
          source: "iana"
        },
        "audio/pcmu-wb": {
          source: "iana"
        },
        "audio/prs.sid": {
          source: "iana"
        },
        "audio/qcelp": {
          source: "iana"
        },
        "audio/raptorfec": {
          source: "iana"
        },
        "audio/red": {
          source: "iana"
        },
        "audio/rtp-enc-aescm128": {
          source: "iana"
        },
        "audio/rtp-midi": {
          source: "iana"
        },
        "audio/rtploopback": {
          source: "iana"
        },
        "audio/rtx": {
          source: "iana"
        },
        "audio/s3m": {
          source: "apache",
          extensions: ["s3m"]
        },
        "audio/scip": {
          source: "iana"
        },
        "audio/silk": {
          source: "apache",
          extensions: ["sil"]
        },
        "audio/smv": {
          source: "iana"
        },
        "audio/smv-qcp": {
          source: "iana"
        },
        "audio/smv0": {
          source: "iana"
        },
        "audio/sofa": {
          source: "iana"
        },
        "audio/sp-midi": {
          source: "iana"
        },
        "audio/speex": {
          source: "iana"
        },
        "audio/t140c": {
          source: "iana"
        },
        "audio/t38": {
          source: "iana"
        },
        "audio/telephone-event": {
          source: "iana"
        },
        "audio/tetra_acelp": {
          source: "iana"
        },
        "audio/tetra_acelp_bb": {
          source: "iana"
        },
        "audio/tone": {
          source: "iana"
        },
        "audio/tsvcis": {
          source: "iana"
        },
        "audio/uemclip": {
          source: "iana"
        },
        "audio/ulpfec": {
          source: "iana"
        },
        "audio/usac": {
          source: "iana"
        },
        "audio/vdvi": {
          source: "iana"
        },
        "audio/vmr-wb": {
          source: "iana"
        },
        "audio/vnd.3gpp.iufp": {
          source: "iana"
        },
        "audio/vnd.4sb": {
          source: "iana"
        },
        "audio/vnd.audiokoz": {
          source: "iana"
        },
        "audio/vnd.celp": {
          source: "iana"
        },
        "audio/vnd.cisco.nse": {
          source: "iana"
        },
        "audio/vnd.cmles.radio-events": {
          source: "iana"
        },
        "audio/vnd.cns.anp1": {
          source: "iana"
        },
        "audio/vnd.cns.inf1": {
          source: "iana"
        },
        "audio/vnd.dece.audio": {
          source: "iana",
          extensions: ["uva", "uvva"]
        },
        "audio/vnd.digital-winds": {
          source: "iana",
          extensions: ["eol"]
        },
        "audio/vnd.dlna.adts": {
          source: "iana"
        },
        "audio/vnd.dolby.heaac.1": {
          source: "iana"
        },
        "audio/vnd.dolby.heaac.2": {
          source: "iana"
        },
        "audio/vnd.dolby.mlp": {
          source: "iana"
        },
        "audio/vnd.dolby.mps": {
          source: "iana"
        },
        "audio/vnd.dolby.pl2": {
          source: "iana"
        },
        "audio/vnd.dolby.pl2x": {
          source: "iana"
        },
        "audio/vnd.dolby.pl2z": {
          source: "iana"
        },
        "audio/vnd.dolby.pulse.1": {
          source: "iana"
        },
        "audio/vnd.dra": {
          source: "iana",
          extensions: ["dra"]
        },
        "audio/vnd.dts": {
          source: "iana",
          extensions: ["dts"]
        },
        "audio/vnd.dts.hd": {
          source: "iana",
          extensions: ["dtshd"]
        },
        "audio/vnd.dts.uhd": {
          source: "iana"
        },
        "audio/vnd.dvb.file": {
          source: "iana"
        },
        "audio/vnd.everad.plj": {
          source: "iana"
        },
        "audio/vnd.hns.audio": {
          source: "iana"
        },
        "audio/vnd.lucent.voice": {
          source: "iana",
          extensions: ["lvp"]
        },
        "audio/vnd.ms-playready.media.pya": {
          source: "iana",
          extensions: ["pya"]
        },
        "audio/vnd.nokia.mobile-xmf": {
          source: "iana"
        },
        "audio/vnd.nortel.vbk": {
          source: "iana"
        },
        "audio/vnd.nuera.ecelp4800": {
          source: "iana",
          extensions: ["ecelp4800"]
        },
        "audio/vnd.nuera.ecelp7470": {
          source: "iana",
          extensions: ["ecelp7470"]
        },
        "audio/vnd.nuera.ecelp9600": {
          source: "iana",
          extensions: ["ecelp9600"]
        },
        "audio/vnd.octel.sbc": {
          source: "iana"
        },
        "audio/vnd.presonus.multitrack": {
          source: "iana"
        },
        "audio/vnd.qcelp": {
          source: "iana"
        },
        "audio/vnd.rhetorex.32kadpcm": {
          source: "iana"
        },
        "audio/vnd.rip": {
          source: "iana",
          extensions: ["rip"]
        },
        "audio/vnd.rn-realaudio": {
          compressible: false
        },
        "audio/vnd.sealedmedia.softseal.mpeg": {
          source: "iana"
        },
        "audio/vnd.vmx.cvsd": {
          source: "iana"
        },
        "audio/vnd.wave": {
          compressible: false
        },
        "audio/vorbis": {
          source: "iana",
          compressible: false
        },
        "audio/vorbis-config": {
          source: "iana"
        },
        "audio/wav": {
          compressible: false,
          extensions: ["wav"]
        },
        "audio/wave": {
          compressible: false,
          extensions: ["wav"]
        },
        "audio/webm": {
          source: "apache",
          compressible: false,
          extensions: ["weba"]
        },
        "audio/x-aac": {
          source: "apache",
          compressible: false,
          extensions: ["aac"]
        },
        "audio/x-aiff": {
          source: "apache",
          extensions: ["aif", "aiff", "aifc"]
        },
        "audio/x-caf": {
          source: "apache",
          compressible: false,
          extensions: ["caf"]
        },
        "audio/x-flac": {
          source: "apache",
          extensions: ["flac"]
        },
        "audio/x-m4a": {
          source: "nginx",
          extensions: ["m4a"]
        },
        "audio/x-matroska": {
          source: "apache",
          extensions: ["mka"]
        },
        "audio/x-mpegurl": {
          source: "apache",
          extensions: ["m3u"]
        },
        "audio/x-ms-wax": {
          source: "apache",
          extensions: ["wax"]
        },
        "audio/x-ms-wma": {
          source: "apache",
          extensions: ["wma"]
        },
        "audio/x-pn-realaudio": {
          source: "apache",
          extensions: ["ram", "ra"]
        },
        "audio/x-pn-realaudio-plugin": {
          source: "apache",
          extensions: ["rmp"]
        },
        "audio/x-realaudio": {
          source: "nginx",
          extensions: ["ra"]
        },
        "audio/x-tta": {
          source: "apache"
        },
        "audio/x-wav": {
          source: "apache",
          extensions: ["wav"]
        },
        "audio/xm": {
          source: "apache",
          extensions: ["xm"]
        },
        "chemical/x-cdx": {
          source: "apache",
          extensions: ["cdx"]
        },
        "chemical/x-cif": {
          source: "apache",
          extensions: ["cif"]
        },
        "chemical/x-cmdf": {
          source: "apache",
          extensions: ["cmdf"]
        },
        "chemical/x-cml": {
          source: "apache",
          extensions: ["cml"]
        },
        "chemical/x-csml": {
          source: "apache",
          extensions: ["csml"]
        },
        "chemical/x-pdb": {
          source: "apache"
        },
        "chemical/x-xyz": {
          source: "apache",
          extensions: ["xyz"]
        },
        "font/collection": {
          source: "iana",
          extensions: ["ttc"]
        },
        "font/otf": {
          source: "iana",
          compressible: true,
          extensions: ["otf"]
        },
        "font/sfnt": {
          source: "iana"
        },
        "font/ttf": {
          source: "iana",
          compressible: true,
          extensions: ["ttf"]
        },
        "font/woff": {
          source: "iana",
          extensions: ["woff"]
        },
        "font/woff2": {
          source: "iana",
          extensions: ["woff2"]
        },
        "image/aces": {
          source: "iana",
          extensions: ["exr"]
        },
        "image/apng": {
          compressible: false,
          extensions: ["apng"]
        },
        "image/avci": {
          source: "iana",
          extensions: ["avci"]
        },
        "image/avcs": {
          source: "iana",
          extensions: ["avcs"]
        },
        "image/avif": {
          source: "iana",
          compressible: false,
          extensions: ["avif"]
        },
        "image/bmp": {
          source: "iana",
          compressible: true,
          extensions: ["bmp"]
        },
        "image/cgm": {
          source: "iana",
          extensions: ["cgm"]
        },
        "image/dicom-rle": {
          source: "iana",
          extensions: ["drle"]
        },
        "image/emf": {
          source: "iana",
          extensions: ["emf"]
        },
        "image/fits": {
          source: "iana",
          extensions: ["fits"]
        },
        "image/g3fax": {
          source: "iana",
          extensions: ["g3"]
        },
        "image/gif": {
          source: "iana",
          compressible: false,
          extensions: ["gif"]
        },
        "image/heic": {
          source: "iana",
          extensions: ["heic"]
        },
        "image/heic-sequence": {
          source: "iana",
          extensions: ["heics"]
        },
        "image/heif": {
          source: "iana",
          extensions: ["heif"]
        },
        "image/heif-sequence": {
          source: "iana",
          extensions: ["heifs"]
        },
        "image/hej2k": {
          source: "iana",
          extensions: ["hej2"]
        },
        "image/hsj2": {
          source: "iana",
          extensions: ["hsj2"]
        },
        "image/ief": {
          source: "iana",
          extensions: ["ief"]
        },
        "image/jls": {
          source: "iana",
          extensions: ["jls"]
        },
        "image/jp2": {
          source: "iana",
          compressible: false,
          extensions: ["jp2", "jpg2"]
        },
        "image/jpeg": {
          source: "iana",
          compressible: false,
          extensions: ["jpeg", "jpg", "jpe"]
        },
        "image/jph": {
          source: "iana",
          extensions: ["jph"]
        },
        "image/jphc": {
          source: "iana",
          extensions: ["jhc"]
        },
        "image/jpm": {
          source: "iana",
          compressible: false,
          extensions: ["jpm"]
        },
        "image/jpx": {
          source: "iana",
          compressible: false,
          extensions: ["jpx", "jpf"]
        },
        "image/jxr": {
          source: "iana",
          extensions: ["jxr"]
        },
        "image/jxra": {
          source: "iana",
          extensions: ["jxra"]
        },
        "image/jxrs": {
          source: "iana",
          extensions: ["jxrs"]
        },
        "image/jxs": {
          source: "iana",
          extensions: ["jxs"]
        },
        "image/jxsc": {
          source: "iana",
          extensions: ["jxsc"]
        },
        "image/jxsi": {
          source: "iana",
          extensions: ["jxsi"]
        },
        "image/jxss": {
          source: "iana",
          extensions: ["jxss"]
        },
        "image/ktx": {
          source: "iana",
          extensions: ["ktx"]
        },
        "image/ktx2": {
          source: "iana",
          extensions: ["ktx2"]
        },
        "image/naplps": {
          source: "iana"
        },
        "image/pjpeg": {
          compressible: false
        },
        "image/png": {
          source: "iana",
          compressible: false,
          extensions: ["png"]
        },
        "image/prs.btif": {
          source: "iana",
          extensions: ["btif"]
        },
        "image/prs.pti": {
          source: "iana",
          extensions: ["pti"]
        },
        "image/pwg-raster": {
          source: "iana"
        },
        "image/sgi": {
          source: "apache",
          extensions: ["sgi"]
        },
        "image/svg+xml": {
          source: "iana",
          compressible: true,
          extensions: ["svg", "svgz"]
        },
        "image/t38": {
          source: "iana",
          extensions: ["t38"]
        },
        "image/tiff": {
          source: "iana",
          compressible: false,
          extensions: ["tif", "tiff"]
        },
        "image/tiff-fx": {
          source: "iana",
          extensions: ["tfx"]
        },
        "image/vnd.adobe.photoshop": {
          source: "iana",
          compressible: true,
          extensions: ["psd"]
        },
        "image/vnd.airzip.accelerator.azv": {
          source: "iana",
          extensions: ["azv"]
        },
        "image/vnd.cns.inf2": {
          source: "iana"
        },
        "image/vnd.dece.graphic": {
          source: "iana",
          extensions: ["uvi", "uvvi", "uvg", "uvvg"]
        },
        "image/vnd.djvu": {
          source: "iana",
          extensions: ["djvu", "djv"]
        },
        "image/vnd.dvb.subtitle": {
          source: "iana",
          extensions: ["sub"]
        },
        "image/vnd.dwg": {
          source: "iana",
          extensions: ["dwg"]
        },
        "image/vnd.dxf": {
          source: "iana",
          extensions: ["dxf"]
        },
        "image/vnd.fastbidsheet": {
          source: "iana",
          extensions: ["fbs"]
        },
        "image/vnd.fpx": {
          source: "iana",
          extensions: ["fpx"]
        },
        "image/vnd.fst": {
          source: "iana",
          extensions: ["fst"]
        },
        "image/vnd.fujixerox.edmics-mmr": {
          source: "iana",
          extensions: ["mmr"]
        },
        "image/vnd.fujixerox.edmics-rlc": {
          source: "iana",
          extensions: ["rlc"]
        },
        "image/vnd.globalgraphics.pgb": {
          source: "iana"
        },
        "image/vnd.microsoft.icon": {
          source: "iana",
          compressible: true,
          extensions: ["ico"]
        },
        "image/vnd.mix": {
          source: "iana"
        },
        "image/vnd.mozilla.apng": {
          source: "iana"
        },
        "image/vnd.ms-dds": {
          compressible: true,
          extensions: ["dds"]
        },
        "image/vnd.ms-modi": {
          source: "iana",
          extensions: ["mdi"]
        },
        "image/vnd.ms-photo": {
          source: "apache",
          extensions: ["wdp"]
        },
        "image/vnd.net-fpx": {
          source: "iana",
          extensions: ["npx"]
        },
        "image/vnd.pco.b16": {
          source: "iana",
          extensions: ["b16"]
        },
        "image/vnd.radiance": {
          source: "iana"
        },
        "image/vnd.sealed.png": {
          source: "iana"
        },
        "image/vnd.sealedmedia.softseal.gif": {
          source: "iana"
        },
        "image/vnd.sealedmedia.softseal.jpg": {
          source: "iana"
        },
        "image/vnd.svf": {
          source: "iana"
        },
        "image/vnd.tencent.tap": {
          source: "iana",
          extensions: ["tap"]
        },
        "image/vnd.valve.source.texture": {
          source: "iana",
          extensions: ["vtf"]
        },
        "image/vnd.wap.wbmp": {
          source: "iana",
          extensions: ["wbmp"]
        },
        "image/vnd.xiff": {
          source: "iana",
          extensions: ["xif"]
        },
        "image/vnd.zbrush.pcx": {
          source: "iana",
          extensions: ["pcx"]
        },
        "image/webp": {
          source: "apache",
          extensions: ["webp"]
        },
        "image/wmf": {
          source: "iana",
          extensions: ["wmf"]
        },
        "image/x-3ds": {
          source: "apache",
          extensions: ["3ds"]
        },
        "image/x-cmu-raster": {
          source: "apache",
          extensions: ["ras"]
        },
        "image/x-cmx": {
          source: "apache",
          extensions: ["cmx"]
        },
        "image/x-freehand": {
          source: "apache",
          extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
        },
        "image/x-icon": {
          source: "apache",
          compressible: true,
          extensions: ["ico"]
        },
        "image/x-jng": {
          source: "nginx",
          extensions: ["jng"]
        },
        "image/x-mrsid-image": {
          source: "apache",
          extensions: ["sid"]
        },
        "image/x-ms-bmp": {
          source: "nginx",
          compressible: true,
          extensions: ["bmp"]
        },
        "image/x-pcx": {
          source: "apache",
          extensions: ["pcx"]
        },
        "image/x-pict": {
          source: "apache",
          extensions: ["pic", "pct"]
        },
        "image/x-portable-anymap": {
          source: "apache",
          extensions: ["pnm"]
        },
        "image/x-portable-bitmap": {
          source: "apache",
          extensions: ["pbm"]
        },
        "image/x-portable-graymap": {
          source: "apache",
          extensions: ["pgm"]
        },
        "image/x-portable-pixmap": {
          source: "apache",
          extensions: ["ppm"]
        },
        "image/x-rgb": {
          source: "apache",
          extensions: ["rgb"]
        },
        "image/x-tga": {
          source: "apache",
          extensions: ["tga"]
        },
        "image/x-xbitmap": {
          source: "apache",
          extensions: ["xbm"]
        },
        "image/x-xcf": {
          compressible: false
        },
        "image/x-xpixmap": {
          source: "apache",
          extensions: ["xpm"]
        },
        "image/x-xwindowdump": {
          source: "apache",
          extensions: ["xwd"]
        },
        "message/cpim": {
          source: "iana"
        },
        "message/delivery-status": {
          source: "iana"
        },
        "message/disposition-notification": {
          source: "iana",
          extensions: [
            "disposition-notification"
          ]
        },
        "message/external-body": {
          source: "iana"
        },
        "message/feedback-report": {
          source: "iana"
        },
        "message/global": {
          source: "iana",
          extensions: ["u8msg"]
        },
        "message/global-delivery-status": {
          source: "iana",
          extensions: ["u8dsn"]
        },
        "message/global-disposition-notification": {
          source: "iana",
          extensions: ["u8mdn"]
        },
        "message/global-headers": {
          source: "iana",
          extensions: ["u8hdr"]
        },
        "message/http": {
          source: "iana",
          compressible: false
        },
        "message/imdn+xml": {
          source: "iana",
          compressible: true
        },
        "message/news": {
          source: "iana"
        },
        "message/partial": {
          source: "iana",
          compressible: false
        },
        "message/rfc822": {
          source: "iana",
          compressible: true,
          extensions: ["eml", "mime"]
        },
        "message/s-http": {
          source: "iana"
        },
        "message/sip": {
          source: "iana"
        },
        "message/sipfrag": {
          source: "iana"
        },
        "message/tracking-status": {
          source: "iana"
        },
        "message/vnd.si.simp": {
          source: "iana"
        },
        "message/vnd.wfa.wsc": {
          source: "iana",
          extensions: ["wsc"]
        },
        "model/3mf": {
          source: "iana",
          extensions: ["3mf"]
        },
        "model/e57": {
          source: "iana"
        },
        "model/gltf+json": {
          source: "iana",
          compressible: true,
          extensions: ["gltf"]
        },
        "model/gltf-binary": {
          source: "iana",
          compressible: true,
          extensions: ["glb"]
        },
        "model/iges": {
          source: "iana",
          compressible: false,
          extensions: ["igs", "iges"]
        },
        "model/mesh": {
          source: "iana",
          compressible: false,
          extensions: ["msh", "mesh", "silo"]
        },
        "model/mtl": {
          source: "iana",
          extensions: ["mtl"]
        },
        "model/obj": {
          source: "iana",
          extensions: ["obj"]
        },
        "model/step": {
          source: "iana"
        },
        "model/step+xml": {
          source: "iana",
          compressible: true,
          extensions: ["stpx"]
        },
        "model/step+zip": {
          source: "iana",
          compressible: false,
          extensions: ["stpz"]
        },
        "model/step-xml+zip": {
          source: "iana",
          compressible: false,
          extensions: ["stpxz"]
        },
        "model/stl": {
          source: "iana",
          extensions: ["stl"]
        },
        "model/vnd.collada+xml": {
          source: "iana",
          compressible: true,
          extensions: ["dae"]
        },
        "model/vnd.dwf": {
          source: "iana",
          extensions: ["dwf"]
        },
        "model/vnd.flatland.3dml": {
          source: "iana"
        },
        "model/vnd.gdl": {
          source: "iana",
          extensions: ["gdl"]
        },
        "model/vnd.gs-gdl": {
          source: "apache"
        },
        "model/vnd.gs.gdl": {
          source: "iana"
        },
        "model/vnd.gtw": {
          source: "iana",
          extensions: ["gtw"]
        },
        "model/vnd.moml+xml": {
          source: "iana",
          compressible: true
        },
        "model/vnd.mts": {
          source: "iana",
          extensions: ["mts"]
        },
        "model/vnd.opengex": {
          source: "iana",
          extensions: ["ogex"]
        },
        "model/vnd.parasolid.transmit.binary": {
          source: "iana",
          extensions: ["x_b"]
        },
        "model/vnd.parasolid.transmit.text": {
          source: "iana",
          extensions: ["x_t"]
        },
        "model/vnd.pytha.pyox": {
          source: "iana"
        },
        "model/vnd.rosette.annotated-data-model": {
          source: "iana"
        },
        "model/vnd.sap.vds": {
          source: "iana",
          extensions: ["vds"]
        },
        "model/vnd.usdz+zip": {
          source: "iana",
          compressible: false,
          extensions: ["usdz"]
        },
        "model/vnd.valve.source.compiled-map": {
          source: "iana",
          extensions: ["bsp"]
        },
        "model/vnd.vtu": {
          source: "iana",
          extensions: ["vtu"]
        },
        "model/vrml": {
          source: "iana",
          compressible: false,
          extensions: ["wrl", "vrml"]
        },
        "model/x3d+binary": {
          source: "apache",
          compressible: false,
          extensions: ["x3db", "x3dbz"]
        },
        "model/x3d+fastinfoset": {
          source: "iana",
          extensions: ["x3db"]
        },
        "model/x3d+vrml": {
          source: "apache",
          compressible: false,
          extensions: ["x3dv", "x3dvz"]
        },
        "model/x3d+xml": {
          source: "iana",
          compressible: true,
          extensions: ["x3d", "x3dz"]
        },
        "model/x3d-vrml": {
          source: "iana",
          extensions: ["x3dv"]
        },
        "multipart/alternative": {
          source: "iana",
          compressible: false
        },
        "multipart/appledouble": {
          source: "iana"
        },
        "multipart/byteranges": {
          source: "iana"
        },
        "multipart/digest": {
          source: "iana"
        },
        "multipart/encrypted": {
          source: "iana",
          compressible: false
        },
        "multipart/form-data": {
          source: "iana",
          compressible: false
        },
        "multipart/header-set": {
          source: "iana"
        },
        "multipart/mixed": {
          source: "iana"
        },
        "multipart/multilingual": {
          source: "iana"
        },
        "multipart/parallel": {
          source: "iana"
        },
        "multipart/related": {
          source: "iana",
          compressible: false
        },
        "multipart/report": {
          source: "iana"
        },
        "multipart/signed": {
          source: "iana",
          compressible: false
        },
        "multipart/vnd.bint.med-plus": {
          source: "iana"
        },
        "multipart/voice-message": {
          source: "iana"
        },
        "multipart/x-mixed-replace": {
          source: "iana"
        },
        "text/1d-interleaved-parityfec": {
          source: "iana"
        },
        "text/cache-manifest": {
          source: "iana",
          compressible: true,
          extensions: ["appcache", "manifest"]
        },
        "text/calendar": {
          source: "iana",
          extensions: ["ics", "ifb"]
        },
        "text/calender": {
          compressible: true
        },
        "text/cmd": {
          compressible: true
        },
        "text/coffeescript": {
          extensions: ["coffee", "litcoffee"]
        },
        "text/cql": {
          source: "iana"
        },
        "text/cql-expression": {
          source: "iana"
        },
        "text/cql-identifier": {
          source: "iana"
        },
        "text/css": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["css"]
        },
        "text/csv": {
          source: "iana",
          compressible: true,
          extensions: ["csv"]
        },
        "text/csv-schema": {
          source: "iana"
        },
        "text/directory": {
          source: "iana"
        },
        "text/dns": {
          source: "iana"
        },
        "text/ecmascript": {
          source: "iana"
        },
        "text/encaprtp": {
          source: "iana"
        },
        "text/enriched": {
          source: "iana"
        },
        "text/fhirpath": {
          source: "iana"
        },
        "text/flexfec": {
          source: "iana"
        },
        "text/fwdred": {
          source: "iana"
        },
        "text/gff3": {
          source: "iana"
        },
        "text/grammar-ref-list": {
          source: "iana"
        },
        "text/html": {
          source: "iana",
          compressible: true,
          extensions: ["html", "htm", "shtml"]
        },
        "text/jade": {
          extensions: ["jade"]
        },
        "text/javascript": {
          source: "iana",
          compressible: true
        },
        "text/jcr-cnd": {
          source: "iana"
        },
        "text/jsx": {
          compressible: true,
          extensions: ["jsx"]
        },
        "text/less": {
          compressible: true,
          extensions: ["less"]
        },
        "text/markdown": {
          source: "iana",
          compressible: true,
          extensions: ["markdown", "md"]
        },
        "text/mathml": {
          source: "nginx",
          extensions: ["mml"]
        },
        "text/mdx": {
          compressible: true,
          extensions: ["mdx"]
        },
        "text/mizar": {
          source: "iana"
        },
        "text/n3": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["n3"]
        },
        "text/parameters": {
          source: "iana",
          charset: "UTF-8"
        },
        "text/parityfec": {
          source: "iana"
        },
        "text/plain": {
          source: "iana",
          compressible: true,
          extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
        },
        "text/provenance-notation": {
          source: "iana",
          charset: "UTF-8"
        },
        "text/prs.fallenstein.rst": {
          source: "iana"
        },
        "text/prs.lines.tag": {
          source: "iana",
          extensions: ["dsc"]
        },
        "text/prs.prop.logic": {
          source: "iana"
        },
        "text/raptorfec": {
          source: "iana"
        },
        "text/red": {
          source: "iana"
        },
        "text/rfc822-headers": {
          source: "iana"
        },
        "text/richtext": {
          source: "iana",
          compressible: true,
          extensions: ["rtx"]
        },
        "text/rtf": {
          source: "iana",
          compressible: true,
          extensions: ["rtf"]
        },
        "text/rtp-enc-aescm128": {
          source: "iana"
        },
        "text/rtploopback": {
          source: "iana"
        },
        "text/rtx": {
          source: "iana"
        },
        "text/sgml": {
          source: "iana",
          extensions: ["sgml", "sgm"]
        },
        "text/shaclc": {
          source: "iana"
        },
        "text/shex": {
          source: "iana",
          extensions: ["shex"]
        },
        "text/slim": {
          extensions: ["slim", "slm"]
        },
        "text/spdx": {
          source: "iana",
          extensions: ["spdx"]
        },
        "text/strings": {
          source: "iana"
        },
        "text/stylus": {
          extensions: ["stylus", "styl"]
        },
        "text/t140": {
          source: "iana"
        },
        "text/tab-separated-values": {
          source: "iana",
          compressible: true,
          extensions: ["tsv"]
        },
        "text/troff": {
          source: "iana",
          extensions: ["t", "tr", "roff", "man", "me", "ms"]
        },
        "text/turtle": {
          source: "iana",
          charset: "UTF-8",
          extensions: ["ttl"]
        },
        "text/ulpfec": {
          source: "iana"
        },
        "text/uri-list": {
          source: "iana",
          compressible: true,
          extensions: ["uri", "uris", "urls"]
        },
        "text/vcard": {
          source: "iana",
          compressible: true,
          extensions: ["vcard"]
        },
        "text/vnd.a": {
          source: "iana"
        },
        "text/vnd.abc": {
          source: "iana"
        },
        "text/vnd.ascii-art": {
          source: "iana"
        },
        "text/vnd.curl": {
          source: "iana",
          extensions: ["curl"]
        },
        "text/vnd.curl.dcurl": {
          source: "apache",
          extensions: ["dcurl"]
        },
        "text/vnd.curl.mcurl": {
          source: "apache",
          extensions: ["mcurl"]
        },
        "text/vnd.curl.scurl": {
          source: "apache",
          extensions: ["scurl"]
        },
        "text/vnd.debian.copyright": {
          source: "iana",
          charset: "UTF-8"
        },
        "text/vnd.dmclientscript": {
          source: "iana"
        },
        "text/vnd.dvb.subtitle": {
          source: "iana",
          extensions: ["sub"]
        },
        "text/vnd.esmertec.theme-descriptor": {
          source: "iana",
          charset: "UTF-8"
        },
        "text/vnd.familysearch.gedcom": {
          source: "iana",
          extensions: ["ged"]
        },
        "text/vnd.ficlab.flt": {
          source: "iana"
        },
        "text/vnd.fly": {
          source: "iana",
          extensions: ["fly"]
        },
        "text/vnd.fmi.flexstor": {
          source: "iana",
          extensions: ["flx"]
        },
        "text/vnd.gml": {
          source: "iana"
        },
        "text/vnd.graphviz": {
          source: "iana",
          extensions: ["gv"]
        },
        "text/vnd.hans": {
          source: "iana"
        },
        "text/vnd.hgl": {
          source: "iana"
        },
        "text/vnd.in3d.3dml": {
          source: "iana",
          extensions: ["3dml"]
        },
        "text/vnd.in3d.spot": {
          source: "iana",
          extensions: ["spot"]
        },
        "text/vnd.iptc.newsml": {
          source: "iana"
        },
        "text/vnd.iptc.nitf": {
          source: "iana"
        },
        "text/vnd.latex-z": {
          source: "iana"
        },
        "text/vnd.motorola.reflex": {
          source: "iana"
        },
        "text/vnd.ms-mediapackage": {
          source: "iana"
        },
        "text/vnd.net2phone.commcenter.command": {
          source: "iana"
        },
        "text/vnd.radisys.msml-basic-layout": {
          source: "iana"
        },
        "text/vnd.senx.warpscript": {
          source: "iana"
        },
        "text/vnd.si.uricatalogue": {
          source: "iana"
        },
        "text/vnd.sosi": {
          source: "iana"
        },
        "text/vnd.sun.j2me.app-descriptor": {
          source: "iana",
          charset: "UTF-8",
          extensions: ["jad"]
        },
        "text/vnd.trolltech.linguist": {
          source: "iana",
          charset: "UTF-8"
        },
        "text/vnd.wap.si": {
          source: "iana"
        },
        "text/vnd.wap.sl": {
          source: "iana"
        },
        "text/vnd.wap.wml": {
          source: "iana",
          extensions: ["wml"]
        },
        "text/vnd.wap.wmlscript": {
          source: "iana",
          extensions: ["wmls"]
        },
        "text/vtt": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["vtt"]
        },
        "text/x-asm": {
          source: "apache",
          extensions: ["s", "asm"]
        },
        "text/x-c": {
          source: "apache",
          extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
        },
        "text/x-component": {
          source: "nginx",
          extensions: ["htc"]
        },
        "text/x-fortran": {
          source: "apache",
          extensions: ["f", "for", "f77", "f90"]
        },
        "text/x-gwt-rpc": {
          compressible: true
        },
        "text/x-handlebars-template": {
          extensions: ["hbs"]
        },
        "text/x-java-source": {
          source: "apache",
          extensions: ["java"]
        },
        "text/x-jquery-tmpl": {
          compressible: true
        },
        "text/x-lua": {
          extensions: ["lua"]
        },
        "text/x-markdown": {
          compressible: true,
          extensions: ["mkd"]
        },
        "text/x-nfo": {
          source: "apache",
          extensions: ["nfo"]
        },
        "text/x-opml": {
          source: "apache",
          extensions: ["opml"]
        },
        "text/x-org": {
          compressible: true,
          extensions: ["org"]
        },
        "text/x-pascal": {
          source: "apache",
          extensions: ["p", "pas"]
        },
        "text/x-processing": {
          compressible: true,
          extensions: ["pde"]
        },
        "text/x-sass": {
          extensions: ["sass"]
        },
        "text/x-scss": {
          extensions: ["scss"]
        },
        "text/x-setext": {
          source: "apache",
          extensions: ["etx"]
        },
        "text/x-sfv": {
          source: "apache",
          extensions: ["sfv"]
        },
        "text/x-suse-ymp": {
          compressible: true,
          extensions: ["ymp"]
        },
        "text/x-uuencode": {
          source: "apache",
          extensions: ["uu"]
        },
        "text/x-vcalendar": {
          source: "apache",
          extensions: ["vcs"]
        },
        "text/x-vcard": {
          source: "apache",
          extensions: ["vcf"]
        },
        "text/xml": {
          source: "iana",
          compressible: true,
          extensions: ["xml"]
        },
        "text/xml-external-parsed-entity": {
          source: "iana"
        },
        "text/yaml": {
          compressible: true,
          extensions: ["yaml", "yml"]
        },
        "video/1d-interleaved-parityfec": {
          source: "iana"
        },
        "video/3gpp": {
          source: "iana",
          extensions: ["3gp", "3gpp"]
        },
        "video/3gpp-tt": {
          source: "iana"
        },
        "video/3gpp2": {
          source: "iana",
          extensions: ["3g2"]
        },
        "video/av1": {
          source: "iana"
        },
        "video/bmpeg": {
          source: "iana"
        },
        "video/bt656": {
          source: "iana"
        },
        "video/celb": {
          source: "iana"
        },
        "video/dv": {
          source: "iana"
        },
        "video/encaprtp": {
          source: "iana"
        },
        "video/ffv1": {
          source: "iana"
        },
        "video/flexfec": {
          source: "iana"
        },
        "video/h261": {
          source: "iana",
          extensions: ["h261"]
        },
        "video/h263": {
          source: "iana",
          extensions: ["h263"]
        },
        "video/h263-1998": {
          source: "iana"
        },
        "video/h263-2000": {
          source: "iana"
        },
        "video/h264": {
          source: "iana",
          extensions: ["h264"]
        },
        "video/h264-rcdo": {
          source: "iana"
        },
        "video/h264-svc": {
          source: "iana"
        },
        "video/h265": {
          source: "iana"
        },
        "video/iso.segment": {
          source: "iana",
          extensions: ["m4s"]
        },
        "video/jpeg": {
          source: "iana",
          extensions: ["jpgv"]
        },
        "video/jpeg2000": {
          source: "iana"
        },
        "video/jpm": {
          source: "apache",
          extensions: ["jpm", "jpgm"]
        },
        "video/jxsv": {
          source: "iana"
        },
        "video/mj2": {
          source: "iana",
          extensions: ["mj2", "mjp2"]
        },
        "video/mp1s": {
          source: "iana"
        },
        "video/mp2p": {
          source: "iana"
        },
        "video/mp2t": {
          source: "iana",
          extensions: ["ts"]
        },
        "video/mp4": {
          source: "iana",
          compressible: false,
          extensions: ["mp4", "mp4v", "mpg4"]
        },
        "video/mp4v-es": {
          source: "iana"
        },
        "video/mpeg": {
          source: "iana",
          compressible: false,
          extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
        },
        "video/mpeg4-generic": {
          source: "iana"
        },
        "video/mpv": {
          source: "iana"
        },
        "video/nv": {
          source: "iana"
        },
        "video/ogg": {
          source: "iana",
          compressible: false,
          extensions: ["ogv"]
        },
        "video/parityfec": {
          source: "iana"
        },
        "video/pointer": {
          source: "iana"
        },
        "video/quicktime": {
          source: "iana",
          compressible: false,
          extensions: ["qt", "mov"]
        },
        "video/raptorfec": {
          source: "iana"
        },
        "video/raw": {
          source: "iana"
        },
        "video/rtp-enc-aescm128": {
          source: "iana"
        },
        "video/rtploopback": {
          source: "iana"
        },
        "video/rtx": {
          source: "iana"
        },
        "video/scip": {
          source: "iana"
        },
        "video/smpte291": {
          source: "iana"
        },
        "video/smpte292m": {
          source: "iana"
        },
        "video/ulpfec": {
          source: "iana"
        },
        "video/vc1": {
          source: "iana"
        },
        "video/vc2": {
          source: "iana"
        },
        "video/vnd.cctv": {
          source: "iana"
        },
        "video/vnd.dece.hd": {
          source: "iana",
          extensions: ["uvh", "uvvh"]
        },
        "video/vnd.dece.mobile": {
          source: "iana",
          extensions: ["uvm", "uvvm"]
        },
        "video/vnd.dece.mp4": {
          source: "iana"
        },
        "video/vnd.dece.pd": {
          source: "iana",
          extensions: ["uvp", "uvvp"]
        },
        "video/vnd.dece.sd": {
          source: "iana",
          extensions: ["uvs", "uvvs"]
        },
        "video/vnd.dece.video": {
          source: "iana",
          extensions: ["uvv", "uvvv"]
        },
        "video/vnd.directv.mpeg": {
          source: "iana"
        },
        "video/vnd.directv.mpeg-tts": {
          source: "iana"
        },
        "video/vnd.dlna.mpeg-tts": {
          source: "iana"
        },
        "video/vnd.dvb.file": {
          source: "iana",
          extensions: ["dvb"]
        },
        "video/vnd.fvt": {
          source: "iana",
          extensions: ["fvt"]
        },
        "video/vnd.hns.video": {
          source: "iana"
        },
        "video/vnd.iptvforum.1dparityfec-1010": {
          source: "iana"
        },
        "video/vnd.iptvforum.1dparityfec-2005": {
          source: "iana"
        },
        "video/vnd.iptvforum.2dparityfec-1010": {
          source: "iana"
        },
        "video/vnd.iptvforum.2dparityfec-2005": {
          source: "iana"
        },
        "video/vnd.iptvforum.ttsavc": {
          source: "iana"
        },
        "video/vnd.iptvforum.ttsmpeg2": {
          source: "iana"
        },
        "video/vnd.motorola.video": {
          source: "iana"
        },
        "video/vnd.motorola.videop": {
          source: "iana"
        },
        "video/vnd.mpegurl": {
          source: "iana",
          extensions: ["mxu", "m4u"]
        },
        "video/vnd.ms-playready.media.pyv": {
          source: "iana",
          extensions: ["pyv"]
        },
        "video/vnd.nokia.interleaved-multimedia": {
          source: "iana"
        },
        "video/vnd.nokia.mp4vr": {
          source: "iana"
        },
        "video/vnd.nokia.videovoip": {
          source: "iana"
        },
        "video/vnd.objectvideo": {
          source: "iana"
        },
        "video/vnd.radgamettools.bink": {
          source: "iana"
        },
        "video/vnd.radgamettools.smacker": {
          source: "iana"
        },
        "video/vnd.sealed.mpeg1": {
          source: "iana"
        },
        "video/vnd.sealed.mpeg4": {
          source: "iana"
        },
        "video/vnd.sealed.swf": {
          source: "iana"
        },
        "video/vnd.sealedmedia.softseal.mov": {
          source: "iana"
        },
        "video/vnd.uvvu.mp4": {
          source: "iana",
          extensions: ["uvu", "uvvu"]
        },
        "video/vnd.vivo": {
          source: "iana",
          extensions: ["viv"]
        },
        "video/vnd.youtube.yt": {
          source: "iana"
        },
        "video/vp8": {
          source: "iana"
        },
        "video/vp9": {
          source: "iana"
        },
        "video/webm": {
          source: "apache",
          compressible: false,
          extensions: ["webm"]
        },
        "video/x-f4v": {
          source: "apache",
          extensions: ["f4v"]
        },
        "video/x-fli": {
          source: "apache",
          extensions: ["fli"]
        },
        "video/x-flv": {
          source: "apache",
          compressible: false,
          extensions: ["flv"]
        },
        "video/x-m4v": {
          source: "apache",
          extensions: ["m4v"]
        },
        "video/x-matroska": {
          source: "apache",
          compressible: false,
          extensions: ["mkv", "mk3d", "mks"]
        },
        "video/x-mng": {
          source: "apache",
          extensions: ["mng"]
        },
        "video/x-ms-asf": {
          source: "apache",
          extensions: ["asf", "asx"]
        },
        "video/x-ms-vob": {
          source: "apache",
          extensions: ["vob"]
        },
        "video/x-ms-wm": {
          source: "apache",
          extensions: ["wm"]
        },
        "video/x-ms-wmv": {
          source: "apache",
          compressible: false,
          extensions: ["wmv"]
        },
        "video/x-ms-wmx": {
          source: "apache",
          extensions: ["wmx"]
        },
        "video/x-ms-wvx": {
          source: "apache",
          extensions: ["wvx"]
        },
        "video/x-msvideo": {
          source: "apache",
          extensions: ["avi"]
        },
        "video/x-sgi-movie": {
          source: "apache",
          extensions: ["movie"]
        },
        "video/x-smv": {
          source: "apache",
          extensions: ["smv"]
        },
        "x-conference/x-cooltalk": {
          source: "apache",
          extensions: ["ice"]
        },
        "x-shader/x-fragment": {
          compressible: true
        },
        "x-shader/x-vertex": {
          compressible: true
        }
      };
    }
  });

  // ../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js
  var require_mime_db = __commonJS({
    "../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js"(exports, module) {
      "use strict";
      module.exports = require_db();
    }
  });

  // ../../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js
  var require_mime_types = __commonJS({
    "../../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js"(exports) {
      "use strict";
      var db = require_mime_db();
      var extname = __require("path").extname;
      var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
      var TEXT_TYPE_REGEXP = /^text\//i;
      exports.charset = charset;
      exports.charsets = { lookup: charset };
      exports.contentType = contentType;
      exports.extension = extension;
      exports.extensions = /* @__PURE__ */ Object.create(null);
      exports.lookup = lookup;
      exports.types = /* @__PURE__ */ Object.create(null);
      populateMaps(exports.extensions, exports.types);
      function charset(type) {
        if (!type || typeof type !== "string") {
          return false;
        }
        var match = EXTRACT_TYPE_REGEXP.exec(type);
        var mime = match && db[match[1].toLowerCase()];
        if (mime && mime.charset) {
          return mime.charset;
        }
        if (match && TEXT_TYPE_REGEXP.test(match[1])) {
          return "UTF-8";
        }
        return false;
      }
      function contentType(str) {
        if (!str || typeof str !== "string") {
          return false;
        }
        var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
        if (!mime) {
          return false;
        }
        if (mime.indexOf("charset") === -1) {
          var charset2 = exports.charset(mime);
          if (charset2) mime += "; charset=" + charset2.toLowerCase();
        }
        return mime;
      }
      function extension(type) {
        if (!type || typeof type !== "string") {
          return false;
        }
        var match = EXTRACT_TYPE_REGEXP.exec(type);
        var exts = match && exports.extensions[match[1].toLowerCase()];
        if (!exts || !exts.length) {
          return false;
        }
        return exts[0];
      }
      function lookup(path) {
        if (!path || typeof path !== "string") {
          return false;
        }
        var extension2 = extname("x." + path).toLowerCase().substr(1);
        if (!extension2) {
          return false;
        }
        return exports.types[extension2] || false;
      }
      function populateMaps(extensions, types) {
        var preference = ["nginx", "apache", void 0, "iana"];
        Object.keys(db).forEach(function forEachMimeType(type) {
          var mime = db[type];
          var exts = mime.extensions;
          if (!exts || !exts.length) {
            return;
          }
          extensions[type] = exts;
          for (var i = 0; i < exts.length; i++) {
            var extension2 = exts[i];
            if (types[extension2]) {
              var from = preference.indexOf(db[types[extension2]].source);
              var to = preference.indexOf(mime.source);
              if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
                continue;
              }
            }
            types[extension2] = type;
          }
        });
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js
  var require_defer = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js"(exports, module) {
      "use strict";
      module.exports = defer;
      function defer(fn) {
        var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
        if (nextTick) {
          nextTick(fn);
        } else {
          setTimeout(fn, 0);
        }
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js
  var require_async = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js"(exports, module) {
      "use strict";
      var defer = require_defer();
      module.exports = async;
      function async(callback) {
        var isAsync = false;
        defer(function() {
          isAsync = true;
        });
        return function async_callback(err, result) {
          if (isAsync) {
            callback(err, result);
          } else {
            defer(function nextTick_callback() {
              callback(err, result);
            });
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js
  var require_abort = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js"(exports, module) {
      "use strict";
      module.exports = abort;
      function abort(state) {
        Object.keys(state.jobs).forEach(clean.bind(state));
        state.jobs = {};
      }
      function clean(key) {
        if (typeof this.jobs[key] == "function") {
          this.jobs[key]();
        }
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js
  var require_iterate = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js"(exports, module) {
      "use strict";
      var async = require_async();
      var abort = require_abort();
      module.exports = iterate;
      function iterate(list, iterator, state, callback) {
        var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
        state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
          if (!(key in state.jobs)) {
            return;
          }
          delete state.jobs[key];
          if (error) {
            abort(state);
          } else {
            state.results[key] = output;
          }
          callback(error, state.results);
        });
      }
      function runJob(iterator, key, item, callback) {
        var aborter;
        if (iterator.length == 2) {
          aborter = iterator(item, async(callback));
        } else {
          aborter = iterator(item, key, async(callback));
        }
        return aborter;
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js
  var require_state = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js"(exports, module) {
      "use strict";
      module.exports = state;
      function state(list, sortMethod) {
        var isNamedList = !Array.isArray(list), initState = {
          index: 0,
          keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
          jobs: {},
          results: isNamedList ? {} : [],
          size: isNamedList ? Object.keys(list).length : list.length
        };
        if (sortMethod) {
          initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
            return sortMethod(list[a], list[b]);
          });
        }
        return initState;
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js
  var require_terminator = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js"(exports, module) {
      "use strict";
      var abort = require_abort();
      var async = require_async();
      module.exports = terminator;
      function terminator(callback) {
        if (!Object.keys(this.jobs).length) {
          return;
        }
        this.index = this.size;
        abort(this);
        async(callback)(null, this.results);
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js
  var require_parallel = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js"(exports, module) {
      "use strict";
      var iterate = require_iterate();
      var initState = require_state();
      var terminator = require_terminator();
      module.exports = parallel;
      function parallel(list, iterator, callback) {
        var state = initState(list);
        while (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, function(error, result) {
            if (error) {
              callback(error, result);
              return;
            }
            if (Object.keys(state.jobs).length === 0) {
              callback(null, state.results);
              return;
            }
          });
          state.index++;
        }
        return terminator.bind(state, callback);
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js
  var require_serialOrdered = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js"(exports, module) {
      "use strict";
      var iterate = require_iterate();
      var initState = require_state();
      var terminator = require_terminator();
      module.exports = serialOrdered;
      module.exports.ascending = ascending;
      module.exports.descending = descending;
      function serialOrdered(list, iterator, sortMethod, callback) {
        var state = initState(list, sortMethod);
        iterate(list, iterator, state, function iteratorHandler(error, result) {
          if (error) {
            callback(error, result);
            return;
          }
          state.index++;
          if (state.index < (state["keyedList"] || list).length) {
            iterate(list, iterator, state, iteratorHandler);
            return;
          }
          callback(null, state.results);
        });
        return terminator.bind(state, callback);
      }
      function ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      function descending(a, b) {
        return -1 * ascending(a, b);
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js
  var require_serial = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js"(exports, module) {
      "use strict";
      var serialOrdered = require_serialOrdered();
      module.exports = serial;
      function serial(list, iterator, callback) {
        return serialOrdered(list, iterator, null, callback);
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js
  var require_asynckit = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js"(exports, module) {
      "use strict";
      module.exports = {
        parallel: require_parallel(),
        serial: require_serial(),
        serialOrdered: require_serialOrdered()
      };
    }
  });

  // ../../node_modules/.pnpm/form-data@4.0.1/node_modules/form-data/lib/populate.js
  var require_populate = __commonJS({
    "../../node_modules/.pnpm/form-data@4.0.1/node_modules/form-data/lib/populate.js"(exports, module) {
      "use strict";
      module.exports = function(dst, src) {
        Object.keys(src).forEach(function(prop) {
          dst[prop] = dst[prop] || src[prop];
        });
        return dst;
      };
    }
  });

  // ../../node_modules/.pnpm/form-data@4.0.1/node_modules/form-data/lib/form_data.js
  var require_form_data = __commonJS({
    "../../node_modules/.pnpm/form-data@4.0.1/node_modules/form-data/lib/form_data.js"(exports, module) {
      "use strict";
      var CombinedStream = require_combined_stream();
      var util3 = __require("util");
      var path = __require("path");
      var http2 = __require("http");
      var https2 = __require("https");
      var parseUrl = __require("url").parse;
      var fs = __require("fs");
      var Stream = __require("stream").Stream;
      var mime = require_mime_types();
      var asynckit = require_asynckit();
      var populate = require_populate();
      module.exports = FormData3;
      util3.inherits(FormData3, CombinedStream);
      function FormData3(options) {
        if (!(this instanceof FormData3)) {
          return new FormData3(options);
        }
        this._overheadLength = 0;
        this._valueLength = 0;
        this._valuesToMeasure = [];
        CombinedStream.call(this);
        options = options || {};
        for (var option in options) {
          this[option] = options[option];
        }
      }
      FormData3.LINE_BREAK = "\r\n";
      FormData3.DEFAULT_CONTENT_TYPE = "application/octet-stream";
      FormData3.prototype.append = function(field, value, options) {
        options = options || {};
        if (typeof options == "string") {
          options = { filename: options };
        }
        var append2 = CombinedStream.prototype.append.bind(this);
        if (typeof value == "number") {
          value = "" + value;
        }
        if (Array.isArray(value)) {
          this._error(new Error("Arrays are not supported."));
          return;
        }
        var header = this._multiPartHeader(field, value, options);
        var footer = this._multiPartFooter();
        append2(header);
        append2(value);
        append2(footer);
        this._trackLength(header, value, options);
      };
      FormData3.prototype._trackLength = function(header, value, options) {
        var valueLength = 0;
        if (options.knownLength != null) {
          valueLength += +options.knownLength;
        } else if (Buffer.isBuffer(value)) {
          valueLength = value.length;
        } else if (typeof value === "string") {
          valueLength = Buffer.byteLength(value);
        }
        this._valueLength += valueLength;
        this._overheadLength += Buffer.byteLength(header) + FormData3.LINE_BREAK.length;
        if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion")) && !(value instanceof Stream)) {
          return;
        }
        if (!options.knownLength) {
          this._valuesToMeasure.push(value);
        }
      };
      FormData3.prototype._lengthRetriever = function(value, callback) {
        if (value.hasOwnProperty("fd")) {
          if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
            callback(null, value.end + 1 - (value.start ? value.start : 0));
          } else {
            fs.stat(value.path, function(err, stat) {
              var fileSize;
              if (err) {
                callback(err);
                return;
              }
              fileSize = stat.size - (value.start ? value.start : 0);
              callback(null, fileSize);
            });
          }
        } else if (value.hasOwnProperty("httpVersion")) {
          callback(null, +value.headers["content-length"]);
        } else if (value.hasOwnProperty("httpModule")) {
          value.on("response", function(response) {
            value.pause();
            callback(null, +response.headers["content-length"]);
          });
          value.resume();
        } else {
          callback("Unknown stream");
        }
      };
      FormData3.prototype._multiPartHeader = function(field, value, options) {
        if (typeof options.header == "string") {
          return options.header;
        }
        var contentDisposition = this._getContentDisposition(value, options);
        var contentType = this._getContentType(value, options);
        var contents = "";
        var headers = {
          // add custom disposition as third element or keep it two elements if not
          "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
          // if no content type. allow it to be empty array
          "Content-Type": [].concat(contentType || [])
        };
        if (typeof options.header == "object") {
          populate(headers, options.header);
        }
        var header;
        for (var prop in headers) {
          if (!headers.hasOwnProperty(prop)) continue;
          header = headers[prop];
          if (header == null) {
            continue;
          }
          if (!Array.isArray(header)) {
            header = [header];
          }
          if (header.length) {
            contents += prop + ": " + header.join("; ") + FormData3.LINE_BREAK;
          }
        }
        return "--" + this.getBoundary() + FormData3.LINE_BREAK + contents + FormData3.LINE_BREAK;
      };
      FormData3.prototype._getContentDisposition = function(value, options) {
        var filename, contentDisposition;
        if (typeof options.filepath === "string") {
          filename = path.normalize(options.filepath).replace(/\\/g, "/");
        } else if (options.filename || value.name || value.path) {
          filename = path.basename(options.filename || value.name || value.path);
        } else if (value.readable && value.hasOwnProperty("httpVersion")) {
          filename = path.basename(value.client._httpMessage.path || "");
        }
        if (filename) {
          contentDisposition = 'filename="' + filename + '"';
        }
        return contentDisposition;
      };
      FormData3.prototype._getContentType = function(value, options) {
        var contentType = options.contentType;
        if (!contentType && value.name) {
          contentType = mime.lookup(value.name);
        }
        if (!contentType && value.path) {
          contentType = mime.lookup(value.path);
        }
        if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
          contentType = value.headers["content-type"];
        }
        if (!contentType && (options.filepath || options.filename)) {
          contentType = mime.lookup(options.filepath || options.filename);
        }
        if (!contentType && typeof value == "object") {
          contentType = FormData3.DEFAULT_CONTENT_TYPE;
        }
        return contentType;
      };
      FormData3.prototype._multiPartFooter = function() {
        return function(next) {
          var footer = FormData3.LINE_BREAK;
          var lastPart = this._streams.length === 0;
          if (lastPart) {
            footer += this._lastBoundary();
          }
          next(footer);
        }.bind(this);
      };
      FormData3.prototype._lastBoundary = function() {
        return "--" + this.getBoundary() + "--" + FormData3.LINE_BREAK;
      };
      FormData3.prototype.getHeaders = function(userHeaders) {
        var header;
        var formHeaders = {
          "content-type": "multipart/form-data; boundary=" + this.getBoundary()
        };
        for (header in userHeaders) {
          if (userHeaders.hasOwnProperty(header)) {
            formHeaders[header.toLowerCase()] = userHeaders[header];
          }
        }
        return formHeaders;
      };
      FormData3.prototype.setBoundary = function(boundary) {
        this._boundary = boundary;
      };
      FormData3.prototype.getBoundary = function() {
        if (!this._boundary) {
          this._generateBoundary();
        }
        return this._boundary;
      };
      FormData3.prototype.getBuffer = function() {
        var dataBuffer = new Buffer.alloc(0);
        var boundary = this.getBoundary();
        for (var i = 0, len = this._streams.length; i < len; i++) {
          if (typeof this._streams[i] !== "function") {
            if (Buffer.isBuffer(this._streams[i])) {
              dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
            } else {
              dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
            }
            if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
              dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData3.LINE_BREAK)]);
            }
          }
        }
        return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
      };
      FormData3.prototype._generateBoundary = function() {
        var boundary = "--------------------------";
        for (var i = 0; i < 24; i++) {
          boundary += Math.floor(Math.random() * 10).toString(16);
        }
        this._boundary = boundary;
      };
      FormData3.prototype.getLengthSync = function() {
        var knownLength = this._overheadLength + this._valueLength;
        if (this._streams.length) {
          knownLength += this._lastBoundary().length;
        }
        if (!this.hasKnownLength()) {
          this._error(new Error("Cannot calculate proper length in synchronous way."));
        }
        return knownLength;
      };
      FormData3.prototype.hasKnownLength = function() {
        var hasKnownLength = true;
        if (this._valuesToMeasure.length) {
          hasKnownLength = false;
        }
        return hasKnownLength;
      };
      FormData3.prototype.getLength = function(cb) {
        var knownLength = this._overheadLength + this._valueLength;
        if (this._streams.length) {
          knownLength += this._lastBoundary().length;
        }
        if (!this._valuesToMeasure.length) {
          process.nextTick(cb.bind(this, null, knownLength));
          return;
        }
        asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
          if (err) {
            cb(err);
            return;
          }
          values.forEach(function(length) {
            knownLength += length;
          });
          cb(null, knownLength);
        });
      };
      FormData3.prototype.submit = function(params, cb) {
        var request, options, defaults2 = { method: "post" };
        if (typeof params == "string") {
          params = parseUrl(params);
          options = populate({
            port: params.port,
            path: params.pathname,
            host: params.hostname,
            protocol: params.protocol
          }, defaults2);
        } else {
          options = populate(params, defaults2);
          if (!options.port) {
            options.port = options.protocol == "https:" ? 443 : 80;
          }
        }
        options.headers = this.getHeaders(params.headers);
        if (options.protocol == "https:") {
          request = https2.request(options);
        } else {
          request = http2.request(options);
        }
        this.getLength(function(err, length) {
          if (err && err !== "Unknown stream") {
            this._error(err);
            return;
          }
          if (length) {
            request.setHeader("Content-Length", length);
          }
          this.pipe(request);
          if (cb) {
            var onResponse;
            var callback = function(error, responce) {
              request.removeListener("error", callback);
              request.removeListener("response", onResponse);
              return cb.call(this, error, responce);
            };
            onResponse = callback.bind(this, null);
            request.on("error", callback);
            request.on("response", onResponse);
          }
        }.bind(this));
        return request;
      };
      FormData3.prototype._error = function(err) {
        if (!this.error) {
          this.error = err;
          this.pause();
          this.emit("error", err);
        }
      };
      FormData3.prototype.toString = function() {
        return "[object FormData]";
      };
    }
  });

  // ../../node_modules/.pnpm/proxy-from-env@1.1.0/node_modules/proxy-from-env/index.js
  var require_proxy_from_env = __commonJS({
    "../../node_modules/.pnpm/proxy-from-env@1.1.0/node_modules/proxy-from-env/index.js"(exports) {
      "use strict";
      var parseUrl = __require("url").parse;
      var DEFAULT_PORTS = {
        ftp: 21,
        gopher: 70,
        http: 80,
        https: 443,
        ws: 80,
        wss: 443
      };
      var stringEndsWith = String.prototype.endsWith || function(s) {
        return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
      };
      function getProxyForUrl(url2) {
        var parsedUrl = typeof url2 === "string" ? parseUrl(url2) : url2 || {};
        var proto = parsedUrl.protocol;
        var hostname = parsedUrl.host;
        var port = parsedUrl.port;
        if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
          return "";
        }
        proto = proto.split(":", 1)[0];
        hostname = hostname.replace(/:\d*$/, "");
        port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
        if (!shouldProxy(hostname, port)) {
          return "";
        }
        var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
        if (proxy && proxy.indexOf("://") === -1) {
          proxy = proto + "://" + proxy;
        }
        return proxy;
      }
      function shouldProxy(hostname, port) {
        var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
        if (!NO_PROXY) {
          return true;
        }
        if (NO_PROXY === "*") {
          return false;
        }
        return NO_PROXY.split(/[,\s]/).every(function(proxy) {
          if (!proxy) {
            return true;
          }
          var parsedProxy = proxy.match(/^(.+):(\d+)$/);
          var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
          var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
          if (parsedProxyPort && parsedProxyPort !== port) {
            return true;
          }
          if (!/^[.*]/.test(parsedProxyHostname)) {
            return hostname !== parsedProxyHostname;
          }
          if (parsedProxyHostname.charAt(0) === "*") {
            parsedProxyHostname = parsedProxyHostname.slice(1);
          }
          return !stringEndsWith.call(hostname, parsedProxyHostname);
        });
      }
      function getEnv(key) {
        return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
      }
      exports.getProxyForUrl = getProxyForUrl;
    }
  });

  // ../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
  var require_ms = __commonJS({
    "../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js"(exports, module) {
      "use strict";
      var s = 1e3;
      var m = s * 60;
      var h2 = m * 60;
      var d = h2 * 24;
      var w = d * 7;
      var y = d * 365.25;
      module.exports = function(val, options) {
        options = options || {};
        var type = typeof val;
        if (type === "string" && val.length > 0) {
          return parse(val);
        } else if (type === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error(
          "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
        );
      };
      function parse(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str
        );
        if (!match) {
          return;
        }
        var n2 = parseFloat(match[1]);
        var type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n2 * y;
          case "weeks":
          case "week":
          case "w":
            return n2 * w;
          case "days":
          case "day":
          case "d":
            return n2 * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n2 * h2;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n2 * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n2 * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n2;
          default:
            return void 0;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return Math.round(ms / d) + "d";
        }
        if (msAbs >= h2) {
          return Math.round(ms / h2) + "h";
        }
        if (msAbs >= m) {
          return Math.round(ms / m) + "m";
        }
        if (msAbs >= s) {
          return Math.round(ms / s) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return plural(ms, msAbs, d, "day");
        }
        if (msAbs >= h2) {
          return plural(ms, msAbs, h2, "hour");
        }
        if (msAbs >= m) {
          return plural(ms, msAbs, m, "minute");
        }
        if (msAbs >= s) {
          return plural(ms, msAbs, s, "second");
        }
        return ms + " ms";
      }
      function plural(ms, msAbs, n2, name) {
        var isPlural = msAbs >= n2 * 1.5;
        return Math.round(ms / n2) + " " + name + (isPlural ? "s" : "");
      }
    }
  });

  // ../../node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/common.js
  var require_common = __commonJS({
    "../../node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/common.js"(exports, module) {
      "use strict";
      function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        createDebug.destroy = destroy;
        Object.keys(env).forEach((key) => {
          createDebug[key] = env[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          let hash = 0;
          for (let i = 0; i < namespace.length; i++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug(...args) {
            if (!debug.enabled) {
              return;
            }
            const self2 = debug;
            const curr = Number(/* @__PURE__ */ new Date());
            const ms = curr - (prevTime || curr);
            self2.diff = ms;
            self2.prev = prevTime;
            self2.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
              if (match === "%%") {
                return "%";
              }
              index++;
              const formatter = createDebug.formatters[format];
              if (typeof formatter === "function") {
                const val = args[index];
                match = formatter.call(self2, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug.formatArgs.call(self2, args);
            const logFn = self2.log || createDebug.log;
            logFn.apply(self2, args);
          }
          debug.namespace = namespace;
          debug.useColors = createDebug.useColors();
          debug.color = createDebug.selectColor(namespace);
          debug.extend = extend2;
          debug.destroy = createDebug.destroy;
          Object.defineProperty(debug, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }
              return enabledCache;
            },
            set: (v) => {
              enableOverride = v;
            }
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug);
          }
          return debug;
        }
        function extend2(namespace, delimiter) {
          const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
          newDebug.log = this.log;
          return newDebug;
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;
          createDebug.names = [];
          createDebug.skips = [];
          const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
          for (const ns of split) {
            if (ns[0] === "-") {
              createDebug.skips.push(ns.slice(1));
            } else {
              createDebug.names.push(ns);
            }
          }
        }
        function matchesTemplate(search, template) {
          let searchIndex = 0;
          let templateIndex = 0;
          let starIndex = -1;
          let matchIndex = 0;
          while (searchIndex < search.length) {
            if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
              if (template[templateIndex] === "*") {
                starIndex = templateIndex;
                matchIndex = searchIndex;
                templateIndex++;
              } else {
                searchIndex++;
                templateIndex++;
              }
            } else if (starIndex !== -1) {
              templateIndex = starIndex + 1;
              matchIndex++;
              searchIndex = matchIndex;
            } else {
              return false;
            }
          }
          while (templateIndex < template.length && template[templateIndex] === "*") {
            templateIndex++;
          }
          return templateIndex === template.length;
        }
        function disable() {
          const namespaces = [
            ...createDebug.names,
            ...createDebug.skips.map((namespace) => "-" + namespace)
          ].join(",");
          createDebug.enable("");
          return namespaces;
        }
        function enabled(name) {
          for (const skip of createDebug.skips) {
            if (matchesTemplate(name, skip)) {
              return false;
            }
          }
          for (const ns of createDebug.names) {
            if (matchesTemplate(name, ns)) {
              return true;
            }
          }
          return false;
        }
        function coerce(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        function destroy() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module.exports = setup;
    }
  });

  // ../../node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/browser.js
  var require_browser = __commonJS({
    "../../node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/browser.js"(exports, module) {
      "use strict";
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = localstorage();
      exports.destroy = /* @__PURE__ */ (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        let m;
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
        typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }
      exports.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports.storage.setItem("debug", namespaces);
          } else {
            exports.storage.removeItem("debug");
          }
        } catch (error) {
        }
      }
      function load() {
        let r2;
        try {
          r2 = exports.storage.getItem("debug");
        } catch (error) {
        }
        if (!r2 && typeof process !== "undefined" && "env" in process) {
          r2 = process.env.DEBUG;
        }
        return r2;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error) {
        }
      }
      module.exports = require_common()(exports);
      var { formatters } = module.exports;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
  var require_has_flag = __commonJS({
    "../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"(exports, module) {
      "use strict";
      module.exports = (flag, argv = process.argv) => {
        const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
        const position = argv.indexOf(prefix + flag);
        const terminatorPosition = argv.indexOf("--");
        return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
      };
    }
  });

  // ../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js
  var require_supports_color = __commonJS({
    "../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js"(exports, module) {
      "use strict";
      var os = __require("os");
      var tty = __require("tty");
      var hasFlag = require_has_flag();
      var { env } = process;
      var forceColor;
      if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
        forceColor = 0;
      } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
        forceColor = 1;
      }
      if ("FORCE_COLOR" in env) {
        if (env.FORCE_COLOR === "true") {
          forceColor = 1;
        } else if (env.FORCE_COLOR === "false") {
          forceColor = 0;
        } else {
          forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
        }
      }
      function translateLevel(level) {
        if (level === 0) {
          return false;
        }
        return {
          level,
          hasBasic: true,
          has256: level >= 2,
          has16m: level >= 3
        };
      }
      function supportsColor(haveStream, streamIsTTY) {
        if (forceColor === 0) {
          return 0;
        }
        if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
          return 3;
        }
        if (hasFlag("color=256")) {
          return 2;
        }
        if (haveStream && !streamIsTTY && forceColor === void 0) {
          return 0;
        }
        const min = forceColor || 0;
        if (env.TERM === "dumb") {
          return min;
        }
        if (process.platform === "win32") {
          const osRelease = os.release().split(".");
          if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
            return Number(osRelease[2]) >= 14931 ? 3 : 2;
          }
          return 1;
        }
        if ("CI" in env) {
          if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
            return 1;
          }
          return min;
        }
        if ("TEAMCITY_VERSION" in env) {
          return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
        }
        if (env.COLORTERM === "truecolor") {
          return 3;
        }
        if ("TERM_PROGRAM" in env) {
          const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
          switch (env.TERM_PROGRAM) {
            case "iTerm.app":
              return version2 >= 3 ? 3 : 2;
            case "Apple_Terminal":
              return 2;
          }
        }
        if (/-256(color)?$/i.test(env.TERM)) {
          return 2;
        }
        if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
          return 1;
        }
        if ("COLORTERM" in env) {
          return 1;
        }
        return min;
      }
      function getSupportLevel(stream4) {
        const level = supportsColor(stream4, stream4 && stream4.isTTY);
        return translateLevel(level);
      }
      module.exports = {
        supportsColor: getSupportLevel,
        stdout: translateLevel(supportsColor(true, tty.isatty(1))),
        stderr: translateLevel(supportsColor(true, tty.isatty(2)))
      };
    }
  });

  // ../../node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/node.js
  var require_node = __commonJS({
    "../../node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/node.js"(exports, module) {
      "use strict";
      var tty = __require("tty");
      var util3 = __require("util");
      exports.init = init;
      exports.log = log2;
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.destroy = util3.deprecate(
        () => {
        },
        "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
      );
      exports.colors = [6, 2, 3, 4, 5, 1];
      try {
        const supportsColor = require_supports_color();
        if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
          exports.colors = [
            20,
            21,
            26,
            27,
            32,
            33,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            56,
            57,
            62,
            63,
            68,
            69,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            92,
            93,
            98,
            99,
            112,
            113,
            128,
            129,
            134,
            135,
            148,
            149,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            178,
            179,
            184,
            185,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            203,
            204,
            205,
            206,
            207,
            208,
            209,
            214,
            215,
            220,
            221
          ];
        }
      } catch (error) {
      }
      exports.inspectOpts = Object.keys(process.env).filter((key) => {
        return /^debug_/i.test(key);
      }).reduce((obj, key) => {
        const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k2) => {
          return k2.toUpperCase();
        });
        let val = process.env[key];
        if (/^(yes|on|true|enabled)$/i.test(val)) {
          val = true;
        } else if (/^(no|off|false|disabled)$/i.test(val)) {
          val = false;
        } else if (val === "null") {
          val = null;
        } else {
          val = Number(val);
        }
        obj[prop] = val;
        return obj;
      }, {});
      function useColors() {
        return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
      }
      function formatArgs(args) {
        const { namespace: name, useColors: useColors2 } = this;
        if (useColors2) {
          const c = this.color;
          const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
          const prefix = `  ${colorCode};1m${name} \x1B[0m`;
          args[0] = prefix + args[0].split("\n").join("\n" + prefix);
          args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
        } else {
          args[0] = getDate() + name + " " + args[0];
        }
      }
      function getDate() {
        if (exports.inspectOpts.hideDate) {
          return "";
        }
        return (/* @__PURE__ */ new Date()).toISOString() + " ";
      }
      function log2(...args) {
        return process.stderr.write(util3.formatWithOptions(exports.inspectOpts, ...args) + "\n");
      }
      function save(namespaces) {
        if (namespaces) {
          process.env.DEBUG = namespaces;
        } else {
          delete process.env.DEBUG;
        }
      }
      function load() {
        return process.env.DEBUG;
      }
      function init(debug) {
        debug.inspectOpts = {};
        const keys = Object.keys(exports.inspectOpts);
        for (let i = 0; i < keys.length; i++) {
          debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
        }
      }
      module.exports = require_common()(exports);
      var { formatters } = module.exports;
      formatters.o = function(v) {
        this.inspectOpts.colors = this.useColors;
        return util3.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
      };
      formatters.O = function(v) {
        this.inspectOpts.colors = this.useColors;
        return util3.inspect(v, this.inspectOpts);
      };
    }
  });

  // ../../node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/index.js
  var require_src = __commonJS({
    "../../node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/index.js"(exports, module) {
      "use strict";
      if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
        module.exports = require_browser();
      } else {
        module.exports = require_node();
      }
    }
  });

  // ../../node_modules/.pnpm/follow-redirects@1.15.9/node_modules/follow-redirects/debug.js
  var require_debug = __commonJS({
    "../../node_modules/.pnpm/follow-redirects@1.15.9/node_modules/follow-redirects/debug.js"(exports, module) {
      "use strict";
      var debug;
      module.exports = function() {
        if (!debug) {
          try {
            debug = require_src()("follow-redirects");
          } catch (error) {
          }
          if (typeof debug !== "function") {
            debug = function() {
            };
          }
        }
        debug.apply(null, arguments);
      };
    }
  });

  // ../../node_modules/.pnpm/follow-redirects@1.15.9/node_modules/follow-redirects/index.js
  var require_follow_redirects = __commonJS({
    "../../node_modules/.pnpm/follow-redirects@1.15.9/node_modules/follow-redirects/index.js"(exports, module) {
      "use strict";
      var url2 = __require("url");
      var URL2 = url2.URL;
      var http2 = __require("http");
      var https2 = __require("https");
      var Writable = __require("stream").Writable;
      var assert2 = __require("assert");
      var debug = require_debug();
      (function detectUnsupportedEnvironment() {
        var looksLikeNode = typeof process !== "undefined";
        var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
        var looksLikeV8 = isFunction2(Error.captureStackTrace);
        if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
          console.warn("The follow-redirects package should be excluded from browser builds.");
        }
      })();
      var useNativeURL = false;
      try {
        assert2(new URL2(""));
      } catch (error) {
        useNativeURL = error.code === "ERR_INVALID_URL";
      }
      var preservedUrlFields = [
        "auth",
        "host",
        "hostname",
        "href",
        "path",
        "pathname",
        "port",
        "protocol",
        "query",
        "search",
        "hash"
      ];
      var events2 = ["abort", "aborted", "connect", "error", "socket", "timeout"];
      var eventHandlers = /* @__PURE__ */ Object.create(null);
      events2.forEach(function(event) {
        eventHandlers[event] = function(arg1, arg2, arg3) {
          this._redirectable.emit(event, arg1, arg2, arg3);
        };
      });
      var InvalidUrlError = createErrorType(
        "ERR_INVALID_URL",
        "Invalid URL",
        TypeError
      );
      var RedirectionError = createErrorType(
        "ERR_FR_REDIRECTION_FAILURE",
        "Redirected request failed"
      );
      var TooManyRedirectsError = createErrorType(
        "ERR_FR_TOO_MANY_REDIRECTS",
        "Maximum number of redirects exceeded",
        RedirectionError
      );
      var MaxBodyLengthExceededError = createErrorType(
        "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
        "Request body larger than maxBodyLength limit"
      );
      var WriteAfterEndError = createErrorType(
        "ERR_STREAM_WRITE_AFTER_END",
        "write after end"
      );
      var destroy = Writable.prototype.destroy || noop2;
      function RedirectableRequest(options, responseCallback) {
        Writable.call(this);
        this._sanitizeOptions(options);
        this._options = options;
        this._ended = false;
        this._ending = false;
        this._redirectCount = 0;
        this._redirects = [];
        this._requestBodyLength = 0;
        this._requestBodyBuffers = [];
        if (responseCallback) {
          this.on("response", responseCallback);
        }
        var self2 = this;
        this._onNativeResponse = function(response) {
          try {
            self2._processResponse(response);
          } catch (cause) {
            self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
          }
        };
        this._performRequest();
      }
      RedirectableRequest.prototype = Object.create(Writable.prototype);
      RedirectableRequest.prototype.abort = function() {
        destroyRequest(this._currentRequest);
        this._currentRequest.abort();
        this.emit("abort");
      };
      RedirectableRequest.prototype.destroy = function(error) {
        destroyRequest(this._currentRequest, error);
        destroy.call(this, error);
        return this;
      };
      RedirectableRequest.prototype.write = function(data, encoding, callback) {
        if (this._ending) {
          throw new WriteAfterEndError();
        }
        if (!isString2(data) && !isBuffer2(data)) {
          throw new TypeError("data should be a string, Buffer or Uint8Array");
        }
        if (isFunction2(encoding)) {
          callback = encoding;
          encoding = null;
        }
        if (data.length === 0) {
          if (callback) {
            callback();
          }
          return;
        }
        if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
          this._requestBodyLength += data.length;
          this._requestBodyBuffers.push({ data, encoding });
          this._currentRequest.write(data, encoding, callback);
        } else {
          this.emit("error", new MaxBodyLengthExceededError());
          this.abort();
        }
      };
      RedirectableRequest.prototype.end = function(data, encoding, callback) {
        if (isFunction2(data)) {
          callback = data;
          data = encoding = null;
        } else if (isFunction2(encoding)) {
          callback = encoding;
          encoding = null;
        }
        if (!data) {
          this._ended = this._ending = true;
          this._currentRequest.end(null, null, callback);
        } else {
          var self2 = this;
          var currentRequest = this._currentRequest;
          this.write(data, encoding, function() {
            self2._ended = true;
            currentRequest.end(null, null, callback);
          });
          this._ending = true;
        }
      };
      RedirectableRequest.prototype.setHeader = function(name, value) {
        this._options.headers[name] = value;
        this._currentRequest.setHeader(name, value);
      };
      RedirectableRequest.prototype.removeHeader = function(name) {
        delete this._options.headers[name];
        this._currentRequest.removeHeader(name);
      };
      RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
        var self2 = this;
        function destroyOnTimeout(socket) {
          socket.setTimeout(msecs);
          socket.removeListener("timeout", socket.destroy);
          socket.addListener("timeout", socket.destroy);
        }
        function startTimer(socket) {
          if (self2._timeout) {
            clearTimeout(self2._timeout);
          }
          self2._timeout = setTimeout(function() {
            self2.emit("timeout");
            clearTimer();
          }, msecs);
          destroyOnTimeout(socket);
        }
        function clearTimer() {
          if (self2._timeout) {
            clearTimeout(self2._timeout);
            self2._timeout = null;
          }
          self2.removeListener("abort", clearTimer);
          self2.removeListener("error", clearTimer);
          self2.removeListener("response", clearTimer);
          self2.removeListener("close", clearTimer);
          if (callback) {
            self2.removeListener("timeout", callback);
          }
          if (!self2.socket) {
            self2._currentRequest.removeListener("socket", startTimer);
          }
        }
        if (callback) {
          this.on("timeout", callback);
        }
        if (this.socket) {
          startTimer(this.socket);
        } else {
          this._currentRequest.once("socket", startTimer);
        }
        this.on("socket", destroyOnTimeout);
        this.on("abort", clearTimer);
        this.on("error", clearTimer);
        this.on("response", clearTimer);
        this.on("close", clearTimer);
        return this;
      };
      [
        "flushHeaders",
        "getHeader",
        "setNoDelay",
        "setSocketKeepAlive"
      ].forEach(function(method) {
        RedirectableRequest.prototype[method] = function(a, b) {
          return this._currentRequest[method](a, b);
        };
      });
      ["aborted", "connection", "socket"].forEach(function(property) {
        Object.defineProperty(RedirectableRequest.prototype, property, {
          get: function() {
            return this._currentRequest[property];
          }
        });
      });
      RedirectableRequest.prototype._sanitizeOptions = function(options) {
        if (!options.headers) {
          options.headers = {};
        }
        if (options.host) {
          if (!options.hostname) {
            options.hostname = options.host;
          }
          delete options.host;
        }
        if (!options.pathname && options.path) {
          var searchPos = options.path.indexOf("?");
          if (searchPos < 0) {
            options.pathname = options.path;
          } else {
            options.pathname = options.path.substring(0, searchPos);
            options.search = options.path.substring(searchPos);
          }
        }
      };
      RedirectableRequest.prototype._performRequest = function() {
        var protocol = this._options.protocol;
        var nativeProtocol = this._options.nativeProtocols[protocol];
        if (!nativeProtocol) {
          throw new TypeError("Unsupported protocol " + protocol);
        }
        if (this._options.agents) {
          var scheme = protocol.slice(0, -1);
          this._options.agent = this._options.agents[scheme];
        }
        var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
        request._redirectable = this;
        for (var event of events2) {
          request.on(event, eventHandlers[event]);
        }
        this._currentUrl = /^\//.test(this._options.path) ? url2.format(this._options) : (
          // When making a request to a proxy, []
          // a client MUST send the target URI in absolute-form [].
          this._options.path
        );
        if (this._isRedirect) {
          var i = 0;
          var self2 = this;
          var buffers = this._requestBodyBuffers;
          (function writeNext(error) {
            if (request === self2._currentRequest) {
              if (error) {
                self2.emit("error", error);
              } else if (i < buffers.length) {
                var buffer = buffers[i++];
                if (!request.finished) {
                  request.write(buffer.data, buffer.encoding, writeNext);
                }
              } else if (self2._ended) {
                request.end();
              }
            }
          })();
        }
      };
      RedirectableRequest.prototype._processResponse = function(response) {
        var statusCode = response.statusCode;
        if (this._options.trackRedirects) {
          this._redirects.push({
            url: this._currentUrl,
            headers: response.headers,
            statusCode
          });
        }
        var location = response.headers.location;
        if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
          response.responseUrl = this._currentUrl;
          response.redirects = this._redirects;
          this.emit("response", response);
          this._requestBodyBuffers = [];
          return;
        }
        destroyRequest(this._currentRequest);
        response.destroy();
        if (++this._redirectCount > this._options.maxRedirects) {
          throw new TooManyRedirectsError();
        }
        var requestHeaders;
        var beforeRedirect = this._options.beforeRedirect;
        if (beforeRedirect) {
          requestHeaders = Object.assign({
            // The Host header was set by nativeProtocol.request
            Host: response.req.getHeader("host")
          }, this._options.headers);
        }
        var method = this._options.method;
        if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
        // the server is redirecting the user agent to a different resource []
        // A user agent can perform a retrieval request targeting that URI
        // (a GET or HEAD request if using HTTP) []
        statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
          this._options.method = "GET";
          this._requestBodyBuffers = [];
          removeMatchingHeaders(/^content-/i, this._options.headers);
        }
        var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
        var currentUrlParts = parseUrl(this._currentUrl);
        var currentHost = currentHostHeader || currentUrlParts.host;
        var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url2.format(Object.assign(currentUrlParts, { host: currentHost }));
        var redirectUrl = resolveUrl(location, currentUrl);
        debug("redirecting to", redirectUrl.href);
        this._isRedirect = true;
        spreadUrlObject(redirectUrl, this._options);
        if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
          removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
        }
        if (isFunction2(beforeRedirect)) {
          var responseDetails = {
            headers: response.headers,
            statusCode
          };
          var requestDetails = {
            url: currentUrl,
            method,
            headers: requestHeaders
          };
          beforeRedirect(this._options, responseDetails, requestDetails);
          this._sanitizeOptions(this._options);
        }
        this._performRequest();
      };
      function wrap(protocols) {
        var exports2 = {
          maxRedirects: 21,
          maxBodyLength: 10 * 1024 * 1024
        };
        var nativeProtocols = {};
        Object.keys(protocols).forEach(function(scheme) {
          var protocol = scheme + ":";
          var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
          var wrappedProtocol = exports2[scheme] = Object.create(nativeProtocol);
          function request(input, options, callback) {
            if (isURL(input)) {
              input = spreadUrlObject(input);
            } else if (isString2(input)) {
              input = spreadUrlObject(parseUrl(input));
            } else {
              callback = options;
              options = validateUrl(input);
              input = { protocol };
            }
            if (isFunction2(options)) {
              callback = options;
              options = null;
            }
            options = Object.assign({
              maxRedirects: exports2.maxRedirects,
              maxBodyLength: exports2.maxBodyLength
            }, input, options);
            options.nativeProtocols = nativeProtocols;
            if (!isString2(options.host) && !isString2(options.hostname)) {
              options.hostname = "::1";
            }
            assert2.equal(options.protocol, protocol, "protocol mismatch");
            debug("options", options);
            return new RedirectableRequest(options, callback);
          }
          function get(input, options, callback) {
            var wrappedRequest = wrappedProtocol.request(input, options, callback);
            wrappedRequest.end();
            return wrappedRequest;
          }
          Object.defineProperties(wrappedProtocol, {
            request: { value: request, configurable: true, enumerable: true, writable: true },
            get: { value: get, configurable: true, enumerable: true, writable: true }
          });
        });
        return exports2;
      }
      function noop2() {
      }
      function parseUrl(input) {
        var parsed;
        if (useNativeURL) {
          parsed = new URL2(input);
        } else {
          parsed = validateUrl(url2.parse(input));
          if (!isString2(parsed.protocol)) {
            throw new InvalidUrlError({ input });
          }
        }
        return parsed;
      }
      function resolveUrl(relative, base) {
        return useNativeURL ? new URL2(relative, base) : parseUrl(url2.resolve(base, relative));
      }
      function validateUrl(input) {
        if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
          throw new InvalidUrlError({ input: input.href || input });
        }
        if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
          throw new InvalidUrlError({ input: input.href || input });
        }
        return input;
      }
      function spreadUrlObject(urlObject, target) {
        var spread3 = target || {};
        for (var key of preservedUrlFields) {
          spread3[key] = urlObject[key];
        }
        if (spread3.hostname.startsWith("[")) {
          spread3.hostname = spread3.hostname.slice(1, -1);
        }
        if (spread3.port !== "") {
          spread3.port = Number(spread3.port);
        }
        spread3.path = spread3.search ? spread3.pathname + spread3.search : spread3.pathname;
        return spread3;
      }
      function removeMatchingHeaders(regex, headers) {
        var lastValue;
        for (var header in headers) {
          if (regex.test(header)) {
            lastValue = headers[header];
            delete headers[header];
          }
        }
        return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
      }
      function createErrorType(code, message, baseClass) {
        function CustomError(properties) {
          if (isFunction2(Error.captureStackTrace)) {
            Error.captureStackTrace(this, this.constructor);
          }
          Object.assign(this, properties || {});
          this.code = code;
          this.message = this.cause ? message + ": " + this.cause.message : message;
        }
        CustomError.prototype = new (baseClass || Error)();
        Object.defineProperties(CustomError.prototype, {
          constructor: {
            value: CustomError,
            enumerable: false
          },
          name: {
            value: "Error [" + code + "]",
            enumerable: false
          }
        });
        return CustomError;
      }
      function destroyRequest(request, error) {
        for (var event of events2) {
          request.removeListener(event, eventHandlers[event]);
        }
        request.on("error", noop2);
        request.destroy(error);
      }
      function isSubdomain(subdomain, domain) {
        assert2(isString2(subdomain) && isString2(domain));
        var dot = subdomain.length - domain.length - 1;
        return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
      }
      function isString2(value) {
        return typeof value === "string" || value instanceof String;
      }
      function isFunction2(value) {
        return typeof value === "function";
      }
      function isBuffer2(value) {
        return typeof value === "object" && "length" in value;
      }
      function isURL(value) {
        return URL2 && value instanceof URL2;
      }
      module.exports = wrap({ http: http2, https: https2 });
      module.exports.wrap = wrap;
    }
  });

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    Api: () => Api,
    ChatCompletionRequestMessageContentPartAudioInputAudioFormatEnum: () => ChatCompletionRequestMessageContentPartAudioInputAudioFormatEnum,
    ChatCompletionRequestMessageContentPartAudioTypeEnum: () => ChatCompletionRequestMessageContentPartAudioTypeEnum,
    ChatCompletionRequestMessageContentPartTextTypeEnum: () => ChatCompletionRequestMessageContentPartTextTypeEnum,
    ChatCompletionRequestMessageRoleEnum: () => ChatCompletionRequestMessageRoleEnum,
    ChatCompletionResponseGabberMessageDataInnerTypeEnum: () => ChatCompletionResponseGabberMessageDataInnerTypeEnum,
    ChatCompletionResponseMessageRoleEnum: () => ChatCompletionResponseMessageRoleEnum,
    ChatCompletionStreamResponseChoicesInnerFinishReasonEnum: () => ChatCompletionStreamResponseChoicesInnerFinishReasonEnum,
    ChatCompletionStreamResponseDeltaRoleEnum: () => ChatCompletionStreamResponseDeltaRoleEnum,
    ChatCompletionStreamResponseGabberMessageDataInnerTypeEnum: () => ChatCompletionStreamResponseGabberMessageDataInnerTypeEnum,
    ChatCompletionStreamResponseObjectEnum: () => ChatCompletionStreamResponseObjectEnum,
    ContextCreateRequestMessagesInnerRoleEnum: () => ContextCreateRequestMessagesInnerRoleEnum,
    ContextMessageCreateParamsRoleEnum: () => ContextMessageCreateParamsRoleEnum,
    CreatePersonaRequestGenderEnum: () => CreatePersonaRequestGenderEnum,
    HistoryMessageRoleEnum: () => HistoryMessageRoleEnum,
    PersonaGenderEnum: () => PersonaGenderEnum,
    RealtimeSessionEngine: () => RealtimeSessionEngine,
    RealtimeSessionStateEnum: () => RealtimeSessionStateEnum,
    RealtimeSessionTimelineItemTypeEnum: () => RealtimeSessionTimelineItemTypeEnum,
    SDKAgentState: () => SDKAgentState,
    SDKConnectionState: () => SDKConnectionState,
    SessionStateEnum: () => SessionStateEnum,
    SessionTimelineItemTypeEnum: () => SessionTimelineItemTypeEnum,
    UpdatePersonaRequestGenderEnum: () => UpdatePersonaRequestGenderEnum,
    UsageType: () => UsageType,
    WebhookMessageUsageTrackedTypeEnum: () => WebhookMessageUsageTrackedTypeEnum
  });

  // ../../node_modules/.pnpm/livekit-client@2.7.5/node_modules/livekit-client/dist/livekit-client.esm.mjs
  function _mergeNamespaces(n2, m) {
    m.forEach(function(e) {
      e && typeof e !== "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k2) {
        if (k2 !== "default" && !(k2 in n2)) {
          var d = Object.getOwnPropertyDescriptor(e, k2);
          Object.defineProperty(n2, k2, d.get ? d : {
            enumerable: true,
            get: function() {
              return e[k2];
            }
          });
        }
      });
    });
    return Object.freeze(n2);
  }
  var k = Object.defineProperty;
  var n = (s, o, c) => o in s ? k(s, o, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: c
  }) : s[o] = c;
  var l = (s, o, c) => n(s, typeof o != "symbol" ? o + "" : o, c);
  var h = class {
    constructor() {
      l(this, "_locking");
      l(this, "_locks");
      this._locking = Promise.resolve(), this._locks = 0;
    }
    isLocked() {
      return this._locks > 0;
    }
    lock() {
      this._locks += 1;
      let o;
      const c = new Promise((i) => o = () => {
        this._locks -= 1, i();
      }), t = this._locking.then(() => o);
      return this._locking = this._locking.then(() => c), t;
    }
  };
  function assert(condition, msg) {
    if (!condition) {
      throw new Error(msg);
    }
  }
  var FLOAT32_MAX = 34028234663852886e22;
  var FLOAT32_MIN = -34028234663852886e22;
  var UINT32_MAX = 4294967295;
  var INT32_MAX = 2147483647;
  var INT32_MIN = -2147483648;
  function assertInt32(arg) {
    if (typeof arg !== "number") throw new Error("invalid int 32: " + typeof arg);
    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN) throw new Error("invalid int 32: " + arg);
  }
  function assertUInt32(arg) {
    if (typeof arg !== "number") throw new Error("invalid uint 32: " + typeof arg);
    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0) throw new Error("invalid uint 32: " + arg);
  }
  function assertFloat32(arg) {
    if (typeof arg !== "number") throw new Error("invalid float 32: " + typeof arg);
    if (!Number.isFinite(arg)) return;
    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN) throw new Error("invalid float 32: " + arg);
  }
  var enumTypeSymbol = Symbol("@bufbuild/protobuf/enum-type");
  function getEnumType(enumObject) {
    const t = enumObject[enumTypeSymbol];
    assert(t, "missing enum type on enum object");
    return t;
  }
  function setEnumType(enumObject, typeName, values, opt) {
    enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map((v) => ({
      no: v.no,
      name: v.name,
      localName: enumObject[v.no]
    })));
  }
  function makeEnumType(typeName, values, _opt) {
    const names = /* @__PURE__ */ Object.create(null);
    const numbers = /* @__PURE__ */ Object.create(null);
    const normalValues = [];
    for (const value of values) {
      const n2 = normalizeEnumValue(value);
      normalValues.push(n2);
      names[value.name] = n2;
      numbers[value.no] = n2;
    }
    return {
      typeName,
      values: normalValues,
      // We do not surface options at this time
      // options: opt?.options ?? Object.create(null),
      findName(name) {
        return names[name];
      },
      findNumber(no) {
        return numbers[no];
      }
    };
  }
  function makeEnum(typeName, values, opt) {
    const enumObject = {};
    for (const value of values) {
      const n2 = normalizeEnumValue(value);
      enumObject[n2.localName] = n2.no;
      enumObject[n2.no] = n2.localName;
    }
    setEnumType(enumObject, typeName, values);
    return enumObject;
  }
  function normalizeEnumValue(value) {
    if ("localName" in value) {
      return value;
    }
    return Object.assign(Object.assign({}, value), {
      localName: value.name
    });
  }
  var Message = class {
    /**
     * Compare with a message of the same type.
     * Note that this function disregards extensions and unknown fields.
     */
    equals(other) {
      return this.getType().runtime.util.equals(this.getType(), this, other);
    }
    /**
     * Create a deep copy.
     */
    clone() {
      return this.getType().runtime.util.clone(this);
    }
    /**
     * Parse from binary data, merging fields.
     *
     * Repeated fields are appended. Map entries are added, overwriting
     * existing keys.
     *
     * If a message field is already present, it will be merged with the
     * new data.
     */
    fromBinary(bytes, options) {
      const type = this.getType(), format = type.runtime.bin, opt = format.makeReadOptions(options);
      format.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);
      return this;
    }
    /**
     * Parse a message from a JSON value.
     */
    fromJson(jsonValue, options) {
      const type = this.getType(), format = type.runtime.json, opt = format.makeReadOptions(options);
      format.readMessage(type, jsonValue, opt, this);
      return this;
    }
    /**
     * Parse a message from a JSON string.
     */
    fromJsonString(jsonString, options) {
      let json;
      try {
        json = JSON.parse(jsonString);
      } catch (e) {
        throw new Error("cannot decode ".concat(this.getType().typeName, " from JSON: ").concat(e instanceof Error ? e.message : String(e)));
      }
      return this.fromJson(json, options);
    }
    /**
     * Serialize the message to binary data.
     */
    toBinary(options) {
      const type = this.getType(), bin = type.runtime.bin, opt = bin.makeWriteOptions(options), writer2 = opt.writerFactory();
      bin.writeMessage(this, writer2, opt);
      return writer2.finish();
    }
    /**
     * Serialize the message to a JSON value, a JavaScript value that can be
     * passed to JSON.stringify().
     */
    toJson(options) {
      const type = this.getType(), json = type.runtime.json, opt = json.makeWriteOptions(options);
      return json.writeMessage(this, opt);
    }
    /**
     * Serialize the message to a JSON string.
     */
    toJsonString(options) {
      var _a;
      const value = this.toJson(options);
      return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);
    }
    /**
     * Override for serialization behavior. This will be invoked when calling
     * JSON.stringify on this message (i.e. JSON.stringify(msg)).
     *
     * Note that this will not serialize google.protobuf.Any with a packed
     * message because the protobuf JSON format specifies that it needs to be
     * unpacked, and this is only possible with a type registry to look up the
     * message type.  As a result, attempting to serialize a message with this
     * type will throw an Error.
     *
     * This method is protected because you should not need to invoke it
     * directly -- instead use JSON.stringify or toJsonString for
     * stringified JSON.  Alternatively, if actual JSON is desired, you should
     * use toJson.
     */
    toJSON() {
      return this.toJson({
        emitDefaultValues: true
      });
    }
    /**
     * Retrieve the MessageType of this message - a singleton that represents
     * the protobuf message declaration and provides metadata for reflection-
     * based operations.
     */
    getType() {
      return Object.getPrototypeOf(this).constructor;
    }
  };
  function makeMessageType(runtime, typeName, fields, opt) {
    var _a;
    const localName = (_a = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a !== void 0 ? _a : typeName.substring(typeName.lastIndexOf(".") + 1);
    const type = {
      [localName]: function(data) {
        runtime.util.initFields(this);
        runtime.util.initPartial(data, this);
      }
    }[localName];
    Object.setPrototypeOf(type.prototype, new Message());
    Object.assign(type, {
      runtime,
      typeName,
      fields: runtime.util.newFieldList(fields),
      fromBinary(bytes, options) {
        return new type().fromBinary(bytes, options);
      },
      fromJson(jsonValue, options) {
        return new type().fromJson(jsonValue, options);
      },
      fromJsonString(jsonString, options) {
        return new type().fromJsonString(jsonString, options);
      },
      equals(a, b) {
        return runtime.util.equals(type, a, b);
      }
    });
    return type;
  }
  function varint64read() {
    let lowBits = 0;
    let highBits = 0;
    for (let shift = 0; shift < 28; shift += 7) {
      let b = this.buf[this.pos++];
      lowBits |= (b & 127) << shift;
      if ((b & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
    }
    let middleByte = this.buf[this.pos++];
    lowBits |= (middleByte & 15) << 28;
    highBits = (middleByte & 112) >> 4;
    if ((middleByte & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
    for (let shift = 3; shift <= 31; shift += 7) {
      let b = this.buf[this.pos++];
      highBits |= (b & 127) << shift;
      if ((b & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
    }
    throw new Error("invalid varint");
  }
  function varint64write(lo, hi, bytes) {
    for (let i = 0; i < 28; i = i + 7) {
      const shift = lo >>> i;
      const hasNext = !(shift >>> 7 == 0 && hi == 0);
      const byte = (hasNext ? shift | 128 : shift) & 255;
      bytes.push(byte);
      if (!hasNext) {
        return;
      }
    }
    const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
    const hasMoreBits = !(hi >> 3 == 0);
    bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
    if (!hasMoreBits) {
      return;
    }
    for (let i = 3; i < 31; i = i + 7) {
      const shift = hi >>> i;
      const hasNext = !(shift >>> 7 == 0);
      const byte = (hasNext ? shift | 128 : shift) & 255;
      bytes.push(byte);
      if (!hasNext) {
        return;
      }
    }
    bytes.push(hi >>> 31 & 1);
  }
  var TWO_PWR_32_DBL = 4294967296;
  function int64FromString(dec) {
    const minus = dec[0] === "-";
    if (minus) {
      dec = dec.slice(1);
    }
    const base = 1e6;
    let lowBits = 0;
    let highBits = 0;
    function add1e6digit(begin, end) {
      const digit1e6 = Number(dec.slice(begin, end));
      highBits *= base;
      lowBits = lowBits * base + digit1e6;
      if (lowBits >= TWO_PWR_32_DBL) {
        highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
        lowBits = lowBits % TWO_PWR_32_DBL;
      }
    }
    add1e6digit(-24, -18);
    add1e6digit(-18, -12);
    add1e6digit(-12, -6);
    add1e6digit(-6);
    return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
  }
  function int64ToString(lo, hi) {
    let bits = newBits(lo, hi);
    const negative = bits.hi & 2147483648;
    if (negative) {
      bits = negate(bits.lo, bits.hi);
    }
    const result = uInt64ToString(bits.lo, bits.hi);
    return negative ? "-" + result : result;
  }
  function uInt64ToString(lo, hi) {
    ({
      lo,
      hi
    } = toUnsigned(lo, hi));
    if (hi <= 2097151) {
      return String(TWO_PWR_32_DBL * hi + lo);
    }
    const low = lo & 16777215;
    const mid = (lo >>> 24 | hi << 8) & 16777215;
    const high = hi >> 16 & 65535;
    let digitA = low + mid * 6777216 + high * 6710656;
    let digitB = mid + high * 8147497;
    let digitC = high * 2;
    const base = 1e7;
    if (digitA >= base) {
      digitB += Math.floor(digitA / base);
      digitA %= base;
    }
    if (digitB >= base) {
      digitC += Math.floor(digitB / base);
      digitB %= base;
    }
    return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
  }
  function toUnsigned(lo, hi) {
    return {
      lo: lo >>> 0,
      hi: hi >>> 0
    };
  }
  function newBits(lo, hi) {
    return {
      lo: lo | 0,
      hi: hi | 0
    };
  }
  function negate(lowBits, highBits) {
    highBits = ~highBits;
    if (lowBits) {
      lowBits = ~lowBits + 1;
    } else {
      highBits += 1;
    }
    return newBits(lowBits, highBits);
  }
  var decimalFrom1e7WithLeadingZeros = (digit1e7) => {
    const partial = String(digit1e7);
    return "0000000".slice(partial.length) + partial;
  };
  function varint32write(value, bytes) {
    if (value >= 0) {
      while (value > 127) {
        bytes.push(value & 127 | 128);
        value = value >>> 7;
      }
      bytes.push(value);
    } else {
      for (let i = 0; i < 9; i++) {
        bytes.push(value & 127 | 128);
        value = value >> 7;
      }
      bytes.push(1);
    }
  }
  function varint32read() {
    let b = this.buf[this.pos++];
    let result = b & 127;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 127) << 7;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 127) << 14;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 127) << 21;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 15) << 28;
    for (let readBytes2 = 5; (b & 128) !== 0 && readBytes2 < 10; readBytes2++) b = this.buf[this.pos++];
    if ((b & 128) != 0) throw new Error("invalid varint");
    this.assertBounds();
    return result >>> 0;
  }
  function makeInt64Support() {
    const dv = new DataView(new ArrayBuffer(8));
    const ok = typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && (typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1");
    if (ok) {
      const MIN = BigInt("-9223372036854775808"), MAX = BigInt("9223372036854775807"), UMIN = BigInt("0"), UMAX = BigInt("18446744073709551615");
      return {
        zero: BigInt(0),
        supported: true,
        parse(value) {
          const bi = typeof value == "bigint" ? value : BigInt(value);
          if (bi > MAX || bi < MIN) {
            throw new Error("int64 invalid: ".concat(value));
          }
          return bi;
        },
        uParse(value) {
          const bi = typeof value == "bigint" ? value : BigInt(value);
          if (bi > UMAX || bi < UMIN) {
            throw new Error("uint64 invalid: ".concat(value));
          }
          return bi;
        },
        enc(value) {
          dv.setBigInt64(0, this.parse(value), true);
          return {
            lo: dv.getInt32(0, true),
            hi: dv.getInt32(4, true)
          };
        },
        uEnc(value) {
          dv.setBigInt64(0, this.uParse(value), true);
          return {
            lo: dv.getInt32(0, true),
            hi: dv.getInt32(4, true)
          };
        },
        dec(lo, hi) {
          dv.setInt32(0, lo, true);
          dv.setInt32(4, hi, true);
          return dv.getBigInt64(0, true);
        },
        uDec(lo, hi) {
          dv.setInt32(0, lo, true);
          dv.setInt32(4, hi, true);
          return dv.getBigUint64(0, true);
        }
      };
    }
    const assertInt64String = (value) => assert(/^-?[0-9]+$/.test(value), "int64 invalid: ".concat(value));
    const assertUInt64String = (value) => assert(/^[0-9]+$/.test(value), "uint64 invalid: ".concat(value));
    return {
      zero: "0",
      supported: false,
      parse(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertInt64String(value);
        return value;
      },
      uParse(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertUInt64String(value);
        return value;
      },
      enc(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertInt64String(value);
        return int64FromString(value);
      },
      uEnc(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertUInt64String(value);
        return int64FromString(value);
      },
      dec(lo, hi) {
        return int64ToString(lo, hi);
      },
      uDec(lo, hi) {
        return uInt64ToString(lo, hi);
      }
    };
  }
  var protoInt64 = makeInt64Support();
  var ScalarType;
  (function(ScalarType2) {
    ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
    ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
    ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
    ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
    ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
    ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
    ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
    ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
    ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
    ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
    ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
    ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
    ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
    ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
    ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
  })(ScalarType || (ScalarType = {}));
  var LongType;
  (function(LongType2) {
    LongType2[LongType2["BIGINT"] = 0] = "BIGINT";
    LongType2[LongType2["STRING"] = 1] = "STRING";
  })(LongType || (LongType = {}));
  function scalarEquals(type, a, b) {
    if (a === b) {
      return true;
    }
    if (type == ScalarType.BYTES) {
      if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    switch (type) {
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        return a == b;
    }
    return false;
  }
  function scalarZeroValue(type, longType) {
    switch (type) {
      case ScalarType.BOOL:
        return false;
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        return longType == 0 ? protoInt64.zero : "0";
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        return 0;
      case ScalarType.BYTES:
        return new Uint8Array(0);
      case ScalarType.STRING:
        return "";
      default:
        return 0;
    }
  }
  function isScalarZeroValue(type, value) {
    switch (type) {
      case ScalarType.BOOL:
        return value === false;
      case ScalarType.STRING:
        return value === "";
      case ScalarType.BYTES:
        return value instanceof Uint8Array && !value.byteLength;
      default:
        return value == 0;
    }
  }
  var WireType;
  (function(WireType2) {
    WireType2[WireType2["Varint"] = 0] = "Varint";
    WireType2[WireType2["Bit64"] = 1] = "Bit64";
    WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
    WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
    WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
    WireType2[WireType2["Bit32"] = 5] = "Bit32";
  })(WireType || (WireType = {}));
  var BinaryWriter = class {
    constructor(textEncoder2) {
      this.stack = [];
      this.textEncoder = textEncoder2 !== null && textEncoder2 !== void 0 ? textEncoder2 : new TextEncoder();
      this.chunks = [];
      this.buf = [];
    }
    /**
     * Return all bytes written and reset this writer.
     */
    finish() {
      this.chunks.push(new Uint8Array(this.buf));
      let len = 0;
      for (let i = 0; i < this.chunks.length; i++) len += this.chunks[i].length;
      let bytes = new Uint8Array(len);
      let offset = 0;
      for (let i = 0; i < this.chunks.length; i++) {
        bytes.set(this.chunks[i], offset);
        offset += this.chunks[i].length;
      }
      this.chunks = [];
      return bytes;
    }
    /**
     * Start a new fork for length-delimited data like a message
     * or a packed repeated field.
     *
     * Must be joined later with `join()`.
     */
    fork() {
      this.stack.push({
        chunks: this.chunks,
        buf: this.buf
      });
      this.chunks = [];
      this.buf = [];
      return this;
    }
    /**
     * Join the last fork. Write its length and bytes, then
     * return to the previous state.
     */
    join() {
      let chunk = this.finish();
      let prev = this.stack.pop();
      if (!prev) throw new Error("invalid state, fork stack empty");
      this.chunks = prev.chunks;
      this.buf = prev.buf;
      this.uint32(chunk.byteLength);
      return this.raw(chunk);
    }
    /**
     * Writes a tag (field number and wire type).
     *
     * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
     *
     * Generated code should compute the tag ahead of time and call `uint32()`.
     */
    tag(fieldNo, type) {
      return this.uint32((fieldNo << 3 | type) >>> 0);
    }
    /**
     * Write a chunk of raw bytes.
     */
    raw(chunk) {
      if (this.buf.length) {
        this.chunks.push(new Uint8Array(this.buf));
        this.buf = [];
      }
      this.chunks.push(chunk);
      return this;
    }
    /**
     * Write a `uint32` value, an unsigned 32 bit varint.
     */
    uint32(value) {
      assertUInt32(value);
      while (value > 127) {
        this.buf.push(value & 127 | 128);
        value = value >>> 7;
      }
      this.buf.push(value);
      return this;
    }
    /**
     * Write a `int32` value, a signed 32 bit varint.
     */
    int32(value) {
      assertInt32(value);
      varint32write(value, this.buf);
      return this;
    }
    /**
     * Write a `bool` value, a variant.
     */
    bool(value) {
      this.buf.push(value ? 1 : 0);
      return this;
    }
    /**
     * Write a `bytes` value, length-delimited arbitrary data.
     */
    bytes(value) {
      this.uint32(value.byteLength);
      return this.raw(value);
    }
    /**
     * Write a `string` value, length-delimited data converted to UTF-8 text.
     */
    string(value) {
      let chunk = this.textEncoder.encode(value);
      this.uint32(chunk.byteLength);
      return this.raw(chunk);
    }
    /**
     * Write a `float` value, 32-bit floating point number.
     */
    float(value) {
      assertFloat32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setFloat32(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `double` value, a 64-bit floating point number.
     */
    double(value) {
      let chunk = new Uint8Array(8);
      new DataView(chunk.buffer).setFloat64(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
     */
    fixed32(value) {
      assertUInt32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setUint32(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
     */
    sfixed32(value) {
      assertInt32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setInt32(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
     */
    sint32(value) {
      assertInt32(value);
      value = (value << 1 ^ value >> 31) >>> 0;
      varint32write(value, this.buf);
      return this;
    }
    /**
     * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
     */
    sfixed64(value) {
      let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);
      view.setInt32(0, tc.lo, true);
      view.setInt32(4, tc.hi, true);
      return this.raw(chunk);
    }
    /**
     * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
     */
    fixed64(value) {
      let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);
      view.setInt32(0, tc.lo, true);
      view.setInt32(4, tc.hi, true);
      return this.raw(chunk);
    }
    /**
     * Write a `int64` value, a signed 64-bit varint.
     */
    int64(value) {
      let tc = protoInt64.enc(value);
      varint64write(tc.lo, tc.hi, this.buf);
      return this;
    }
    /**
     * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64(value) {
      let tc = protoInt64.enc(value), sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;
      varint64write(lo, hi, this.buf);
      return this;
    }
    /**
     * Write a `uint64` value, an unsigned 64-bit varint.
     */
    uint64(value) {
      let tc = protoInt64.uEnc(value);
      varint64write(tc.lo, tc.hi, this.buf);
      return this;
    }
  };
  var BinaryReader = class {
    constructor(buf, textDecoder) {
      this.varint64 = varint64read;
      this.uint32 = varint32read;
      this.buf = buf;
      this.len = buf.length;
      this.pos = 0;
      this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();
    }
    /**
     * Reads a tag - field number and wire type.
     */
    tag() {
      let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
      if (fieldNo <= 0 || wireType < 0 || wireType > 5) throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
      return [fieldNo, wireType];
    }
    /**
     * Skip one element and return the skipped data.
     *
     * When skipping StartGroup, provide the tags field number to check for
     * matching field number in the EndGroup tag.
     */
    skip(wireType, fieldNo) {
      let start = this.pos;
      switch (wireType) {
        case WireType.Varint:
          while (this.buf[this.pos++] & 128) {
          }
          break;
        // eslint-disable-next-line
        // @ts-ignore TS7029: Fallthrough case in switch
        case WireType.Bit64:
          this.pos += 4;
        // eslint-disable-next-line
        // @ts-ignore TS7029: Fallthrough case in switch
        case WireType.Bit32:
          this.pos += 4;
          break;
        case WireType.LengthDelimited:
          let len = this.uint32();
          this.pos += len;
          break;
        case WireType.StartGroup:
          for (; ; ) {
            const [fn, wt] = this.tag();
            if (wt === WireType.EndGroup) {
              if (fieldNo !== void 0 && fn !== fieldNo) {
                throw new Error("invalid end group tag");
              }
              break;
            }
            this.skip(wt, fn);
          }
          break;
        default:
          throw new Error("cant skip wire type " + wireType);
      }
      this.assertBounds();
      return this.buf.subarray(start, this.pos);
    }
    /**
     * Throws error if position in byte array is out of range.
     */
    assertBounds() {
      if (this.pos > this.len) throw new RangeError("premature EOF");
    }
    /**
     * Read a `int32` field, a signed 32 bit varint.
     */
    int32() {
      return this.uint32() | 0;
    }
    /**
     * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
     */
    sint32() {
      let zze = this.uint32();
      return zze >>> 1 ^ -(zze & 1);
    }
    /**
     * Read a `int64` field, a signed 64-bit varint.
     */
    int64() {
      return protoInt64.dec(...this.varint64());
    }
    /**
     * Read a `uint64` field, an unsigned 64-bit varint.
     */
    uint64() {
      return protoInt64.uDec(...this.varint64());
    }
    /**
     * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64() {
      let [lo, hi] = this.varint64();
      let s = -(lo & 1);
      lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
      hi = hi >>> 1 ^ s;
      return protoInt64.dec(lo, hi);
    }
    /**
     * Read a `bool` field, a variant.
     */
    bool() {
      let [lo, hi] = this.varint64();
      return lo !== 0 || hi !== 0;
    }
    /**
     * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
     */
    fixed32() {
      return this.view.getUint32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
     */
    sfixed32() {
      return this.view.getInt32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
     */
    fixed64() {
      return protoInt64.uDec(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
     */
    sfixed64() {
      return protoInt64.dec(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `float` field, 32-bit floating point number.
     */
    float() {
      return this.view.getFloat32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `double` field, a 64-bit floating point number.
     */
    double() {
      return this.view.getFloat64((this.pos += 8) - 8, true);
    }
    /**
     * Read a `bytes` field, length-delimited arbitrary data.
     */
    bytes() {
      let len = this.uint32(), start = this.pos;
      this.pos += len;
      this.assertBounds();
      return this.buf.subarray(start, start + len);
    }
    /**
     * Read a `string` field, length-delimited data converted to UTF-8 text.
     */
    string() {
      return this.textDecoder.decode(this.bytes());
    }
  };
  function makeExtension(runtime, typeName, extendee, field) {
    let fi;
    return {
      typeName,
      extendee,
      get field() {
        if (!fi) {
          const i = typeof field == "function" ? field() : field;
          i.name = typeName.split(".").pop();
          i.jsonName = "[".concat(typeName, "]");
          fi = runtime.util.newFieldList([i]).list()[0];
        }
        return fi;
      },
      runtime
    };
  }
  function createExtensionContainer(extension) {
    const localName = extension.field.localName;
    const container = /* @__PURE__ */ Object.create(null);
    container[localName] = initExtensionField(extension);
    return [container, () => container[localName]];
  }
  function initExtensionField(ext) {
    const field = ext.field;
    if (field.repeated) {
      return [];
    }
    if (field.default !== void 0) {
      return field.default;
    }
    switch (field.kind) {
      case "enum":
        return field.T.values[0].no;
      case "scalar":
        return scalarZeroValue(field.T, field.L);
      case "message":
        const T = field.T, value = new T();
        return T.fieldWrapper ? T.fieldWrapper.unwrapField(value) : value;
      case "map":
        throw "map fields are not allowed to be extensions";
    }
  }
  function filterUnknownFields(unknownFields, field) {
    if (!field.repeated && (field.kind == "enum" || field.kind == "scalar")) {
      for (let i = unknownFields.length - 1; i >= 0; --i) {
        if (unknownFields[i].no == field.no) {
          return [unknownFields[i]];
        }
      }
      return [];
    }
    return unknownFields.filter((uf) => uf.no === field.no);
  }
  var encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  var decTable = [];
  for (let i = 0; i < encTable.length; i++) decTable[encTable[i].charCodeAt(0)] = i;
  decTable["-".charCodeAt(0)] = encTable.indexOf("+");
  decTable["_".charCodeAt(0)] = encTable.indexOf("/");
  var protoBase64 = {
    /**
     * Decodes a base64 string to a byte array.
     *
     * - ignores white-space, including line breaks and tabs
     * - allows inner padding (can decode concatenated base64 strings)
     * - does not require padding
     * - understands base64url encoding:
     *   "-" instead of "+",
     *   "_" instead of "/",
     *   no padding
     */
    dec(base64Str) {
      let es = base64Str.length * 3 / 4;
      if (base64Str[base64Str.length - 2] == "=") es -= 2;
      else if (base64Str[base64Str.length - 1] == "=") es -= 1;
      let bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b, p = 0;
      for (let i = 0; i < base64Str.length; i++) {
        b = decTable[base64Str.charCodeAt(i)];
        if (b === void 0) {
          switch (base64Str[i]) {
            // @ts-ignore TS7029: Fallthrough case in switch
            case "=":
              groupPos = 0;
            // reset state when padding found
            // @ts-ignore TS7029: Fallthrough case in switch
            case "\n":
            case "\r":
            case "	":
            case " ":
              continue;
            // skip white-space, and padding
            default:
              throw Error("invalid base64 string.");
          }
        }
        switch (groupPos) {
          case 0:
            p = b;
            groupPos = 1;
            break;
          case 1:
            bytes[bytePos++] = p << 2 | (b & 48) >> 4;
            p = b;
            groupPos = 2;
            break;
          case 2:
            bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
            p = b;
            groupPos = 3;
            break;
          case 3:
            bytes[bytePos++] = (p & 3) << 6 | b;
            groupPos = 0;
            break;
        }
      }
      if (groupPos == 1) throw Error("invalid base64 string.");
      return bytes.subarray(0, bytePos);
    },
    /**
     * Encode a byte array to a base64 string.
     */
    enc(bytes) {
      let base64 = "", groupPos = 0, b, p = 0;
      for (let i = 0; i < bytes.length; i++) {
        b = bytes[i];
        switch (groupPos) {
          case 0:
            base64 += encTable[b >> 2];
            p = (b & 3) << 4;
            groupPos = 1;
            break;
          case 1:
            base64 += encTable[p | b >> 4];
            p = (b & 15) << 2;
            groupPos = 2;
            break;
          case 2:
            base64 += encTable[p | b >> 6];
            base64 += encTable[b & 63];
            groupPos = 0;
            break;
        }
      }
      if (groupPos) {
        base64 += encTable[p];
        base64 += "=";
        if (groupPos == 1) base64 += "=";
      }
      return base64;
    }
  };
  function getExtension(message, extension, options) {
    assertExtendee(extension, message);
    const opt = extension.runtime.bin.makeReadOptions(options);
    const ufs = filterUnknownFields(message.getType().runtime.bin.listUnknownFields(message), extension.field);
    const [container, get] = createExtensionContainer(extension);
    for (const uf of ufs) {
      extension.runtime.bin.readField(container, opt.readerFactory(uf.data), extension.field, uf.wireType, opt);
    }
    return get();
  }
  function setExtension(message, extension, value, options) {
    assertExtendee(extension, message);
    const readOpt = extension.runtime.bin.makeReadOptions(options);
    const writeOpt = extension.runtime.bin.makeWriteOptions(options);
    if (hasExtension(message, extension)) {
      const ufs = message.getType().runtime.bin.listUnknownFields(message).filter((uf) => uf.no != extension.field.no);
      message.getType().runtime.bin.discardUnknownFields(message);
      for (const uf of ufs) {
        message.getType().runtime.bin.onUnknownField(message, uf.no, uf.wireType, uf.data);
      }
    }
    const writer2 = writeOpt.writerFactory();
    let f = extension.field;
    if (!f.opt && !f.repeated && (f.kind == "enum" || f.kind == "scalar")) {
      f = Object.assign(Object.assign({}, extension.field), {
        opt: true
      });
    }
    extension.runtime.bin.writeField(f, value, writer2, writeOpt);
    const reader = readOpt.readerFactory(writer2.finish());
    while (reader.pos < reader.len) {
      const [no, wireType] = reader.tag();
      const data = reader.skip(wireType, no);
      message.getType().runtime.bin.onUnknownField(message, no, wireType, data);
    }
  }
  function hasExtension(message, extension) {
    const messageType = message.getType();
    return extension.extendee.typeName === messageType.typeName && !!messageType.runtime.bin.listUnknownFields(message).find((uf) => uf.no == extension.field.no);
  }
  function assertExtendee(extension, message) {
    assert(extension.extendee.typeName == message.getType().typeName, "extension ".concat(extension.typeName, " can only be applied to message ").concat(extension.extendee.typeName));
  }
  function isFieldSet(field, target) {
    const localName = field.localName;
    if (field.repeated) {
      return target[localName].length > 0;
    }
    if (field.oneof) {
      return target[field.oneof.localName].case === localName;
    }
    switch (field.kind) {
      case "enum":
      case "scalar":
        if (field.opt || field.req) {
          return target[localName] !== void 0;
        }
        if (field.kind == "enum") {
          return target[localName] !== field.T.values[0].no;
        }
        return !isScalarZeroValue(field.T, target[localName]);
      case "message":
        return target[localName] !== void 0;
      case "map":
        return Object.keys(target[localName]).length > 0;
    }
  }
  function clearField(field, target) {
    const localName = field.localName;
    const implicitPresence = !field.opt && !field.req;
    if (field.repeated) {
      target[localName] = [];
    } else if (field.oneof) {
      target[field.oneof.localName] = {
        case: void 0
      };
    } else {
      switch (field.kind) {
        case "map":
          target[localName] = {};
          break;
        case "enum":
          target[localName] = implicitPresence ? field.T.values[0].no : void 0;
          break;
        case "scalar":
          target[localName] = implicitPresence ? scalarZeroValue(field.T, field.L) : void 0;
          break;
        case "message":
          target[localName] = void 0;
          break;
      }
    }
  }
  function isMessage(arg, type) {
    if (arg === null || typeof arg != "object") {
      return false;
    }
    if (!Object.getOwnPropertyNames(Message.prototype).every((m) => m in arg && typeof arg[m] == "function")) {
      return false;
    }
    const actualType = arg.getType();
    if (actualType === null || typeof actualType != "function" || !("typeName" in actualType) || typeof actualType.typeName != "string") {
      return false;
    }
    return type === void 0 ? true : actualType.typeName == type.typeName;
  }
  function wrapField(type, value) {
    if (isMessage(value) || !type.fieldWrapper) {
      return value;
    }
    return type.fieldWrapper.wrapField(value);
  }
  ({
    "google.protobuf.DoubleValue": ScalarType.DOUBLE,
    "google.protobuf.FloatValue": ScalarType.FLOAT,
    "google.protobuf.Int64Value": ScalarType.INT64,
    "google.protobuf.UInt64Value": ScalarType.UINT64,
    "google.protobuf.Int32Value": ScalarType.INT32,
    "google.protobuf.UInt32Value": ScalarType.UINT32,
    "google.protobuf.BoolValue": ScalarType.BOOL,
    "google.protobuf.StringValue": ScalarType.STRING,
    "google.protobuf.BytesValue": ScalarType.BYTES
  });
  var jsonReadDefaults = {
    ignoreUnknownFields: false
  };
  var jsonWriteDefaults = {
    emitDefaultValues: false,
    enumAsInteger: false,
    useProtoFieldName: false,
    prettySpaces: 0
  };
  function makeReadOptions$1(options) {
    return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;
  }
  function makeWriteOptions$1(options) {
    return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;
  }
  var tokenNull = Symbol();
  var tokenIgnoredUnknownEnum = Symbol();
  function makeJsonFormat() {
    return {
      makeReadOptions: makeReadOptions$1,
      makeWriteOptions: makeWriteOptions$1,
      readMessage(type, json, options, message) {
        if (json == null || Array.isArray(json) || typeof json != "object") {
          throw new Error("cannot decode message ".concat(type.typeName, " from JSON: ").concat(debugJsonValue(json)));
        }
        message = message !== null && message !== void 0 ? message : new type();
        const oneofSeen = /* @__PURE__ */ new Map();
        const registry = options.typeRegistry;
        for (const [jsonKey, jsonValue] of Object.entries(json)) {
          const field = type.fields.findJsonName(jsonKey);
          if (field) {
            if (field.oneof) {
              if (jsonValue === null && field.kind == "scalar") {
                continue;
              }
              const seen = oneofSeen.get(field.oneof);
              if (seen !== void 0) {
                throw new Error("cannot decode message ".concat(type.typeName, ' from JSON: multiple keys for oneof "').concat(field.oneof.name, '" present: "').concat(seen, '", "').concat(jsonKey, '"'));
              }
              oneofSeen.set(field.oneof, jsonKey);
            }
            readField$1(message, jsonValue, field, options, type);
          } else {
            let found = false;
            if ((registry === null || registry === void 0 ? void 0 : registry.findExtension) && jsonKey.startsWith("[") && jsonKey.endsWith("]")) {
              const ext = registry.findExtension(jsonKey.substring(1, jsonKey.length - 1));
              if (ext && ext.extendee.typeName == type.typeName) {
                found = true;
                const [container, get] = createExtensionContainer(ext);
                readField$1(container, jsonValue, ext.field, options, ext);
                setExtension(message, ext, get(), options);
              }
            }
            if (!found && !options.ignoreUnknownFields) {
              throw new Error("cannot decode message ".concat(type.typeName, ' from JSON: key "').concat(jsonKey, '" is unknown'));
            }
          }
        }
        return message;
      },
      writeMessage(message, options) {
        const type = message.getType();
        const json = {};
        let field;
        try {
          for (field of type.fields.byNumber()) {
            if (!isFieldSet(field, message)) {
              if (field.req) {
                throw "required field not set";
              }
              if (!options.emitDefaultValues) {
                continue;
              }
              if (!canEmitFieldDefaultValue(field)) {
                continue;
              }
            }
            const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];
            const jsonValue = writeField$1(field, value, options);
            if (jsonValue !== void 0) {
              json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
            }
          }
          const registry = options.typeRegistry;
          if (registry === null || registry === void 0 ? void 0 : registry.findExtensionFor) {
            for (const uf of type.runtime.bin.listUnknownFields(message)) {
              const ext = registry.findExtensionFor(type.typeName, uf.no);
              if (ext && hasExtension(message, ext)) {
                const value = getExtension(message, ext, options);
                const jsonValue = writeField$1(ext.field, value, options);
                if (jsonValue !== void 0) {
                  json[ext.field.jsonName] = jsonValue;
                }
              }
            }
          }
        } catch (e) {
          const m = field ? "cannot encode field ".concat(type.typeName, ".").concat(field.name, " to JSON") : "cannot encode message ".concat(type.typeName, " to JSON");
          const r2 = e instanceof Error ? e.message : String(e);
          throw new Error(m + (r2.length > 0 ? ": ".concat(r2) : ""));
        }
        return json;
      },
      readScalar(type, json, longType) {
        return readScalar$1(type, json, longType !== null && longType !== void 0 ? longType : LongType.BIGINT, true);
      },
      writeScalar(type, value, emitDefaultValues) {
        if (value === void 0) {
          return void 0;
        }
        if (emitDefaultValues || isScalarZeroValue(type, value)) {
          return writeScalar$1(type, value);
        }
        return void 0;
      },
      debug: debugJsonValue
    };
  }
  function debugJsonValue(json) {
    if (json === null) {
      return "null";
    }
    switch (typeof json) {
      case "object":
        return Array.isArray(json) ? "array" : "object";
      case "string":
        return json.length > 100 ? "string" : '"'.concat(json.split('"').join('\\"'), '"');
      default:
        return String(json);
    }
  }
  function readField$1(target, jsonValue, field, options, parentType) {
    let localName = field.localName;
    if (field.repeated) {
      assert(field.kind != "map");
      if (jsonValue === null) {
        return;
      }
      if (!Array.isArray(jsonValue)) {
        throw new Error("cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonValue)));
      }
      const targetArray = target[localName];
      for (const jsonItem of jsonValue) {
        if (jsonItem === null) {
          throw new Error("cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonItem)));
        }
        switch (field.kind) {
          case "message":
            targetArray.push(field.T.fromJson(jsonItem, options));
            break;
          case "enum":
            const enumValue = readEnum(field.T, jsonItem, options.ignoreUnknownFields, true);
            if (enumValue !== tokenIgnoredUnknownEnum) {
              targetArray.push(enumValue);
            }
            break;
          case "scalar":
            try {
              targetArray.push(readScalar$1(field.T, jsonItem, field.L, true));
            } catch (e) {
              let m = "cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonItem));
              if (e instanceof Error && e.message.length > 0) {
                m += ": ".concat(e.message);
              }
              throw new Error(m);
            }
            break;
        }
      }
    } else if (field.kind == "map") {
      if (jsonValue === null) {
        return;
      }
      if (typeof jsonValue != "object" || Array.isArray(jsonValue)) {
        throw new Error("cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonValue)));
      }
      const targetMap = target[localName];
      for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)) {
        if (jsonMapValue === null) {
          throw new Error("cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: map value null"));
        }
        let key;
        try {
          key = readMapKey(field.K, jsonMapKey);
        } catch (e) {
          let m = "cannot decode map key for field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonValue));
          if (e instanceof Error && e.message.length > 0) {
            m += ": ".concat(e.message);
          }
          throw new Error(m);
        }
        switch (field.V.kind) {
          case "message":
            targetMap[key] = field.V.T.fromJson(jsonMapValue, options);
            break;
          case "enum":
            const enumValue = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields, true);
            if (enumValue !== tokenIgnoredUnknownEnum) {
              targetMap[key] = enumValue;
            }
            break;
          case "scalar":
            try {
              targetMap[key] = readScalar$1(field.V.T, jsonMapValue, LongType.BIGINT, true);
            } catch (e) {
              let m = "cannot decode map value for field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonValue));
              if (e instanceof Error && e.message.length > 0) {
                m += ": ".concat(e.message);
              }
              throw new Error(m);
            }
            break;
        }
      }
    } else {
      if (field.oneof) {
        target = target[field.oneof.localName] = {
          case: localName
        };
        localName = "value";
      }
      switch (field.kind) {
        case "message":
          const messageType = field.T;
          if (jsonValue === null && messageType.typeName != "google.protobuf.Value") {
            return;
          }
          let currentValue = target[localName];
          if (isMessage(currentValue)) {
            currentValue.fromJson(jsonValue, options);
          } else {
            target[localName] = currentValue = messageType.fromJson(jsonValue, options);
            if (messageType.fieldWrapper && !field.oneof) {
              target[localName] = messageType.fieldWrapper.unwrapField(currentValue);
            }
          }
          break;
        case "enum":
          const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields, false);
          switch (enumValue) {
            case tokenNull:
              clearField(field, target);
              break;
            case tokenIgnoredUnknownEnum:
              break;
            default:
              target[localName] = enumValue;
              break;
          }
          break;
        case "scalar":
          try {
            const scalarValue = readScalar$1(field.T, jsonValue, field.L, false);
            switch (scalarValue) {
              case tokenNull:
                clearField(field, target);
                break;
              default:
                target[localName] = scalarValue;
                break;
            }
          } catch (e) {
            let m = "cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonValue));
            if (e instanceof Error && e.message.length > 0) {
              m += ": ".concat(e.message);
            }
            throw new Error(m);
          }
          break;
      }
    }
  }
  function readMapKey(type, json) {
    if (type === ScalarType.BOOL) {
      switch (json) {
        case "true":
          json = true;
          break;
        case "false":
          json = false;
          break;
      }
    }
    return readScalar$1(type, json, LongType.BIGINT, true).toString();
  }
  function readScalar$1(type, json, longType, nullAsZeroValue) {
    if (json === null) {
      if (nullAsZeroValue) {
        return scalarZeroValue(type, longType);
      }
      return tokenNull;
    }
    switch (type) {
      // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
      // Either numbers or strings are accepted. Exponent notation is also accepted.
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        if (json === "NaN") return Number.NaN;
        if (json === "Infinity") return Number.POSITIVE_INFINITY;
        if (json === "-Infinity") return Number.NEGATIVE_INFINITY;
        if (json === "") {
          break;
        }
        if (typeof json == "string" && json.trim().length !== json.length) {
          break;
        }
        if (typeof json != "string" && typeof json != "number") {
          break;
        }
        const float = Number(json);
        if (Number.isNaN(float)) {
          break;
        }
        if (!Number.isFinite(float)) {
          break;
        }
        if (type == ScalarType.FLOAT) assertFloat32(float);
        return float;
      // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.UINT32:
        let int32;
        if (typeof json == "number") int32 = json;
        else if (typeof json == "string" && json.length > 0) {
          if (json.trim().length === json.length) int32 = Number(json);
        }
        if (int32 === void 0) break;
        if (type == ScalarType.UINT32 || type == ScalarType.FIXED32) assertUInt32(int32);
        else assertInt32(int32);
        return int32;
      // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        if (typeof json != "number" && typeof json != "string") break;
        const long = protoInt64.parse(json);
        return longType ? long.toString() : long;
      case ScalarType.FIXED64:
      case ScalarType.UINT64:
        if (typeof json != "number" && typeof json != "string") break;
        const uLong = protoInt64.uParse(json);
        return longType ? uLong.toString() : uLong;
      // bool:
      case ScalarType.BOOL:
        if (typeof json !== "boolean") break;
        return json;
      // string:
      case ScalarType.STRING:
        if (typeof json !== "string") {
          break;
        }
        try {
          encodeURIComponent(json);
        } catch (e) {
          throw new Error("invalid UTF8");
        }
        return json;
      // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
      // Either standard or URL-safe base64 encoding with/without paddings are accepted.
      case ScalarType.BYTES:
        if (json === "") return new Uint8Array(0);
        if (typeof json !== "string") break;
        return protoBase64.dec(json);
    }
    throw new Error();
  }
  function readEnum(type, json, ignoreUnknownFields, nullAsZeroValue) {
    if (json === null) {
      if (type.typeName == "google.protobuf.NullValue") {
        return 0;
      }
      return nullAsZeroValue ? type.values[0].no : tokenNull;
    }
    switch (typeof json) {
      case "number":
        if (Number.isInteger(json)) {
          return json;
        }
        break;
      case "string":
        const value = type.findName(json);
        if (value !== void 0) {
          return value.no;
        }
        if (ignoreUnknownFields) {
          return tokenIgnoredUnknownEnum;
        }
        break;
    }
    throw new Error("cannot decode enum ".concat(type.typeName, " from JSON: ").concat(debugJsonValue(json)));
  }
  function canEmitFieldDefaultValue(field) {
    if (field.repeated || field.kind == "map") {
      return true;
    }
    if (field.oneof) {
      return false;
    }
    if (field.kind == "message") {
      return false;
    }
    if (field.opt || field.req) {
      return false;
    }
    return true;
  }
  function writeField$1(field, value, options) {
    if (field.kind == "map") {
      assert(typeof value == "object" && value != null);
      const jsonObj = {};
      const entries = Object.entries(value);
      switch (field.V.kind) {
        case "scalar":
          for (const [entryKey, entryValue] of entries) {
            jsonObj[entryKey.toString()] = writeScalar$1(field.V.T, entryValue);
          }
          break;
        case "message":
          for (const [entryKey, entryValue] of entries) {
            jsonObj[entryKey.toString()] = entryValue.toJson(options);
          }
          break;
        case "enum":
          const enumType = field.V.T;
          for (const [entryKey, entryValue] of entries) {
            jsonObj[entryKey.toString()] = writeEnum(enumType, entryValue, options.enumAsInteger);
          }
          break;
      }
      return options.emitDefaultValues || entries.length > 0 ? jsonObj : void 0;
    }
    if (field.repeated) {
      assert(Array.isArray(value));
      const jsonArr = [];
      switch (field.kind) {
        case "scalar":
          for (let i = 0; i < value.length; i++) {
            jsonArr.push(writeScalar$1(field.T, value[i]));
          }
          break;
        case "enum":
          for (let i = 0; i < value.length; i++) {
            jsonArr.push(writeEnum(field.T, value[i], options.enumAsInteger));
          }
          break;
        case "message":
          for (let i = 0; i < value.length; i++) {
            jsonArr.push(value[i].toJson(options));
          }
          break;
      }
      return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : void 0;
    }
    switch (field.kind) {
      case "scalar":
        return writeScalar$1(field.T, value);
      case "enum":
        return writeEnum(field.T, value, options.enumAsInteger);
      case "message":
        return wrapField(field.T, value).toJson(options);
    }
  }
  function writeEnum(type, value, enumAsInteger) {
    var _a;
    assert(typeof value == "number");
    if (type.typeName == "google.protobuf.NullValue") {
      return null;
    }
    if (enumAsInteger) {
      return value;
    }
    const val = type.findNumber(value);
    return (_a = val === null || val === void 0 ? void 0 : val.name) !== null && _a !== void 0 ? _a : value;
  }
  function writeScalar$1(type, value) {
    switch (type) {
      // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
      case ScalarType.INT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
        assert(typeof value == "number");
        return value;
      // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
      // Either numbers or strings are accepted. Exponent notation is also accepted.
      case ScalarType.FLOAT:
      // assertFloat32(value);
      case ScalarType.DOUBLE:
        assert(typeof value == "number");
        if (Number.isNaN(value)) return "NaN";
        if (value === Number.POSITIVE_INFINITY) return "Infinity";
        if (value === Number.NEGATIVE_INFINITY) return "-Infinity";
        return value;
      // string:
      case ScalarType.STRING:
        assert(typeof value == "string");
        return value;
      // bool:
      case ScalarType.BOOL:
        assert(typeof value == "boolean");
        return value;
      // JSON value will be a decimal string. Either numbers or strings are accepted.
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        assert(typeof value == "bigint" || typeof value == "string" || typeof value == "number");
        return value.toString();
      // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
      // Either standard or URL-safe base64 encoding with/without paddings are accepted.
      case ScalarType.BYTES:
        assert(value instanceof Uint8Array);
        return protoBase64.enc(value);
    }
  }
  var unknownFieldsSymbol = Symbol("@bufbuild/protobuf/unknown-fields");
  var readDefaults = {
    readUnknownFields: true,
    readerFactory: (bytes) => new BinaryReader(bytes)
  };
  var writeDefaults = {
    writeUnknownFields: true,
    writerFactory: () => new BinaryWriter()
  };
  function makeReadOptions(options) {
    return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;
  }
  function makeWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;
  }
  function makeBinaryFormat() {
    return {
      makeReadOptions,
      makeWriteOptions,
      listUnknownFields(message) {
        var _a;
        return (_a = message[unknownFieldsSymbol]) !== null && _a !== void 0 ? _a : [];
      },
      discardUnknownFields(message) {
        delete message[unknownFieldsSymbol];
      },
      writeUnknownFields(message, writer2) {
        const m = message;
        const c = m[unknownFieldsSymbol];
        if (c) {
          for (const f of c) {
            writer2.tag(f.no, f.wireType).raw(f.data);
          }
        }
      },
      onUnknownField(message, no, wireType, data) {
        const m = message;
        if (!Array.isArray(m[unknownFieldsSymbol])) {
          m[unknownFieldsSymbol] = [];
        }
        m[unknownFieldsSymbol].push({
          no,
          wireType,
          data
        });
      },
      readMessage(message, reader, lengthOrEndTagFieldNo, options, delimitedMessageEncoding) {
        const type = message.getType();
        const end = delimitedMessageEncoding ? reader.len : reader.pos + lengthOrEndTagFieldNo;
        let fieldNo, wireType;
        while (reader.pos < end) {
          [fieldNo, wireType] = reader.tag();
          if (delimitedMessageEncoding === true && wireType == WireType.EndGroup) {
            break;
          }
          const field = type.fields.find(fieldNo);
          if (!field) {
            const data = reader.skip(wireType, fieldNo);
            if (options.readUnknownFields) {
              this.onUnknownField(message, fieldNo, wireType, data);
            }
            continue;
          }
          readField(message, reader, field, wireType, options);
        }
        if (delimitedMessageEncoding && // eslint-disable-line @typescript-eslint/strict-boolean-expressions
        (wireType != WireType.EndGroup || fieldNo !== lengthOrEndTagFieldNo)) {
          throw new Error("invalid end group tag");
        }
      },
      readField,
      writeMessage(message, writer2, options) {
        const type = message.getType();
        for (const field of type.fields.byNumber()) {
          if (!isFieldSet(field, message)) {
            if (field.req) {
              throw new Error("cannot encode field ".concat(type.typeName, ".").concat(field.name, " to binary: required field not set"));
            }
            continue;
          }
          const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];
          writeField(field, value, writer2, options);
        }
        if (options.writeUnknownFields) {
          this.writeUnknownFields(message, writer2);
        }
        return writer2;
      },
      writeField(field, value, writer2, options) {
        if (value === void 0) {
          return void 0;
        }
        writeField(field, value, writer2, options);
      }
    };
  }
  function readField(target, reader, field, wireType, options) {
    let {
      repeated,
      localName
    } = field;
    if (field.oneof) {
      target = target[field.oneof.localName];
      if (target.case != localName) {
        delete target.value;
      }
      target.case = localName;
      localName = "value";
    }
    switch (field.kind) {
      case "scalar":
      case "enum":
        const scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
        let read = readScalar;
        if (field.kind == "scalar" && field.L > 0) {
          read = readScalarLTString;
        }
        if (repeated) {
          let arr = target[localName];
          const isPacked = wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES;
          if (isPacked) {
            let e = reader.uint32() + reader.pos;
            while (reader.pos < e) {
              arr.push(read(reader, scalarType));
            }
          } else {
            arr.push(read(reader, scalarType));
          }
        } else {
          target[localName] = read(reader, scalarType);
        }
        break;
      case "message":
        const messageType = field.T;
        if (repeated) {
          target[localName].push(readMessageField(reader, new messageType(), options, field));
        } else {
          if (isMessage(target[localName])) {
            readMessageField(reader, target[localName], options, field);
          } else {
            target[localName] = readMessageField(reader, new messageType(), options, field);
            if (messageType.fieldWrapper && !field.oneof && !field.repeated) {
              target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);
            }
          }
        }
        break;
      case "map":
        let [mapKey, mapVal] = readMapEntry(field, reader, options);
        target[localName][mapKey] = mapVal;
        break;
    }
  }
  function readMessageField(reader, message, options, field) {
    const format = message.getType().runtime.bin;
    const delimited = field === null || field === void 0 ? void 0 : field.delimited;
    format.readMessage(
      message,
      reader,
      delimited ? field.no : reader.uint32(),
      // eslint-disable-line @typescript-eslint/strict-boolean-expressions
      options,
      delimited
    );
    return message;
  }
  function readMapEntry(field, reader, options) {
    const length = reader.uint32(), end = reader.pos + length;
    let key, val;
    while (reader.pos < end) {
      const [fieldNo] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = readScalar(reader, field.K);
          break;
        case 2:
          switch (field.V.kind) {
            case "scalar":
              val = readScalar(reader, field.V.T);
              break;
            case "enum":
              val = reader.int32();
              break;
            case "message":
              val = readMessageField(reader, new field.V.T(), options, void 0);
              break;
          }
          break;
      }
    }
    if (key === void 0) {
      key = scalarZeroValue(field.K, LongType.BIGINT);
    }
    if (typeof key != "string" && typeof key != "number") {
      key = key.toString();
    }
    if (val === void 0) {
      switch (field.V.kind) {
        case "scalar":
          val = scalarZeroValue(field.V.T, LongType.BIGINT);
          break;
        case "enum":
          val = field.V.T.values[0].no;
          break;
        case "message":
          val = new field.V.T();
          break;
      }
    }
    return [key, val];
  }
  function readScalarLTString(reader, type) {
    const v = readScalar(reader, type);
    return typeof v == "bigint" ? v.toString() : v;
  }
  function readScalar(reader, type) {
    switch (type) {
      case ScalarType.STRING:
        return reader.string();
      case ScalarType.BOOL:
        return reader.bool();
      case ScalarType.DOUBLE:
        return reader.double();
      case ScalarType.FLOAT:
        return reader.float();
      case ScalarType.INT32:
        return reader.int32();
      case ScalarType.INT64:
        return reader.int64();
      case ScalarType.UINT64:
        return reader.uint64();
      case ScalarType.FIXED64:
        return reader.fixed64();
      case ScalarType.BYTES:
        return reader.bytes();
      case ScalarType.FIXED32:
        return reader.fixed32();
      case ScalarType.SFIXED32:
        return reader.sfixed32();
      case ScalarType.SFIXED64:
        return reader.sfixed64();
      case ScalarType.SINT64:
        return reader.sint64();
      case ScalarType.UINT32:
        return reader.uint32();
      case ScalarType.SINT32:
        return reader.sint32();
    }
  }
  function writeField(field, value, writer2, options) {
    assert(value !== void 0);
    const repeated = field.repeated;
    switch (field.kind) {
      case "scalar":
      case "enum":
        let scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
        if (repeated) {
          assert(Array.isArray(value));
          if (field.packed) {
            writePacked(writer2, scalarType, field.no, value);
          } else {
            for (const item of value) {
              writeScalar(writer2, scalarType, field.no, item);
            }
          }
        } else {
          writeScalar(writer2, scalarType, field.no, value);
        }
        break;
      case "message":
        if (repeated) {
          assert(Array.isArray(value));
          for (const item of value) {
            writeMessageField(writer2, options, field, item);
          }
        } else {
          writeMessageField(writer2, options, field, value);
        }
        break;
      case "map":
        assert(typeof value == "object" && value != null);
        for (const [key, val] of Object.entries(value)) {
          writeMapEntry(writer2, options, field, key, val);
        }
        break;
    }
  }
  function writeMapEntry(writer2, options, field, key, value) {
    writer2.tag(field.no, WireType.LengthDelimited);
    writer2.fork();
    let keyValue = key;
    switch (field.K) {
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
        keyValue = Number.parseInt(key);
        break;
      case ScalarType.BOOL:
        assert(key == "true" || key == "false");
        keyValue = key == "true";
        break;
    }
    writeScalar(writer2, field.K, 1, keyValue);
    switch (field.V.kind) {
      case "scalar":
        writeScalar(writer2, field.V.T, 2, value);
        break;
      case "enum":
        writeScalar(writer2, ScalarType.INT32, 2, value);
        break;
      case "message":
        assert(value !== void 0);
        writer2.tag(2, WireType.LengthDelimited).bytes(value.toBinary(options));
        break;
    }
    writer2.join();
  }
  function writeMessageField(writer2, options, field, value) {
    const message = wrapField(field.T, value);
    if (field.delimited) writer2.tag(field.no, WireType.StartGroup).raw(message.toBinary(options)).tag(field.no, WireType.EndGroup);
    else writer2.tag(field.no, WireType.LengthDelimited).bytes(message.toBinary(options));
  }
  function writeScalar(writer2, type, fieldNo, value) {
    assert(value !== void 0);
    let [wireType, method] = scalarTypeInfo(type);
    writer2.tag(fieldNo, wireType)[method](value);
  }
  function writePacked(writer2, type, fieldNo, value) {
    if (!value.length) {
      return;
    }
    writer2.tag(fieldNo, WireType.LengthDelimited).fork();
    let [, method] = scalarTypeInfo(type);
    for (let i = 0; i < value.length; i++) {
      writer2[method](value[i]);
    }
    writer2.join();
  }
  function scalarTypeInfo(type) {
    let wireType = WireType.Varint;
    switch (type) {
      case ScalarType.BYTES:
      case ScalarType.STRING:
        wireType = WireType.LengthDelimited;
        break;
      case ScalarType.DOUBLE:
      case ScalarType.FIXED64:
      case ScalarType.SFIXED64:
        wireType = WireType.Bit64;
        break;
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.FLOAT:
        wireType = WireType.Bit32;
        break;
    }
    const method = ScalarType[type].toLowerCase();
    return [wireType, method];
  }
  function makeUtilCommon() {
    return {
      setEnumType,
      initPartial(source, target) {
        if (source === void 0) {
          return;
        }
        const type = target.getType();
        for (const member of type.fields.byMember()) {
          const localName = member.localName, t = target, s = source;
          if (s[localName] == null) {
            continue;
          }
          switch (member.kind) {
            case "oneof":
              const sk = s[localName].case;
              if (sk === void 0) {
                continue;
              }
              const sourceField = member.findField(sk);
              let val = s[localName].value;
              if (sourceField && sourceField.kind == "message" && !isMessage(val, sourceField.T)) {
                val = new sourceField.T(val);
              } else if (sourceField && sourceField.kind === "scalar" && sourceField.T === ScalarType.BYTES) {
                val = toU8Arr(val);
              }
              t[localName] = {
                case: sk,
                value: val
              };
              break;
            case "scalar":
            case "enum":
              let copy = s[localName];
              if (member.T === ScalarType.BYTES) {
                copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);
              }
              t[localName] = copy;
              break;
            case "map":
              switch (member.V.kind) {
                case "scalar":
                case "enum":
                  if (member.V.T === ScalarType.BYTES) {
                    for (const [k2, v] of Object.entries(s[localName])) {
                      t[localName][k2] = toU8Arr(v);
                    }
                  } else {
                    Object.assign(t[localName], s[localName]);
                  }
                  break;
                case "message":
                  const messageType = member.V.T;
                  for (const k2 of Object.keys(s[localName])) {
                    let val2 = s[localName][k2];
                    if (!messageType.fieldWrapper) {
                      val2 = new messageType(val2);
                    }
                    t[localName][k2] = val2;
                  }
                  break;
              }
              break;
            case "message":
              const mt = member.T;
              if (member.repeated) {
                t[localName] = s[localName].map((val2) => isMessage(val2, mt) ? val2 : new mt(val2));
              } else {
                const val2 = s[localName];
                if (mt.fieldWrapper) {
                  if (
                    // We can't use BytesValue.typeName as that will create a circular import
                    mt.typeName === "google.protobuf.BytesValue"
                  ) {
                    t[localName] = toU8Arr(val2);
                  } else {
                    t[localName] = val2;
                  }
                } else {
                  t[localName] = isMessage(val2, mt) ? val2 : new mt(val2);
                }
              }
              break;
          }
        }
      },
      // TODO use isFieldSet() here to support future field presence
      equals(type, a, b) {
        if (a === b) {
          return true;
        }
        if (!a || !b) {
          return false;
        }
        return type.fields.byMember().every((m) => {
          const va = a[m.localName];
          const vb = b[m.localName];
          if (m.repeated) {
            if (va.length !== vb.length) {
              return false;
            }
            switch (m.kind) {
              case "message":
                return va.every((a2, i) => m.T.equals(a2, vb[i]));
              case "scalar":
                return va.every((a2, i) => scalarEquals(m.T, a2, vb[i]));
              case "enum":
                return va.every((a2, i) => scalarEquals(ScalarType.INT32, a2, vb[i]));
            }
            throw new Error("repeated cannot contain ".concat(m.kind));
          }
          switch (m.kind) {
            case "message":
              return m.T.equals(va, vb);
            case "enum":
              return scalarEquals(ScalarType.INT32, va, vb);
            case "scalar":
              return scalarEquals(m.T, va, vb);
            case "oneof":
              if (va.case !== vb.case) {
                return false;
              }
              const s = m.findField(va.case);
              if (s === void 0) {
                return true;
              }
              switch (s.kind) {
                case "message":
                  return s.T.equals(va.value, vb.value);
                case "enum":
                  return scalarEquals(ScalarType.INT32, va.value, vb.value);
                case "scalar":
                  return scalarEquals(s.T, va.value, vb.value);
              }
              throw new Error("oneof cannot contain ".concat(s.kind));
            case "map":
              const keys = Object.keys(va).concat(Object.keys(vb));
              switch (m.V.kind) {
                case "message":
                  const messageType = m.V.T;
                  return keys.every((k2) => messageType.equals(va[k2], vb[k2]));
                case "enum":
                  return keys.every((k2) => scalarEquals(ScalarType.INT32, va[k2], vb[k2]));
                case "scalar":
                  const scalarType = m.V.T;
                  return keys.every((k2) => scalarEquals(scalarType, va[k2], vb[k2]));
              }
              break;
          }
        });
      },
      // TODO use isFieldSet() here to support future field presence
      clone(message) {
        const type = message.getType(), target = new type(), any = target;
        for (const member of type.fields.byMember()) {
          const source = message[member.localName];
          let copy;
          if (member.repeated) {
            copy = source.map(cloneSingularField);
          } else if (member.kind == "map") {
            copy = any[member.localName];
            for (const [key, v] of Object.entries(source)) {
              copy[key] = cloneSingularField(v);
            }
          } else if (member.kind == "oneof") {
            const f = member.findField(source.case);
            copy = f ? {
              case: source.case,
              value: cloneSingularField(source.value)
            } : {
              case: void 0
            };
          } else {
            copy = cloneSingularField(source);
          }
          any[member.localName] = copy;
        }
        for (const uf of type.runtime.bin.listUnknownFields(message)) {
          type.runtime.bin.onUnknownField(any, uf.no, uf.wireType, uf.data);
        }
        return target;
      }
    };
  }
  function cloneSingularField(value) {
    if (value === void 0) {
      return value;
    }
    if (isMessage(value)) {
      return value.clone();
    }
    if (value instanceof Uint8Array) {
      const c = new Uint8Array(value.byteLength);
      c.set(value);
      return c;
    }
    return value;
  }
  function toU8Arr(input) {
    return input instanceof Uint8Array ? input : new Uint8Array(input);
  }
  function makeProtoRuntime(syntax, newFieldList, initFields) {
    return {
      syntax,
      json: makeJsonFormat(),
      bin: makeBinaryFormat(),
      util: Object.assign(Object.assign({}, makeUtilCommon()), {
        newFieldList,
        initFields
      }),
      makeMessageType(typeName, fields, opt) {
        return makeMessageType(this, typeName, fields, opt);
      },
      makeEnum,
      makeEnumType,
      getEnumType,
      makeExtension(typeName, extendee, field) {
        return makeExtension(this, typeName, extendee, field);
      }
    };
  }
  var InternalFieldList = class {
    constructor(fields, normalizer) {
      this._fields = fields;
      this._normalizer = normalizer;
    }
    findJsonName(jsonName) {
      if (!this.jsonNames) {
        const t = {};
        for (const f of this.list()) {
          t[f.jsonName] = t[f.name] = f;
        }
        this.jsonNames = t;
      }
      return this.jsonNames[jsonName];
    }
    find(fieldNo) {
      if (!this.numbers) {
        const t = {};
        for (const f of this.list()) {
          t[f.no] = f;
        }
        this.numbers = t;
      }
      return this.numbers[fieldNo];
    }
    list() {
      if (!this.all) {
        this.all = this._normalizer(this._fields);
      }
      return this.all;
    }
    byNumber() {
      if (!this.numbersAsc) {
        this.numbersAsc = this.list().concat().sort((a, b) => a.no - b.no);
      }
      return this.numbersAsc;
    }
    byMember() {
      if (!this.members) {
        this.members = [];
        const a = this.members;
        let o;
        for (const f of this.list()) {
          if (f.oneof) {
            if (f.oneof !== o) {
              o = f.oneof;
              a.push(o);
            }
          } else {
            a.push(f);
          }
        }
      }
      return this.members;
    }
  };
  function localFieldName(protoName, inOneof) {
    const name = protoCamelCase(protoName);
    if (inOneof) {
      return name;
    }
    return safeObjectProperty(safeMessageProperty(name));
  }
  function localOneofName(protoName) {
    return localFieldName(protoName, false);
  }
  var fieldJsonName = protoCamelCase;
  function protoCamelCase(snakeCase) {
    let capNext = false;
    const b = [];
    for (let i = 0; i < snakeCase.length; i++) {
      let c = snakeCase.charAt(i);
      switch (c) {
        case "_":
          capNext = true;
          break;
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          b.push(c);
          capNext = false;
          break;
        default:
          if (capNext) {
            capNext = false;
            c = c.toUpperCase();
          }
          b.push(c);
          break;
      }
    }
    return b.join("");
  }
  var reservedObjectProperties = /* @__PURE__ */ new Set([
    // names reserved by JavaScript
    "constructor",
    "toString",
    "toJSON",
    "valueOf"
  ]);
  var reservedMessageProperties = /* @__PURE__ */ new Set([
    // names reserved by the runtime
    "getType",
    "clone",
    "equals",
    "fromBinary",
    "fromJson",
    "fromJsonString",
    "toBinary",
    "toJson",
    "toJsonString",
    // names reserved by the runtime for the future
    "toObject"
  ]);
  var fallback = (name) => "".concat(name, "$");
  var safeMessageProperty = (name) => {
    if (reservedMessageProperties.has(name)) {
      return fallback(name);
    }
    return name;
  };
  var safeObjectProperty = (name) => {
    if (reservedObjectProperties.has(name)) {
      return fallback(name);
    }
    return name;
  };
  var InternalOneofInfo = class {
    constructor(name) {
      this.kind = "oneof";
      this.repeated = false;
      this.packed = false;
      this.opt = false;
      this.req = false;
      this.default = void 0;
      this.fields = [];
      this.name = name;
      this.localName = localOneofName(name);
    }
    addField(field) {
      assert(field.oneof === this, "field ".concat(field.name, " not one of ").concat(this.name));
      this.fields.push(field);
    }
    findField(localName) {
      if (!this._lookup) {
        this._lookup = /* @__PURE__ */ Object.create(null);
        for (let i = 0; i < this.fields.length; i++) {
          this._lookup[this.fields[i].localName] = this.fields[i];
        }
      }
      return this._lookup[localName];
    }
  };
  function normalizeFieldInfos(fieldInfos, packedByDefault) {
    var _a, _b, _c, _d, _e, _f;
    const r2 = [];
    let o;
    for (const field of typeof fieldInfos == "function" ? fieldInfos() : fieldInfos) {
      const f = field;
      f.localName = localFieldName(field.name, field.oneof !== void 0);
      f.jsonName = (_a = field.jsonName) !== null && _a !== void 0 ? _a : fieldJsonName(field.name);
      f.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;
      if (field.kind == "scalar") {
        f.L = (_c = field.L) !== null && _c !== void 0 ? _c : LongType.BIGINT;
      }
      f.delimited = (_d = field.delimited) !== null && _d !== void 0 ? _d : false;
      f.req = (_e = field.req) !== null && _e !== void 0 ? _e : false;
      f.opt = (_f = field.opt) !== null && _f !== void 0 ? _f : false;
      if (field.packed === void 0) {
        {
          f.packed = field.kind == "enum" || field.kind == "scalar" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;
        }
      }
      if (field.oneof !== void 0) {
        const ooname = typeof field.oneof == "string" ? field.oneof : field.oneof.name;
        if (!o || o.name != ooname) {
          o = new InternalOneofInfo(ooname);
        }
        f.oneof = o;
        o.addField(f);
      }
      r2.push(f);
    }
    return r2;
  }
  var proto3 = makeProtoRuntime(
    "proto3",
    (fields) => {
      return new InternalFieldList(fields, (source) => normalizeFieldInfos(source));
    },
    // TODO merge with proto2 and initExtensionField, also see initPartial, equals, clone
    (target) => {
      for (const member of target.getType().fields.byMember()) {
        if (member.opt) {
          continue;
        }
        const name = member.localName, t = target;
        if (member.repeated) {
          t[name] = [];
          continue;
        }
        switch (member.kind) {
          case "oneof":
            t[name] = {
              case: void 0
            };
            break;
          case "enum":
            t[name] = 0;
            break;
          case "map":
            t[name] = {};
            break;
          case "scalar":
            t[name] = scalarZeroValue(member.T, member.L);
            break;
        }
      }
    }
  );
  var Timestamp = class _Timestamp extends Message {
    constructor(data) {
      super();
      this.seconds = protoInt64.zero;
      this.nanos = 0;
      proto3.util.initPartial(data, this);
    }
    fromJson(json, options) {
      if (typeof json !== "string") {
        throw new Error("cannot decode google.protobuf.Timestamp from JSON: ".concat(proto3.json.debug(json)));
      }
      const matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
      if (!matches) {
        throw new Error("cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string");
      }
      const ms = Date.parse(matches[1] + "-" + matches[2] + "-" + matches[3] + "T" + matches[4] + ":" + matches[5] + ":" + matches[6] + (matches[8] ? matches[8] : "Z"));
      if (Number.isNaN(ms)) {
        throw new Error("cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string");
      }
      if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) {
        throw new Error("cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive");
      }
      this.seconds = protoInt64.parse(ms / 1e3);
      this.nanos = 0;
      if (matches[7]) {
        this.nanos = parseInt("1" + matches[7] + "0".repeat(9 - matches[7].length)) - 1e9;
      }
      return this;
    }
    toJson(options) {
      const ms = Number(this.seconds) * 1e3;
      if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) {
        throw new Error("cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive");
      }
      if (this.nanos < 0) {
        throw new Error("cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative");
      }
      let z = "Z";
      if (this.nanos > 0) {
        const nanosStr = (this.nanos + 1e9).toString().substring(1);
        if (nanosStr.substring(3) === "000000") {
          z = "." + nanosStr.substring(0, 3) + "Z";
        } else if (nanosStr.substring(6) === "000") {
          z = "." + nanosStr.substring(0, 6) + "Z";
        } else {
          z = "." + nanosStr + "Z";
        }
      }
      return new Date(ms).toISOString().replace(".000Z", z);
    }
    toDate() {
      return new Date(Number(this.seconds) * 1e3 + Math.ceil(this.nanos / 1e6));
    }
    static now() {
      return _Timestamp.fromDate(/* @__PURE__ */ new Date());
    }
    static fromDate(date) {
      const ms = date.getTime();
      return new _Timestamp({
        seconds: protoInt64.parse(Math.floor(ms / 1e3)),
        nanos: ms % 1e3 * 1e6
      });
    }
    static fromBinary(bytes, options) {
      return new _Timestamp().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new _Timestamp().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new _Timestamp().fromJsonString(jsonString, options);
    }
    static equals(a, b) {
      return proto3.util.equals(_Timestamp, a, b);
    }
  };
  Timestamp.runtime = proto3;
  Timestamp.typeName = "google.protobuf.Timestamp";
  Timestamp.fields = proto3.util.newFieldList(() => [{
    no: 1,
    name: "seconds",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 2,
    name: "nanos",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }]);
  var MetricsBatch = /* @__PURE__ */ proto3.makeMessageType("livekit.MetricsBatch", () => [{
    no: 1,
    name: "timestamp_ms",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 2,
    name: "normalized_timestamp",
    kind: "message",
    T: Timestamp
  }, {
    no: 3,
    name: "str_data",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 4,
    name: "time_series",
    kind: "message",
    T: TimeSeriesMetric,
    repeated: true
  }, {
    no: 5,
    name: "events",
    kind: "message",
    T: EventMetric,
    repeated: true
  }]);
  var TimeSeriesMetric = /* @__PURE__ */ proto3.makeMessageType("livekit.TimeSeriesMetric", () => [{
    no: 1,
    name: "label",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 2,
    name: "participant_identity",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 3,
    name: "track_sid",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 4,
    name: "samples",
    kind: "message",
    T: MetricSample,
    repeated: true
  }, {
    no: 5,
    name: "rid",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }]);
  var MetricSample = /* @__PURE__ */ proto3.makeMessageType("livekit.MetricSample", () => [{
    no: 1,
    name: "timestamp_ms",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 2,
    name: "normalized_timestamp",
    kind: "message",
    T: Timestamp
  }, {
    no: 3,
    name: "value",
    kind: "scalar",
    T: 2
    /* ScalarType.FLOAT */
  }]);
  var EventMetric = /* @__PURE__ */ proto3.makeMessageType("livekit.EventMetric", () => [{
    no: 1,
    name: "label",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 2,
    name: "participant_identity",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 3,
    name: "track_sid",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 4,
    name: "start_timestamp_ms",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 5,
    name: "end_timestamp_ms",
    kind: "scalar",
    T: 3,
    opt: true
  }, {
    no: 6,
    name: "normalized_start_timestamp",
    kind: "message",
    T: Timestamp
  }, {
    no: 7,
    name: "normalized_end_timestamp",
    kind: "message",
    T: Timestamp,
    opt: true
  }, {
    no: 8,
    name: "metadata",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 9,
    name: "rid",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }]);
  var TrackType = /* @__PURE__ */ proto3.makeEnum("livekit.TrackType", [{
    no: 0,
    name: "AUDIO"
  }, {
    no: 1,
    name: "VIDEO"
  }, {
    no: 2,
    name: "DATA"
  }]);
  var TrackSource = /* @__PURE__ */ proto3.makeEnum("livekit.TrackSource", [{
    no: 0,
    name: "UNKNOWN"
  }, {
    no: 1,
    name: "CAMERA"
  }, {
    no: 2,
    name: "MICROPHONE"
  }, {
    no: 3,
    name: "SCREEN_SHARE"
  }, {
    no: 4,
    name: "SCREEN_SHARE_AUDIO"
  }]);
  var VideoQuality$1 = /* @__PURE__ */ proto3.makeEnum("livekit.VideoQuality", [{
    no: 0,
    name: "LOW"
  }, {
    no: 1,
    name: "MEDIUM"
  }, {
    no: 2,
    name: "HIGH"
  }, {
    no: 3,
    name: "OFF"
  }]);
  var ConnectionQuality$1 = /* @__PURE__ */ proto3.makeEnum("livekit.ConnectionQuality", [{
    no: 0,
    name: "POOR"
  }, {
    no: 1,
    name: "GOOD"
  }, {
    no: 2,
    name: "EXCELLENT"
  }, {
    no: 3,
    name: "LOST"
  }]);
  var ClientConfigSetting = /* @__PURE__ */ proto3.makeEnum("livekit.ClientConfigSetting", [{
    no: 0,
    name: "UNSET"
  }, {
    no: 1,
    name: "DISABLED"
  }, {
    no: 2,
    name: "ENABLED"
  }]);
  var DisconnectReason = /* @__PURE__ */ proto3.makeEnum("livekit.DisconnectReason", [{
    no: 0,
    name: "UNKNOWN_REASON"
  }, {
    no: 1,
    name: "CLIENT_INITIATED"
  }, {
    no: 2,
    name: "DUPLICATE_IDENTITY"
  }, {
    no: 3,
    name: "SERVER_SHUTDOWN"
  }, {
    no: 4,
    name: "PARTICIPANT_REMOVED"
  }, {
    no: 5,
    name: "ROOM_DELETED"
  }, {
    no: 6,
    name: "STATE_MISMATCH"
  }, {
    no: 7,
    name: "JOIN_FAILURE"
  }, {
    no: 8,
    name: "MIGRATION"
  }, {
    no: 9,
    name: "SIGNAL_CLOSE"
  }, {
    no: 10,
    name: "ROOM_CLOSED"
  }, {
    no: 11,
    name: "USER_UNAVAILABLE"
  }, {
    no: 12,
    name: "USER_REJECTED"
  }, {
    no: 13,
    name: "SIP_TRUNK_FAILURE"
  }]);
  var ReconnectReason = /* @__PURE__ */ proto3.makeEnum("livekit.ReconnectReason", [{
    no: 0,
    name: "RR_UNKNOWN"
  }, {
    no: 1,
    name: "RR_SIGNAL_DISCONNECTED"
  }, {
    no: 2,
    name: "RR_PUBLISHER_FAILED"
  }, {
    no: 3,
    name: "RR_SUBSCRIBER_FAILED"
  }, {
    no: 4,
    name: "RR_SWITCH_CANDIDATE"
  }]);
  var SubscriptionError = /* @__PURE__ */ proto3.makeEnum("livekit.SubscriptionError", [{
    no: 0,
    name: "SE_UNKNOWN"
  }, {
    no: 1,
    name: "SE_CODEC_UNSUPPORTED"
  }, {
    no: 2,
    name: "SE_TRACK_NOTFOUND"
  }]);
  var AudioTrackFeature = /* @__PURE__ */ proto3.makeEnum("livekit.AudioTrackFeature", [{
    no: 0,
    name: "TF_STEREO"
  }, {
    no: 1,
    name: "TF_NO_DTX"
  }, {
    no: 2,
    name: "TF_AUTO_GAIN_CONTROL"
  }, {
    no: 3,
    name: "TF_ECHO_CANCELLATION"
  }, {
    no: 4,
    name: "TF_NOISE_SUPPRESSION"
  }, {
    no: 5,
    name: "TF_ENHANCED_NOISE_CANCELLATION"
  }]);
  var Room$1 = /* @__PURE__ */ proto3.makeMessageType("livekit.Room", () => [{
    no: 1,
    name: "sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "empty_timeout",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 14,
    name: "departure_timeout",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 4,
    name: "max_participants",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 5,
    name: "creation_time",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 6,
    name: "turn_password",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 7,
    name: "enabled_codecs",
    kind: "message",
    T: Codec,
    repeated: true
  }, {
    no: 8,
    name: "metadata",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 9,
    name: "num_participants",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 11,
    name: "num_publishers",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 10,
    name: "active_recording",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 13,
    name: "version",
    kind: "message",
    T: TimedVersion
  }]);
  var Codec = /* @__PURE__ */ proto3.makeMessageType("livekit.Codec", () => [{
    no: 1,
    name: "mime",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "fmtp_line",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  var ParticipantPermission = /* @__PURE__ */ proto3.makeMessageType("livekit.ParticipantPermission", () => [{
    no: 1,
    name: "can_subscribe",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 2,
    name: "can_publish",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 3,
    name: "can_publish_data",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 9,
    name: "can_publish_sources",
    kind: "enum",
    T: proto3.getEnumType(TrackSource),
    repeated: true
  }, {
    no: 7,
    name: "hidden",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 8,
    name: "recorder",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 10,
    name: "can_update_metadata",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 11,
    name: "agent",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 12,
    name: "can_subscribe_metrics",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }]);
  var ParticipantInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.ParticipantInfo", () => [{
    no: 1,
    name: "sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "identity",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "state",
    kind: "enum",
    T: proto3.getEnumType(ParticipantInfo_State)
  }, {
    no: 4,
    name: "tracks",
    kind: "message",
    T: TrackInfo,
    repeated: true
  }, {
    no: 5,
    name: "metadata",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 6,
    name: "joined_at",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 9,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 10,
    name: "version",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 11,
    name: "permission",
    kind: "message",
    T: ParticipantPermission
  }, {
    no: 12,
    name: "region",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 13,
    name: "is_publisher",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 14,
    name: "kind",
    kind: "enum",
    T: proto3.getEnumType(ParticipantInfo_Kind)
  }, {
    no: 15,
    name: "attributes",
    kind: "map",
    K: 9,
    V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  }, {
    no: 16,
    name: "disconnect_reason",
    kind: "enum",
    T: proto3.getEnumType(DisconnectReason)
  }]);
  var ParticipantInfo_State = /* @__PURE__ */ proto3.makeEnum("livekit.ParticipantInfo.State", [{
    no: 0,
    name: "JOINING"
  }, {
    no: 1,
    name: "JOINED"
  }, {
    no: 2,
    name: "ACTIVE"
  }, {
    no: 3,
    name: "DISCONNECTED"
  }]);
  var ParticipantInfo_Kind = /* @__PURE__ */ proto3.makeEnum("livekit.ParticipantInfo.Kind", [{
    no: 0,
    name: "STANDARD"
  }, {
    no: 1,
    name: "INGRESS"
  }, {
    no: 2,
    name: "EGRESS"
  }, {
    no: 3,
    name: "SIP"
  }, {
    no: 4,
    name: "AGENT"
  }]);
  var Encryption_Type = /* @__PURE__ */ proto3.makeEnum("livekit.Encryption.Type", [{
    no: 0,
    name: "NONE"
  }, {
    no: 1,
    name: "GCM"
  }, {
    no: 2,
    name: "CUSTOM"
  }]);
  var SimulcastCodecInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.SimulcastCodecInfo", () => [{
    no: 1,
    name: "mime_type",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "mid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "cid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 4,
    name: "layers",
    kind: "message",
    T: VideoLayer,
    repeated: true
  }]);
  var TrackInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.TrackInfo", () => [{
    no: 1,
    name: "sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "type",
    kind: "enum",
    T: proto3.getEnumType(TrackType)
  }, {
    no: 3,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 4,
    name: "muted",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 5,
    name: "width",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 6,
    name: "height",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 7,
    name: "simulcast",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 8,
    name: "disable_dtx",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 9,
    name: "source",
    kind: "enum",
    T: proto3.getEnumType(TrackSource)
  }, {
    no: 10,
    name: "layers",
    kind: "message",
    T: VideoLayer,
    repeated: true
  }, {
    no: 11,
    name: "mime_type",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 12,
    name: "mid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 13,
    name: "codecs",
    kind: "message",
    T: SimulcastCodecInfo,
    repeated: true
  }, {
    no: 14,
    name: "stereo",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 15,
    name: "disable_red",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 16,
    name: "encryption",
    kind: "enum",
    T: proto3.getEnumType(Encryption_Type)
  }, {
    no: 17,
    name: "stream",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 18,
    name: "version",
    kind: "message",
    T: TimedVersion
  }, {
    no: 19,
    name: "audio_features",
    kind: "enum",
    T: proto3.getEnumType(AudioTrackFeature),
    repeated: true
  }]);
  var VideoLayer = /* @__PURE__ */ proto3.makeMessageType("livekit.VideoLayer", () => [{
    no: 1,
    name: "quality",
    kind: "enum",
    T: proto3.getEnumType(VideoQuality$1)
  }, {
    no: 2,
    name: "width",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 3,
    name: "height",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 4,
    name: "bitrate",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 5,
    name: "ssrc",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }]);
  var DataPacket = /* @__PURE__ */ proto3.makeMessageType("livekit.DataPacket", () => [{
    no: 1,
    name: "kind",
    kind: "enum",
    T: proto3.getEnumType(DataPacket_Kind)
  }, {
    no: 4,
    name: "participant_identity",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "destination_identities",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 2,
    name: "user",
    kind: "message",
    T: UserPacket,
    oneof: "value"
  }, {
    no: 3,
    name: "speaker",
    kind: "message",
    T: ActiveSpeakerUpdate,
    oneof: "value"
  }, {
    no: 6,
    name: "sip_dtmf",
    kind: "message",
    T: SipDTMF,
    oneof: "value"
  }, {
    no: 7,
    name: "transcription",
    kind: "message",
    T: Transcription,
    oneof: "value"
  }, {
    no: 8,
    name: "metrics",
    kind: "message",
    T: MetricsBatch,
    oneof: "value"
  }, {
    no: 9,
    name: "chat_message",
    kind: "message",
    T: ChatMessage,
    oneof: "value"
  }, {
    no: 10,
    name: "rpc_request",
    kind: "message",
    T: RpcRequest,
    oneof: "value"
  }, {
    no: 11,
    name: "rpc_ack",
    kind: "message",
    T: RpcAck,
    oneof: "value"
  }, {
    no: 12,
    name: "rpc_response",
    kind: "message",
    T: RpcResponse,
    oneof: "value"
  }, {
    no: 13,
    name: "stream_header",
    kind: "message",
    T: DataStream_Header,
    oneof: "value"
  }, {
    no: 14,
    name: "stream_chunk",
    kind: "message",
    T: DataStream_Chunk,
    oneof: "value"
  }]);
  var DataPacket_Kind = /* @__PURE__ */ proto3.makeEnum("livekit.DataPacket.Kind", [{
    no: 0,
    name: "RELIABLE"
  }, {
    no: 1,
    name: "LOSSY"
  }]);
  var ActiveSpeakerUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.ActiveSpeakerUpdate", () => [{
    no: 1,
    name: "speakers",
    kind: "message",
    T: SpeakerInfo,
    repeated: true
  }]);
  var SpeakerInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.SpeakerInfo", () => [{
    no: 1,
    name: "sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "level",
    kind: "scalar",
    T: 2
    /* ScalarType.FLOAT */
  }, {
    no: 3,
    name: "active",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }]);
  var UserPacket = /* @__PURE__ */ proto3.makeMessageType("livekit.UserPacket", () => [{
    no: 1,
    name: "participant_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "participant_identity",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "payload",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  }, {
    no: 3,
    name: "destination_sids",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 6,
    name: "destination_identities",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 4,
    name: "topic",
    kind: "scalar",
    T: 9,
    opt: true
  }, {
    no: 8,
    name: "id",
    kind: "scalar",
    T: 9,
    opt: true
  }, {
    no: 9,
    name: "start_time",
    kind: "scalar",
    T: 4,
    opt: true
  }, {
    no: 10,
    name: "end_time",
    kind: "scalar",
    T: 4,
    opt: true
  }]);
  var SipDTMF = /* @__PURE__ */ proto3.makeMessageType("livekit.SipDTMF", () => [{
    no: 3,
    name: "code",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 4,
    name: "digit",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  var Transcription = /* @__PURE__ */ proto3.makeMessageType("livekit.Transcription", () => [{
    no: 2,
    name: "transcribed_participant_identity",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "track_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 4,
    name: "segments",
    kind: "message",
    T: TranscriptionSegment,
    repeated: true
  }]);
  var TranscriptionSegment = /* @__PURE__ */ proto3.makeMessageType("livekit.TranscriptionSegment", () => [{
    no: 1,
    name: "id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "text",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "start_time",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 4,
    name: "end_time",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 5,
    name: "final",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 6,
    name: "language",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  var ChatMessage = /* @__PURE__ */ proto3.makeMessageType("livekit.ChatMessage", () => [{
    no: 1,
    name: "id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "timestamp",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 3,
    name: "edit_timestamp",
    kind: "scalar",
    T: 3,
    opt: true
  }, {
    no: 4,
    name: "message",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "deleted",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 6,
    name: "generated",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }]);
  var RpcRequest = /* @__PURE__ */ proto3.makeMessageType("livekit.RpcRequest", () => [{
    no: 1,
    name: "id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "method",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "payload",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 4,
    name: "response_timeout_ms",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 5,
    name: "version",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }]);
  var RpcAck = /* @__PURE__ */ proto3.makeMessageType("livekit.RpcAck", () => [{
    no: 1,
    name: "request_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  var RpcResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.RpcResponse", () => [{
    no: 1,
    name: "request_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "payload",
    kind: "scalar",
    T: 9,
    oneof: "value"
  }, {
    no: 3,
    name: "error",
    kind: "message",
    T: RpcError$1,
    oneof: "value"
  }]);
  var RpcError$1 = /* @__PURE__ */ proto3.makeMessageType("livekit.RpcError", () => [{
    no: 1,
    name: "code",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 2,
    name: "message",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "data",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  var ParticipantTracks = /* @__PURE__ */ proto3.makeMessageType("livekit.ParticipantTracks", () => [{
    no: 1,
    name: "participant_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "track_sids",
    kind: "scalar",
    T: 9,
    repeated: true
  }]);
  var ServerInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.ServerInfo", () => [{
    no: 1,
    name: "edition",
    kind: "enum",
    T: proto3.getEnumType(ServerInfo_Edition)
  }, {
    no: 2,
    name: "version",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "protocol",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }, {
    no: 4,
    name: "region",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "node_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 6,
    name: "debug_info",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 7,
    name: "agent_protocol",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }]);
  var ServerInfo_Edition = /* @__PURE__ */ proto3.makeEnum("livekit.ServerInfo.Edition", [{
    no: 0,
    name: "Standard"
  }, {
    no: 1,
    name: "Cloud"
  }]);
  var ClientInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.ClientInfo", () => [{
    no: 1,
    name: "sdk",
    kind: "enum",
    T: proto3.getEnumType(ClientInfo_SDK)
  }, {
    no: 2,
    name: "version",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "protocol",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }, {
    no: 4,
    name: "os",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "os_version",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 6,
    name: "device_model",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 7,
    name: "browser",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 8,
    name: "browser_version",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 9,
    name: "address",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 10,
    name: "network",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 11,
    name: "other_sdks",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  var ClientInfo_SDK = /* @__PURE__ */ proto3.makeEnum("livekit.ClientInfo.SDK", [{
    no: 0,
    name: "UNKNOWN"
  }, {
    no: 1,
    name: "JS"
  }, {
    no: 2,
    name: "SWIFT"
  }, {
    no: 3,
    name: "ANDROID"
  }, {
    no: 4,
    name: "FLUTTER"
  }, {
    no: 5,
    name: "GO"
  }, {
    no: 6,
    name: "UNITY"
  }, {
    no: 7,
    name: "REACT_NATIVE"
  }, {
    no: 8,
    name: "RUST"
  }, {
    no: 9,
    name: "PYTHON"
  }, {
    no: 10,
    name: "CPP"
  }, {
    no: 11,
    name: "UNITY_WEB"
  }, {
    no: 12,
    name: "NODE"
  }]);
  var ClientConfiguration = /* @__PURE__ */ proto3.makeMessageType("livekit.ClientConfiguration", () => [{
    no: 1,
    name: "video",
    kind: "message",
    T: VideoConfiguration
  }, {
    no: 2,
    name: "screen",
    kind: "message",
    T: VideoConfiguration
  }, {
    no: 3,
    name: "resume_connection",
    kind: "enum",
    T: proto3.getEnumType(ClientConfigSetting)
  }, {
    no: 4,
    name: "disabled_codecs",
    kind: "message",
    T: DisabledCodecs
  }, {
    no: 5,
    name: "force_relay",
    kind: "enum",
    T: proto3.getEnumType(ClientConfigSetting)
  }]);
  var VideoConfiguration = /* @__PURE__ */ proto3.makeMessageType("livekit.VideoConfiguration", () => [{
    no: 1,
    name: "hardware_encoder",
    kind: "enum",
    T: proto3.getEnumType(ClientConfigSetting)
  }]);
  var DisabledCodecs = /* @__PURE__ */ proto3.makeMessageType("livekit.DisabledCodecs", () => [{
    no: 1,
    name: "codecs",
    kind: "message",
    T: Codec,
    repeated: true
  }, {
    no: 2,
    name: "publish",
    kind: "message",
    T: Codec,
    repeated: true
  }]);
  var TimedVersion = /* @__PURE__ */ proto3.makeMessageType("livekit.TimedVersion", () => [{
    no: 1,
    name: "unix_micro",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 2,
    name: "ticks",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }]);
  var DataStream_OperationType = /* @__PURE__ */ proto3.makeEnum("livekit.DataStream.OperationType", [{
    no: 0,
    name: "CREATE"
  }, {
    no: 1,
    name: "UPDATE"
  }, {
    no: 2,
    name: "DELETE"
  }, {
    no: 3,
    name: "REACTION"
  }]);
  var DataStream_TextHeader = /* @__PURE__ */ proto3.makeMessageType("livekit.DataStream.TextHeader", () => [{
    no: 1,
    name: "operation_type",
    kind: "enum",
    T: proto3.getEnumType(DataStream_OperationType)
  }, {
    no: 2,
    name: "version",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }, {
    no: 3,
    name: "reply_to_stream_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 4,
    name: "attached_stream_ids",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 5,
    name: "generated",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }], {
    localName: "DataStream_TextHeader"
  });
  var DataStream_FileHeader = /* @__PURE__ */ proto3.makeMessageType("livekit.DataStream.FileHeader", () => [{
    no: 1,
    name: "file_name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }], {
    localName: "DataStream_FileHeader"
  });
  var DataStream_Header = /* @__PURE__ */ proto3.makeMessageType("livekit.DataStream.Header", () => [{
    no: 1,
    name: "stream_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "timestamp",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 3,
    name: "topic",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 4,
    name: "mime_type",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "total_length",
    kind: "scalar",
    T: 4,
    opt: true
  }, {
    no: 6,
    name: "total_chunks",
    kind: "scalar",
    T: 4,
    opt: true
  }, {
    no: 7,
    name: "encryption_type",
    kind: "enum",
    T: proto3.getEnumType(Encryption_Type)
  }, {
    no: 8,
    name: "extensions",
    kind: "map",
    K: 9,
    V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  }, {
    no: 9,
    name: "text_header",
    kind: "message",
    T: DataStream_TextHeader,
    oneof: "content_header"
  }, {
    no: 10,
    name: "file_header",
    kind: "message",
    T: DataStream_FileHeader,
    oneof: "content_header"
  }], {
    localName: "DataStream_Header"
  });
  var DataStream_Chunk = /* @__PURE__ */ proto3.makeMessageType("livekit.DataStream.Chunk", () => [{
    no: 1,
    name: "stream_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "chunk_index",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 3,
    name: "content",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  }, {
    no: 4,
    name: "complete",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 5,
    name: "version",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }, {
    no: 6,
    name: "iv",
    kind: "scalar",
    T: 12,
    opt: true
  }], {
    localName: "DataStream_Chunk"
  });
  var SignalTarget = /* @__PURE__ */ proto3.makeEnum("livekit.SignalTarget", [{
    no: 0,
    name: "PUBLISHER"
  }, {
    no: 1,
    name: "SUBSCRIBER"
  }]);
  var StreamState = /* @__PURE__ */ proto3.makeEnum("livekit.StreamState", [{
    no: 0,
    name: "ACTIVE"
  }, {
    no: 1,
    name: "PAUSED"
  }]);
  var CandidateProtocol = /* @__PURE__ */ proto3.makeEnum("livekit.CandidateProtocol", [{
    no: 0,
    name: "UDP"
  }, {
    no: 1,
    name: "TCP"
  }, {
    no: 2,
    name: "TLS"
  }]);
  var SignalRequest = /* @__PURE__ */ proto3.makeMessageType("livekit.SignalRequest", () => [{
    no: 1,
    name: "offer",
    kind: "message",
    T: SessionDescription,
    oneof: "message"
  }, {
    no: 2,
    name: "answer",
    kind: "message",
    T: SessionDescription,
    oneof: "message"
  }, {
    no: 3,
    name: "trickle",
    kind: "message",
    T: TrickleRequest,
    oneof: "message"
  }, {
    no: 4,
    name: "add_track",
    kind: "message",
    T: AddTrackRequest,
    oneof: "message"
  }, {
    no: 5,
    name: "mute",
    kind: "message",
    T: MuteTrackRequest,
    oneof: "message"
  }, {
    no: 6,
    name: "subscription",
    kind: "message",
    T: UpdateSubscription,
    oneof: "message"
  }, {
    no: 7,
    name: "track_setting",
    kind: "message",
    T: UpdateTrackSettings,
    oneof: "message"
  }, {
    no: 8,
    name: "leave",
    kind: "message",
    T: LeaveRequest,
    oneof: "message"
  }, {
    no: 10,
    name: "update_layers",
    kind: "message",
    T: UpdateVideoLayers,
    oneof: "message"
  }, {
    no: 11,
    name: "subscription_permission",
    kind: "message",
    T: SubscriptionPermission,
    oneof: "message"
  }, {
    no: 12,
    name: "sync_state",
    kind: "message",
    T: SyncState,
    oneof: "message"
  }, {
    no: 13,
    name: "simulate",
    kind: "message",
    T: SimulateScenario,
    oneof: "message"
  }, {
    no: 14,
    name: "ping",
    kind: "scalar",
    T: 3,
    oneof: "message"
  }, {
    no: 15,
    name: "update_metadata",
    kind: "message",
    T: UpdateParticipantMetadata,
    oneof: "message"
  }, {
    no: 16,
    name: "ping_req",
    kind: "message",
    T: Ping,
    oneof: "message"
  }, {
    no: 17,
    name: "update_audio_track",
    kind: "message",
    T: UpdateLocalAudioTrack,
    oneof: "message"
  }, {
    no: 18,
    name: "update_video_track",
    kind: "message",
    T: UpdateLocalVideoTrack,
    oneof: "message"
  }]);
  var SignalResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.SignalResponse", () => [{
    no: 1,
    name: "join",
    kind: "message",
    T: JoinResponse,
    oneof: "message"
  }, {
    no: 2,
    name: "answer",
    kind: "message",
    T: SessionDescription,
    oneof: "message"
  }, {
    no: 3,
    name: "offer",
    kind: "message",
    T: SessionDescription,
    oneof: "message"
  }, {
    no: 4,
    name: "trickle",
    kind: "message",
    T: TrickleRequest,
    oneof: "message"
  }, {
    no: 5,
    name: "update",
    kind: "message",
    T: ParticipantUpdate,
    oneof: "message"
  }, {
    no: 6,
    name: "track_published",
    kind: "message",
    T: TrackPublishedResponse,
    oneof: "message"
  }, {
    no: 8,
    name: "leave",
    kind: "message",
    T: LeaveRequest,
    oneof: "message"
  }, {
    no: 9,
    name: "mute",
    kind: "message",
    T: MuteTrackRequest,
    oneof: "message"
  }, {
    no: 10,
    name: "speakers_changed",
    kind: "message",
    T: SpeakersChanged,
    oneof: "message"
  }, {
    no: 11,
    name: "room_update",
    kind: "message",
    T: RoomUpdate,
    oneof: "message"
  }, {
    no: 12,
    name: "connection_quality",
    kind: "message",
    T: ConnectionQualityUpdate,
    oneof: "message"
  }, {
    no: 13,
    name: "stream_state_update",
    kind: "message",
    T: StreamStateUpdate,
    oneof: "message"
  }, {
    no: 14,
    name: "subscribed_quality_update",
    kind: "message",
    T: SubscribedQualityUpdate,
    oneof: "message"
  }, {
    no: 15,
    name: "subscription_permission_update",
    kind: "message",
    T: SubscriptionPermissionUpdate,
    oneof: "message"
  }, {
    no: 16,
    name: "refresh_token",
    kind: "scalar",
    T: 9,
    oneof: "message"
  }, {
    no: 17,
    name: "track_unpublished",
    kind: "message",
    T: TrackUnpublishedResponse,
    oneof: "message"
  }, {
    no: 18,
    name: "pong",
    kind: "scalar",
    T: 3,
    oneof: "message"
  }, {
    no: 19,
    name: "reconnect",
    kind: "message",
    T: ReconnectResponse,
    oneof: "message"
  }, {
    no: 20,
    name: "pong_resp",
    kind: "message",
    T: Pong,
    oneof: "message"
  }, {
    no: 21,
    name: "subscription_response",
    kind: "message",
    T: SubscriptionResponse,
    oneof: "message"
  }, {
    no: 22,
    name: "request_response",
    kind: "message",
    T: RequestResponse,
    oneof: "message"
  }, {
    no: 23,
    name: "track_subscribed",
    kind: "message",
    T: TrackSubscribed,
    oneof: "message"
  }]);
  var SimulcastCodec = /* @__PURE__ */ proto3.makeMessageType("livekit.SimulcastCodec", () => [{
    no: 1,
    name: "codec",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "cid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  var AddTrackRequest = /* @__PURE__ */ proto3.makeMessageType("livekit.AddTrackRequest", () => [{
    no: 1,
    name: "cid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "type",
    kind: "enum",
    T: proto3.getEnumType(TrackType)
  }, {
    no: 4,
    name: "width",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 5,
    name: "height",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 6,
    name: "muted",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 7,
    name: "disable_dtx",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 8,
    name: "source",
    kind: "enum",
    T: proto3.getEnumType(TrackSource)
  }, {
    no: 9,
    name: "layers",
    kind: "message",
    T: VideoLayer,
    repeated: true
  }, {
    no: 10,
    name: "simulcast_codecs",
    kind: "message",
    T: SimulcastCodec,
    repeated: true
  }, {
    no: 11,
    name: "sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 12,
    name: "stereo",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 13,
    name: "disable_red",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 14,
    name: "encryption",
    kind: "enum",
    T: proto3.getEnumType(Encryption_Type)
  }, {
    no: 15,
    name: "stream",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  var TrickleRequest = /* @__PURE__ */ proto3.makeMessageType("livekit.TrickleRequest", () => [{
    no: 1,
    name: "candidateInit",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "target",
    kind: "enum",
    T: proto3.getEnumType(SignalTarget)
  }, {
    no: 3,
    name: "final",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }]);
  var MuteTrackRequest = /* @__PURE__ */ proto3.makeMessageType("livekit.MuteTrackRequest", () => [{
    no: 1,
    name: "sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "muted",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }]);
  var JoinResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.JoinResponse", () => [{
    no: 1,
    name: "room",
    kind: "message",
    T: Room$1
  }, {
    no: 2,
    name: "participant",
    kind: "message",
    T: ParticipantInfo
  }, {
    no: 3,
    name: "other_participants",
    kind: "message",
    T: ParticipantInfo,
    repeated: true
  }, {
    no: 4,
    name: "server_version",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "ice_servers",
    kind: "message",
    T: ICEServer,
    repeated: true
  }, {
    no: 6,
    name: "subscriber_primary",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 7,
    name: "alternative_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 8,
    name: "client_configuration",
    kind: "message",
    T: ClientConfiguration
  }, {
    no: 9,
    name: "server_region",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 10,
    name: "ping_timeout",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }, {
    no: 11,
    name: "ping_interval",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }, {
    no: 12,
    name: "server_info",
    kind: "message",
    T: ServerInfo
  }, {
    no: 13,
    name: "sif_trailer",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  }, {
    no: 14,
    name: "enabled_publish_codecs",
    kind: "message",
    T: Codec,
    repeated: true
  }, {
    no: 15,
    name: "fast_publish",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }]);
  var ReconnectResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.ReconnectResponse", () => [{
    no: 1,
    name: "ice_servers",
    kind: "message",
    T: ICEServer,
    repeated: true
  }, {
    no: 2,
    name: "client_configuration",
    kind: "message",
    T: ClientConfiguration
  }]);
  var TrackPublishedResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.TrackPublishedResponse", () => [{
    no: 1,
    name: "cid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "track",
    kind: "message",
    T: TrackInfo
  }]);
  var TrackUnpublishedResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.TrackUnpublishedResponse", () => [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  var SessionDescription = /* @__PURE__ */ proto3.makeMessageType("livekit.SessionDescription", () => [{
    no: 1,
    name: "type",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "sdp",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  var ParticipantUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.ParticipantUpdate", () => [{
    no: 1,
    name: "participants",
    kind: "message",
    T: ParticipantInfo,
    repeated: true
  }]);
  var UpdateSubscription = /* @__PURE__ */ proto3.makeMessageType("livekit.UpdateSubscription", () => [{
    no: 1,
    name: "track_sids",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 2,
    name: "subscribe",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 3,
    name: "participant_tracks",
    kind: "message",
    T: ParticipantTracks,
    repeated: true
  }]);
  var UpdateTrackSettings = /* @__PURE__ */ proto3.makeMessageType("livekit.UpdateTrackSettings", () => [{
    no: 1,
    name: "track_sids",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 3,
    name: "disabled",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 4,
    name: "quality",
    kind: "enum",
    T: proto3.getEnumType(VideoQuality$1)
  }, {
    no: 5,
    name: "width",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 6,
    name: "height",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 7,
    name: "fps",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 8,
    name: "priority",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }]);
  var UpdateLocalAudioTrack = /* @__PURE__ */ proto3.makeMessageType("livekit.UpdateLocalAudioTrack", () => [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "features",
    kind: "enum",
    T: proto3.getEnumType(AudioTrackFeature),
    repeated: true
  }]);
  var UpdateLocalVideoTrack = /* @__PURE__ */ proto3.makeMessageType("livekit.UpdateLocalVideoTrack", () => [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "width",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 3,
    name: "height",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }]);
  var LeaveRequest = /* @__PURE__ */ proto3.makeMessageType("livekit.LeaveRequest", () => [{
    no: 1,
    name: "can_reconnect",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 2,
    name: "reason",
    kind: "enum",
    T: proto3.getEnumType(DisconnectReason)
  }, {
    no: 3,
    name: "action",
    kind: "enum",
    T: proto3.getEnumType(LeaveRequest_Action)
  }, {
    no: 4,
    name: "regions",
    kind: "message",
    T: RegionSettings
  }]);
  var LeaveRequest_Action = /* @__PURE__ */ proto3.makeEnum("livekit.LeaveRequest.Action", [{
    no: 0,
    name: "DISCONNECT"
  }, {
    no: 1,
    name: "RESUME"
  }, {
    no: 2,
    name: "RECONNECT"
  }]);
  var UpdateVideoLayers = /* @__PURE__ */ proto3.makeMessageType("livekit.UpdateVideoLayers", () => [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "layers",
    kind: "message",
    T: VideoLayer,
    repeated: true
  }]);
  var UpdateParticipantMetadata = /* @__PURE__ */ proto3.makeMessageType("livekit.UpdateParticipantMetadata", () => [{
    no: 1,
    name: "metadata",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "attributes",
    kind: "map",
    K: 9,
    V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  }, {
    no: 4,
    name: "request_id",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }]);
  var ICEServer = /* @__PURE__ */ proto3.makeMessageType("livekit.ICEServer", () => [{
    no: 1,
    name: "urls",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 2,
    name: "username",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "credential",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  var SpeakersChanged = /* @__PURE__ */ proto3.makeMessageType("livekit.SpeakersChanged", () => [{
    no: 1,
    name: "speakers",
    kind: "message",
    T: SpeakerInfo,
    repeated: true
  }]);
  var RoomUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.RoomUpdate", () => [{
    no: 1,
    name: "room",
    kind: "message",
    T: Room$1
  }]);
  var ConnectionQualityInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.ConnectionQualityInfo", () => [{
    no: 1,
    name: "participant_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "quality",
    kind: "enum",
    T: proto3.getEnumType(ConnectionQuality$1)
  }, {
    no: 3,
    name: "score",
    kind: "scalar",
    T: 2
    /* ScalarType.FLOAT */
  }]);
  var ConnectionQualityUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.ConnectionQualityUpdate", () => [{
    no: 1,
    name: "updates",
    kind: "message",
    T: ConnectionQualityInfo,
    repeated: true
  }]);
  var StreamStateInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.StreamStateInfo", () => [{
    no: 1,
    name: "participant_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "state",
    kind: "enum",
    T: proto3.getEnumType(StreamState)
  }]);
  var StreamStateUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.StreamStateUpdate", () => [{
    no: 1,
    name: "stream_states",
    kind: "message",
    T: StreamStateInfo,
    repeated: true
  }]);
  var SubscribedQuality = /* @__PURE__ */ proto3.makeMessageType("livekit.SubscribedQuality", () => [{
    no: 1,
    name: "quality",
    kind: "enum",
    T: proto3.getEnumType(VideoQuality$1)
  }, {
    no: 2,
    name: "enabled",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }]);
  var SubscribedCodec = /* @__PURE__ */ proto3.makeMessageType("livekit.SubscribedCodec", () => [{
    no: 1,
    name: "codec",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "qualities",
    kind: "message",
    T: SubscribedQuality,
    repeated: true
  }]);
  var SubscribedQualityUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.SubscribedQualityUpdate", () => [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "subscribed_qualities",
    kind: "message",
    T: SubscribedQuality,
    repeated: true
  }, {
    no: 3,
    name: "subscribed_codecs",
    kind: "message",
    T: SubscribedCodec,
    repeated: true
  }]);
  var TrackPermission = /* @__PURE__ */ proto3.makeMessageType("livekit.TrackPermission", () => [{
    no: 1,
    name: "participant_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "all_tracks",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 3,
    name: "track_sids",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 4,
    name: "participant_identity",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  var SubscriptionPermission = /* @__PURE__ */ proto3.makeMessageType("livekit.SubscriptionPermission", () => [{
    no: 1,
    name: "all_participants",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 2,
    name: "track_permissions",
    kind: "message",
    T: TrackPermission,
    repeated: true
  }]);
  var SubscriptionPermissionUpdate = /* @__PURE__ */ proto3.makeMessageType("livekit.SubscriptionPermissionUpdate", () => [{
    no: 1,
    name: "participant_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "allowed",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }]);
  var SyncState = /* @__PURE__ */ proto3.makeMessageType("livekit.SyncState", () => [{
    no: 1,
    name: "answer",
    kind: "message",
    T: SessionDescription
  }, {
    no: 2,
    name: "subscription",
    kind: "message",
    T: UpdateSubscription
  }, {
    no: 3,
    name: "publish_tracks",
    kind: "message",
    T: TrackPublishedResponse,
    repeated: true
  }, {
    no: 4,
    name: "data_channels",
    kind: "message",
    T: DataChannelInfo,
    repeated: true
  }, {
    no: 5,
    name: "offer",
    kind: "message",
    T: SessionDescription
  }, {
    no: 6,
    name: "track_sids_disabled",
    kind: "scalar",
    T: 9,
    repeated: true
  }]);
  var DataChannelInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.DataChannelInfo", () => [{
    no: 1,
    name: "label",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "id",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 3,
    name: "target",
    kind: "enum",
    T: proto3.getEnumType(SignalTarget)
  }]);
  var SimulateScenario = /* @__PURE__ */ proto3.makeMessageType("livekit.SimulateScenario", () => [{
    no: 1,
    name: "speaker_update",
    kind: "scalar",
    T: 5,
    oneof: "scenario"
  }, {
    no: 2,
    name: "node_failure",
    kind: "scalar",
    T: 8,
    oneof: "scenario"
  }, {
    no: 3,
    name: "migration",
    kind: "scalar",
    T: 8,
    oneof: "scenario"
  }, {
    no: 4,
    name: "server_leave",
    kind: "scalar",
    T: 8,
    oneof: "scenario"
  }, {
    no: 5,
    name: "switch_candidate_protocol",
    kind: "enum",
    T: proto3.getEnumType(CandidateProtocol),
    oneof: "scenario"
  }, {
    no: 6,
    name: "subscriber_bandwidth",
    kind: "scalar",
    T: 3,
    oneof: "scenario"
  }, {
    no: 7,
    name: "disconnect_signal_on_resume",
    kind: "scalar",
    T: 8,
    oneof: "scenario"
  }, {
    no: 8,
    name: "disconnect_signal_on_resume_no_messages",
    kind: "scalar",
    T: 8,
    oneof: "scenario"
  }, {
    no: 9,
    name: "leave_request_full_reconnect",
    kind: "scalar",
    T: 8,
    oneof: "scenario"
  }]);
  var Ping = /* @__PURE__ */ proto3.makeMessageType("livekit.Ping", () => [{
    no: 1,
    name: "timestamp",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 2,
    name: "rtt",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }]);
  var Pong = /* @__PURE__ */ proto3.makeMessageType("livekit.Pong", () => [{
    no: 1,
    name: "last_ping_timestamp",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 2,
    name: "timestamp",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }]);
  var RegionSettings = /* @__PURE__ */ proto3.makeMessageType("livekit.RegionSettings", () => [{
    no: 1,
    name: "regions",
    kind: "message",
    T: RegionInfo,
    repeated: true
  }]);
  var RegionInfo = /* @__PURE__ */ proto3.makeMessageType("livekit.RegionInfo", () => [{
    no: 1,
    name: "region",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "distance",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }]);
  var SubscriptionResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.SubscriptionResponse", () => [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "err",
    kind: "enum",
    T: proto3.getEnumType(SubscriptionError)
  }]);
  var RequestResponse = /* @__PURE__ */ proto3.makeMessageType("livekit.RequestResponse", () => [{
    no: 1,
    name: "request_id",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 2,
    name: "reason",
    kind: "enum",
    T: proto3.getEnumType(RequestResponse_Reason)
  }, {
    no: 3,
    name: "message",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  var RequestResponse_Reason = /* @__PURE__ */ proto3.makeEnum("livekit.RequestResponse.Reason", [{
    no: 0,
    name: "OK"
  }, {
    no: 1,
    name: "NOT_FOUND"
  }, {
    no: 2,
    name: "NOT_ALLOWED"
  }, {
    no: 3,
    name: "LIMIT_EXCEEDED"
  }]);
  var TrackSubscribed = /* @__PURE__ */ proto3.makeMessageType("livekit.TrackSubscribed", () => [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }]);
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var loglevel$1 = { exports: {} };
  var loglevel = loglevel$1.exports;
  var hasRequiredLoglevel;
  function requireLoglevel() {
    if (hasRequiredLoglevel) return loglevel$1.exports;
    hasRequiredLoglevel = 1;
    (function(module) {
      (function(root, definition) {
        if (module.exports) {
          module.exports = definition();
        } else {
          root.log = definition();
        }
      })(loglevel, function() {
        var noop2 = function() {
        };
        var undefinedType = "undefined";
        var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\/|MSIE /.test(window.navigator.userAgent);
        var logMethods = ["trace", "debug", "info", "warn", "error"];
        var _loggersByName = {};
        var defaultLogger = null;
        function bindMethod(obj, methodName) {
          var method = obj[methodName];
          if (typeof method.bind === "function") {
            return method.bind(obj);
          } else {
            try {
              return Function.prototype.bind.call(method, obj);
            } catch (e) {
              return function() {
                return Function.prototype.apply.apply(method, [obj, arguments]);
              };
            }
          }
        }
        function traceForIE() {
          if (console.log) {
            if (console.log.apply) {
              console.log.apply(console, arguments);
            } else {
              Function.prototype.apply.apply(console.log, [console, arguments]);
            }
          }
          if (console.trace) console.trace();
        }
        function realMethod(methodName) {
          if (methodName === "debug") {
            methodName = "log";
          }
          if (typeof console === undefinedType) {
            return false;
          } else if (methodName === "trace" && isIE) {
            return traceForIE;
          } else if (console[methodName] !== void 0) {
            return bindMethod(console, methodName);
          } else if (console.log !== void 0) {
            return bindMethod(console, "log");
          } else {
            return noop2;
          }
        }
        function replaceLoggingMethods() {
          var level = this.getLevel();
          for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = i < level ? noop2 : this.methodFactory(methodName, level, this.name);
          }
          this.log = this.debug;
          if (typeof console === undefinedType && level < this.levels.SILENT) {
            return "No console available for logging";
          }
        }
        function enableLoggingWhenConsoleArrives(methodName) {
          return function() {
            if (typeof console !== undefinedType) {
              replaceLoggingMethods.call(this);
              this[methodName].apply(this, arguments);
            }
          };
        }
        function defaultMethodFactory(methodName, _level, _loggerName) {
          return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
        }
        function Logger(name, factory) {
          var self2 = this;
          var inheritedLevel;
          var defaultLevel;
          var userLevel;
          var storageKey = "loglevel";
          if (typeof name === "string") {
            storageKey += ":" + name;
          } else if (typeof name === "symbol") {
            storageKey = void 0;
          }
          function persistLevelIfPossible(levelNum) {
            var levelName = (logMethods[levelNum] || "silent").toUpperCase();
            if (typeof window === undefinedType || !storageKey) return;
            try {
              window.localStorage[storageKey] = levelName;
              return;
            } catch (ignore) {
            }
            try {
              window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
            } catch (ignore) {
            }
          }
          function getPersistedLevel() {
            var storedLevel;
            if (typeof window === undefinedType || !storageKey) return;
            try {
              storedLevel = window.localStorage[storageKey];
            } catch (ignore) {
            }
            if (typeof storedLevel === undefinedType) {
              try {
                var cookie = window.document.cookie;
                var cookieName = encodeURIComponent(storageKey);
                var location = cookie.indexOf(cookieName + "=");
                if (location !== -1) {
                  storedLevel = /^([^;]+)/.exec(cookie.slice(location + cookieName.length + 1))[1];
                }
              } catch (ignore) {
              }
            }
            if (self2.levels[storedLevel] === void 0) {
              storedLevel = void 0;
            }
            return storedLevel;
          }
          function clearPersistedLevel() {
            if (typeof window === undefinedType || !storageKey) return;
            try {
              window.localStorage.removeItem(storageKey);
            } catch (ignore) {
            }
            try {
              window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
            } catch (ignore) {
            }
          }
          function normalizeLevel(input) {
            var level = input;
            if (typeof level === "string" && self2.levels[level.toUpperCase()] !== void 0) {
              level = self2.levels[level.toUpperCase()];
            }
            if (typeof level === "number" && level >= 0 && level <= self2.levels.SILENT) {
              return level;
            } else {
              throw new TypeError("log.setLevel() called with invalid level: " + input);
            }
          }
          self2.name = name;
          self2.levels = {
            "TRACE": 0,
            "DEBUG": 1,
            "INFO": 2,
            "WARN": 3,
            "ERROR": 4,
            "SILENT": 5
          };
          self2.methodFactory = factory || defaultMethodFactory;
          self2.getLevel = function() {
            if (userLevel != null) {
              return userLevel;
            } else if (defaultLevel != null) {
              return defaultLevel;
            } else {
              return inheritedLevel;
            }
          };
          self2.setLevel = function(level, persist) {
            userLevel = normalizeLevel(level);
            if (persist !== false) {
              persistLevelIfPossible(userLevel);
            }
            return replaceLoggingMethods.call(self2);
          };
          self2.setDefaultLevel = function(level) {
            defaultLevel = normalizeLevel(level);
            if (!getPersistedLevel()) {
              self2.setLevel(level, false);
            }
          };
          self2.resetLevel = function() {
            userLevel = null;
            clearPersistedLevel();
            replaceLoggingMethods.call(self2);
          };
          self2.enableAll = function(persist) {
            self2.setLevel(self2.levels.TRACE, persist);
          };
          self2.disableAll = function(persist) {
            self2.setLevel(self2.levels.SILENT, persist);
          };
          self2.rebuild = function() {
            if (defaultLogger !== self2) {
              inheritedLevel = normalizeLevel(defaultLogger.getLevel());
            }
            replaceLoggingMethods.call(self2);
            if (defaultLogger === self2) {
              for (var childName in _loggersByName) {
                _loggersByName[childName].rebuild();
              }
            }
          };
          inheritedLevel = normalizeLevel(defaultLogger ? defaultLogger.getLevel() : "WARN");
          var initialLevel = getPersistedLevel();
          if (initialLevel != null) {
            userLevel = normalizeLevel(initialLevel);
          }
          replaceLoggingMethods.call(self2);
        }
        defaultLogger = new Logger();
        defaultLogger.getLogger = function getLogger2(name) {
          if (typeof name !== "symbol" && typeof name !== "string" || name === "") {
            throw new TypeError("You must supply a name when creating a logger.");
          }
          var logger = _loggersByName[name];
          if (!logger) {
            logger = _loggersByName[name] = new Logger(name, defaultLogger.methodFactory);
          }
          return logger;
        };
        var _log = typeof window !== undefinedType ? window.log : void 0;
        defaultLogger.noConflict = function() {
          if (typeof window !== undefinedType && window.log === defaultLogger) {
            window.log = _log;
          }
          return defaultLogger;
        };
        defaultLogger.getLoggers = function getLoggers() {
          return _loggersByName;
        };
        defaultLogger["default"] = defaultLogger;
        return defaultLogger;
      });
    })(loglevel$1);
    return loglevel$1.exports;
  }
  var loglevelExports = requireLoglevel();
  var LogLevel;
  (function(LogLevel2) {
    LogLevel2[LogLevel2["trace"] = 0] = "trace";
    LogLevel2[LogLevel2["debug"] = 1] = "debug";
    LogLevel2[LogLevel2["info"] = 2] = "info";
    LogLevel2[LogLevel2["warn"] = 3] = "warn";
    LogLevel2[LogLevel2["error"] = 4] = "error";
    LogLevel2[LogLevel2["silent"] = 5] = "silent";
  })(LogLevel || (LogLevel = {}));
  var LoggerNames;
  (function(LoggerNames2) {
    LoggerNames2["Default"] = "livekit";
    LoggerNames2["Room"] = "livekit-room";
    LoggerNames2["Participant"] = "livekit-participant";
    LoggerNames2["Track"] = "livekit-track";
    LoggerNames2["Publication"] = "livekit-track-publication";
    LoggerNames2["Engine"] = "livekit-engine";
    LoggerNames2["Signal"] = "livekit-signal";
    LoggerNames2["PCManager"] = "livekit-pc-manager";
    LoggerNames2["PCTransport"] = "livekit-pc-transport";
    LoggerNames2["E2EE"] = "lk-e2ee";
  })(LoggerNames || (LoggerNames = {}));
  var livekitLogger = loglevelExports.getLogger("livekit");
  var livekitLoggers = Object.values(LoggerNames).map((name) => loglevelExports.getLogger(name));
  livekitLogger.setDefaultLevel(LogLevel.info);
  function getLogger(name) {
    const logger = loglevelExports.getLogger(name);
    logger.setDefaultLevel(livekitLogger.getLevel());
    return logger;
  }
  var workerLogger = loglevelExports.getLogger("lk-e2ee");
  var maxRetryDelay = 7e3;
  var DEFAULT_RETRY_DELAYS_IN_MS = [0, 300, 2 * 2 * 300, 3 * 3 * 300, 4 * 4 * 300, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay];
  var DefaultReconnectPolicy = class {
    constructor(retryDelays) {
      this._retryDelays = retryDelays !== void 0 ? [...retryDelays] : DEFAULT_RETRY_DELAYS_IN_MS;
    }
    nextRetryDelayInMs(context) {
      if (context.retryCount >= this._retryDelays.length) return null;
      const retryDelay = this._retryDelays[context.retryCount];
      if (context.retryCount <= 1) return retryDelay;
      return retryDelay + Math.random() * 1e3;
    }
  };
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n2) {
      i[n2] = o[n2] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n2](v), settle2(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle2(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  }
  var events = { exports: {} };
  var hasRequiredEvents;
  function requireEvents() {
    if (hasRequiredEvents) return events.exports;
    hasRequiredEvents = 1;
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter2() {
      EventEmitter2.init.call(this);
    }
    events.exports = EventEmitter2;
    events.exports.once = once;
    EventEmitter2.EventEmitter = EventEmitter2;
    EventEmitter2.prototype._events = void 0;
    EventEmitter2.prototype._eventsCount = 0;
    EventEmitter2.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter2.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter2.prototype.setMaxListeners = function setMaxListeners(n2) {
      if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
      }
      this._maxListeners = n2;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0) return EventEmitter2.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter2.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter2.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = type === "error";
      var events2 = this._events;
      if (events2 !== void 0) doError = doError && events2.error === void 0;
      else if (!doError) return false;
      if (doError) {
        var er;
        if (args.length > 0) er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events2[type];
      if (handler === void 0) return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events2;
      var existing;
      checkListener(listener);
      events2 = target._events;
      if (events2 === void 0) {
        events2 = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events2.newListener !== void 0) {
          target.emit("newListener", type, listener.listener ? listener.listener : listener);
          events2 = target._events;
        }
        existing = events2[type];
      }
      if (existing === void 0) {
        existing = events2[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter2.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
    EventEmitter2.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = {
        fired: false,
        wrapFn: void 0,
        target,
        type,
        listener
      };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter2.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter2.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter2.prototype.removeListener = function removeListener(type, listener) {
      var list, events2, position, i, originalListener;
      checkListener(listener);
      events2 = this._events;
      if (events2 === void 0) return this;
      list = events2[type];
      if (list === void 0) return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events2[type];
          if (events2.removeListener) this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0) return this;
        if (position === 0) list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1) events2[type] = list[0];
        if (events2.removeListener !== void 0) this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events2, i;
      events2 = this._events;
      if (events2 === void 0) return this;
      if (events2.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events2[type] !== void 0) {
          if (--this._eventsCount === 0) this._events = /* @__PURE__ */ Object.create(null);
          else delete events2[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events2);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events2[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events2 = target._events;
      if (events2 === void 0) return [];
      var evlistener = events2[type];
      if (evlistener === void 0) return [];
      if (typeof evlistener === "function") return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter2.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter2.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter2.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter2.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events2 = this._events;
      if (events2 !== void 0) {
        var evlistener = events2[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n2) {
      var copy = new Array(n2);
      for (var i = 0; i < n2; ++i) copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++) list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        eventTargetAgnosticAddListener(emitter, name, resolver, {
          once: true
        });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, {
            once: true
          });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
    return events.exports;
  }
  var eventsExports = requireEvents();
  var logDisabled_ = true;
  var deprecationWarnings_ = true;
  function extractVersion(uastring, expr, pos) {
    const match = uastring.match(expr);
    return match && match.length >= pos && parseInt(match[pos], 10);
  }
  function wrapPeerConnectionEvent(window2, eventNameToWrap, wrapper) {
    if (!window2.RTCPeerConnection) {
      return;
    }
    const proto = window2.RTCPeerConnection.prototype;
    const nativeAddEventListener = proto.addEventListener;
    proto.addEventListener = function(nativeEventName, cb) {
      if (nativeEventName !== eventNameToWrap) {
        return nativeAddEventListener.apply(this, arguments);
      }
      const wrappedCallback = (e) => {
        const modifiedEvent = wrapper(e);
        if (modifiedEvent) {
          if (cb.handleEvent) {
            cb.handleEvent(modifiedEvent);
          } else {
            cb(modifiedEvent);
          }
        }
      };
      this._eventMap = this._eventMap || {};
      if (!this._eventMap[eventNameToWrap]) {
        this._eventMap[eventNameToWrap] = /* @__PURE__ */ new Map();
      }
      this._eventMap[eventNameToWrap].set(cb, wrappedCallback);
      return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);
    };
    const nativeRemoveEventListener = proto.removeEventListener;
    proto.removeEventListener = function(nativeEventName, cb) {
      if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {
        return nativeRemoveEventListener.apply(this, arguments);
      }
      if (!this._eventMap[eventNameToWrap].has(cb)) {
        return nativeRemoveEventListener.apply(this, arguments);
      }
      const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);
      this._eventMap[eventNameToWrap].delete(cb);
      if (this._eventMap[eventNameToWrap].size === 0) {
        delete this._eventMap[eventNameToWrap];
      }
      if (Object.keys(this._eventMap).length === 0) {
        delete this._eventMap;
      }
      return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);
    };
    Object.defineProperty(proto, "on" + eventNameToWrap, {
      get() {
        return this["_on" + eventNameToWrap];
      },
      set(cb) {
        if (this["_on" + eventNameToWrap]) {
          this.removeEventListener(eventNameToWrap, this["_on" + eventNameToWrap]);
          delete this["_on" + eventNameToWrap];
        }
        if (cb) {
          this.addEventListener(eventNameToWrap, this["_on" + eventNameToWrap] = cb);
        }
      },
      enumerable: true,
      configurable: true
    });
  }
  function disableLog(bool) {
    if (typeof bool !== "boolean") {
      return new Error("Argument type: " + typeof bool + ". Please use a boolean.");
    }
    logDisabled_ = bool;
    return bool ? "adapter.js logging disabled" : "adapter.js logging enabled";
  }
  function disableWarnings(bool) {
    if (typeof bool !== "boolean") {
      return new Error("Argument type: " + typeof bool + ". Please use a boolean.");
    }
    deprecationWarnings_ = !bool;
    return "adapter.js deprecation warnings " + (bool ? "disabled" : "enabled");
  }
  function log() {
    if (typeof window === "object") {
      if (logDisabled_) {
        return;
      }
      if (typeof console !== "undefined" && typeof console.log === "function") {
        console.log.apply(console, arguments);
      }
    }
  }
  function deprecated(oldMethod, newMethod) {
    if (!deprecationWarnings_) {
      return;
    }
    console.warn(oldMethod + " is deprecated, please use " + newMethod + " instead.");
  }
  function detectBrowser(window2) {
    const result = {
      browser: null,
      version: null
    };
    if (typeof window2 === "undefined" || !window2.navigator || !window2.navigator.userAgent) {
      result.browser = "Not a browser.";
      return result;
    }
    const {
      navigator: navigator2
    } = window2;
    if (navigator2.userAgentData && navigator2.userAgentData.brands) {
      const chromium = navigator2.userAgentData.brands.find((brand) => {
        return brand.brand === "Chromium";
      });
      if (chromium) {
        return {
          browser: "chrome",
          version: parseInt(chromium.version, 10)
        };
      }
    }
    if (navigator2.mozGetUserMedia) {
      result.browser = "firefox";
      result.version = extractVersion(navigator2.userAgent, /Firefox\/(\d+)\./, 1);
    } else if (navigator2.webkitGetUserMedia || window2.isSecureContext === false && window2.webkitRTCPeerConnection) {
      result.browser = "chrome";
      result.version = extractVersion(navigator2.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
    } else if (window2.RTCPeerConnection && navigator2.userAgent.match(/AppleWebKit\/(\d+)\./)) {
      result.browser = "safari";
      result.version = extractVersion(navigator2.userAgent, /AppleWebKit\/(\d+)\./, 1);
      result.supportsUnifiedPlan = window2.RTCRtpTransceiver && "currentDirection" in window2.RTCRtpTransceiver.prototype;
    } else {
      result.browser = "Not a supported browser.";
      return result;
    }
    return result;
  }
  function isObject(val) {
    return Object.prototype.toString.call(val) === "[object Object]";
  }
  function compactObject(data) {
    if (!isObject(data)) {
      return data;
    }
    return Object.keys(data).reduce(function(accumulator, key) {
      const isObj = isObject(data[key]);
      const value = isObj ? compactObject(data[key]) : data[key];
      const isEmptyObject = isObj && !Object.keys(value).length;
      if (value === void 0 || isEmptyObject) {
        return accumulator;
      }
      return Object.assign(accumulator, {
        [key]: value
      });
    }, {});
  }
  function walkStats(stats, base, resultSet) {
    if (!base || resultSet.has(base.id)) {
      return;
    }
    resultSet.set(base.id, base);
    Object.keys(base).forEach((name) => {
      if (name.endsWith("Id")) {
        walkStats(stats, stats.get(base[name]), resultSet);
      } else if (name.endsWith("Ids")) {
        base[name].forEach((id) => {
          walkStats(stats, stats.get(id), resultSet);
        });
      }
    });
  }
  function filterStats(result, track, outbound) {
    const streamStatsType = outbound ? "outbound-rtp" : "inbound-rtp";
    const filteredResult = /* @__PURE__ */ new Map();
    if (track === null) {
      return filteredResult;
    }
    const trackStats = [];
    result.forEach((value) => {
      if (value.type === "track" && value.trackIdentifier === track.id) {
        trackStats.push(value);
      }
    });
    trackStats.forEach((trackStat) => {
      result.forEach((stats) => {
        if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
          walkStats(result, stats, filteredResult);
        }
      });
    });
    return filteredResult;
  }
  var logging = log;
  function shimGetUserMedia$2(window2, browserDetails2) {
    const navigator2 = window2 && window2.navigator;
    if (!navigator2.mediaDevices) {
      return;
    }
    const constraintsToChrome_ = function(c) {
      if (typeof c !== "object" || c.mandatory || c.optional) {
        return c;
      }
      const cc = {};
      Object.keys(c).forEach((key) => {
        if (key === "require" || key === "advanced" || key === "mediaSource") {
          return;
        }
        const r2 = typeof c[key] === "object" ? c[key] : {
          ideal: c[key]
        };
        if (r2.exact !== void 0 && typeof r2.exact === "number") {
          r2.min = r2.max = r2.exact;
        }
        const oldname_ = function(prefix, name) {
          if (prefix) {
            return prefix + name.charAt(0).toUpperCase() + name.slice(1);
          }
          return name === "deviceId" ? "sourceId" : name;
        };
        if (r2.ideal !== void 0) {
          cc.optional = cc.optional || [];
          let oc = {};
          if (typeof r2.ideal === "number") {
            oc[oldname_("min", key)] = r2.ideal;
            cc.optional.push(oc);
            oc = {};
            oc[oldname_("max", key)] = r2.ideal;
            cc.optional.push(oc);
          } else {
            oc[oldname_("", key)] = r2.ideal;
            cc.optional.push(oc);
          }
        }
        if (r2.exact !== void 0 && typeof r2.exact !== "number") {
          cc.mandatory = cc.mandatory || {};
          cc.mandatory[oldname_("", key)] = r2.exact;
        } else {
          ["min", "max"].forEach((mix) => {
            if (r2[mix] !== void 0) {
              cc.mandatory = cc.mandatory || {};
              cc.mandatory[oldname_(mix, key)] = r2[mix];
            }
          });
        }
      });
      if (c.advanced) {
        cc.optional = (cc.optional || []).concat(c.advanced);
      }
      return cc;
    };
    const shimConstraints_ = function(constraints, func) {
      if (browserDetails2.version >= 61) {
        return func(constraints);
      }
      constraints = JSON.parse(JSON.stringify(constraints));
      if (constraints && typeof constraints.audio === "object") {
        const remap = function(obj, a, b) {
          if (a in obj && !(b in obj)) {
            obj[b] = obj[a];
            delete obj[a];
          }
        };
        constraints = JSON.parse(JSON.stringify(constraints));
        remap(constraints.audio, "autoGainControl", "googAutoGainControl");
        remap(constraints.audio, "noiseSuppression", "googNoiseSuppression");
        constraints.audio = constraintsToChrome_(constraints.audio);
      }
      if (constraints && typeof constraints.video === "object") {
        let face = constraints.video.facingMode;
        face = face && (typeof face === "object" ? face : {
          ideal: face
        });
        const getSupportedFacingModeLies = browserDetails2.version < 66;
        if (face && (face.exact === "user" || face.exact === "environment" || face.ideal === "user" || face.ideal === "environment") && !(navigator2.mediaDevices.getSupportedConstraints && navigator2.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
          delete constraints.video.facingMode;
          let matches;
          if (face.exact === "environment" || face.ideal === "environment") {
            matches = ["back", "rear"];
          } else if (face.exact === "user" || face.ideal === "user") {
            matches = ["front"];
          }
          if (matches) {
            return navigator2.mediaDevices.enumerateDevices().then((devices) => {
              devices = devices.filter((d) => d.kind === "videoinput");
              let dev = devices.find((d) => matches.some((match) => d.label.toLowerCase().includes(match)));
              if (!dev && devices.length && matches.includes("back")) {
                dev = devices[devices.length - 1];
              }
              if (dev) {
                constraints.video.deviceId = face.exact ? {
                  exact: dev.deviceId
                } : {
                  ideal: dev.deviceId
                };
              }
              constraints.video = constraintsToChrome_(constraints.video);
              logging("chrome: " + JSON.stringify(constraints));
              return func(constraints);
            });
          }
        }
        constraints.video = constraintsToChrome_(constraints.video);
      }
      logging("chrome: " + JSON.stringify(constraints));
      return func(constraints);
    };
    const shimError_ = function(e) {
      if (browserDetails2.version >= 64) {
        return e;
      }
      return {
        name: {
          PermissionDeniedError: "NotAllowedError",
          PermissionDismissedError: "NotAllowedError",
          InvalidStateError: "NotAllowedError",
          DevicesNotFoundError: "NotFoundError",
          ConstraintNotSatisfiedError: "OverconstrainedError",
          TrackStartError: "NotReadableError",
          MediaDeviceFailedDueToShutdown: "NotAllowedError",
          MediaDeviceKillSwitchOn: "NotAllowedError",
          TabCaptureError: "AbortError",
          ScreenCaptureError: "AbortError",
          DeviceCaptureError: "AbortError"
        }[e.name] || e.name,
        message: e.message,
        constraint: e.constraint || e.constraintName,
        toString() {
          return this.name + (this.message && ": ") + this.message;
        }
      };
    };
    const getUserMedia_ = function(constraints, onSuccess, onError) {
      shimConstraints_(constraints, (c) => {
        navigator2.webkitGetUserMedia(c, onSuccess, (e) => {
          if (onError) {
            onError(shimError_(e));
          }
        });
      });
    };
    navigator2.getUserMedia = getUserMedia_.bind(navigator2);
    if (navigator2.mediaDevices.getUserMedia) {
      const origGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);
      navigator2.mediaDevices.getUserMedia = function(cs) {
        return shimConstraints_(cs, (c) => origGetUserMedia(c).then((stream4) => {
          if (c.audio && !stream4.getAudioTracks().length || c.video && !stream4.getVideoTracks().length) {
            stream4.getTracks().forEach((track) => {
              track.stop();
            });
            throw new DOMException("", "NotFoundError");
          }
          return stream4;
        }, (e) => Promise.reject(shimError_(e))));
      };
    }
  }
  function shimMediaStream(window2) {
    window2.MediaStream = window2.MediaStream || window2.webkitMediaStream;
  }
  function shimOnTrack$1(window2) {
    if (typeof window2 === "object" && window2.RTCPeerConnection && !("ontrack" in window2.RTCPeerConnection.prototype)) {
      Object.defineProperty(window2.RTCPeerConnection.prototype, "ontrack", {
        get() {
          return this._ontrack;
        },
        set(f) {
          if (this._ontrack) {
            this.removeEventListener("track", this._ontrack);
          }
          this.addEventListener("track", this._ontrack = f);
        },
        enumerable: true,
        configurable: true
      });
      const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
      window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
        if (!this._ontrackpoly) {
          this._ontrackpoly = (e) => {
            e.stream.addEventListener("addtrack", (te) => {
              let receiver;
              if (window2.RTCPeerConnection.prototype.getReceivers) {
                receiver = this.getReceivers().find((r2) => r2.track && r2.track.id === te.track.id);
              } else {
                receiver = {
                  track: te.track
                };
              }
              const event = new Event("track");
              event.track = te.track;
              event.receiver = receiver;
              event.transceiver = {
                receiver
              };
              event.streams = [e.stream];
              this.dispatchEvent(event);
            });
            e.stream.getTracks().forEach((track) => {
              let receiver;
              if (window2.RTCPeerConnection.prototype.getReceivers) {
                receiver = this.getReceivers().find((r2) => r2.track && r2.track.id === track.id);
              } else {
                receiver = {
                  track
                };
              }
              const event = new Event("track");
              event.track = track;
              event.receiver = receiver;
              event.transceiver = {
                receiver
              };
              event.streams = [e.stream];
              this.dispatchEvent(event);
            });
          };
          this.addEventListener("addstream", this._ontrackpoly);
        }
        return origSetRemoteDescription.apply(this, arguments);
      };
    } else {
      wrapPeerConnectionEvent(window2, "track", (e) => {
        if (!e.transceiver) {
          Object.defineProperty(e, "transceiver", {
            value: {
              receiver: e.receiver
            }
          });
        }
        return e;
      });
    }
  }
  function shimGetSendersWithDtmf(window2) {
    if (typeof window2 === "object" && window2.RTCPeerConnection && !("getSenders" in window2.RTCPeerConnection.prototype) && "createDTMFSender" in window2.RTCPeerConnection.prototype) {
      const shimSenderWithDtmf = function(pc, track) {
        return {
          track,
          get dtmf() {
            if (this._dtmf === void 0) {
              if (track.kind === "audio") {
                this._dtmf = pc.createDTMFSender(track);
              } else {
                this._dtmf = null;
              }
            }
            return this._dtmf;
          },
          _pc: pc
        };
      };
      if (!window2.RTCPeerConnection.prototype.getSenders) {
        window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
          this._senders = this._senders || [];
          return this._senders.slice();
        };
        const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
        window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream4) {
          let sender = origAddTrack.apply(this, arguments);
          if (!sender) {
            sender = shimSenderWithDtmf(this, track);
            this._senders.push(sender);
          }
          return sender;
        };
        const origRemoveTrack = window2.RTCPeerConnection.prototype.removeTrack;
        window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
          origRemoveTrack.apply(this, arguments);
          const idx = this._senders.indexOf(sender);
          if (idx !== -1) {
            this._senders.splice(idx, 1);
          }
        };
      }
      const origAddStream = window2.RTCPeerConnection.prototype.addStream;
      window2.RTCPeerConnection.prototype.addStream = function addStream(stream4) {
        this._senders = this._senders || [];
        origAddStream.apply(this, [stream4]);
        stream4.getTracks().forEach((track) => {
          this._senders.push(shimSenderWithDtmf(this, track));
        });
      };
      const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
      window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream4) {
        this._senders = this._senders || [];
        origRemoveStream.apply(this, [stream4]);
        stream4.getTracks().forEach((track) => {
          const sender = this._senders.find((s) => s.track === track);
          if (sender) {
            this._senders.splice(this._senders.indexOf(sender), 1);
          }
        });
      };
    } else if (typeof window2 === "object" && window2.RTCPeerConnection && "getSenders" in window2.RTCPeerConnection.prototype && "createDTMFSender" in window2.RTCPeerConnection.prototype && window2.RTCRtpSender && !("dtmf" in window2.RTCRtpSender.prototype)) {
      const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
      window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
        const senders = origGetSenders.apply(this, []);
        senders.forEach((sender) => sender._pc = this);
        return senders;
      };
      Object.defineProperty(window2.RTCRtpSender.prototype, "dtmf", {
        get() {
          if (this._dtmf === void 0) {
            if (this.track.kind === "audio") {
              this._dtmf = this._pc.createDTMFSender(this.track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        }
      });
    }
  }
  function shimSenderReceiverGetStats(window2) {
    if (!(typeof window2 === "object" && window2.RTCPeerConnection && window2.RTCRtpSender && window2.RTCRtpReceiver)) {
      return;
    }
    if (!("getStats" in window2.RTCRtpSender.prototype)) {
      const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
      if (origGetSenders) {
        window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
          const senders = origGetSenders.apply(this, []);
          senders.forEach((sender) => sender._pc = this);
          return senders;
        };
      }
      const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
      if (origAddTrack) {
        window2.RTCPeerConnection.prototype.addTrack = function addTrack() {
          const sender = origAddTrack.apply(this, arguments);
          sender._pc = this;
          return sender;
        };
      }
      window2.RTCRtpSender.prototype.getStats = function getStats() {
        const sender = this;
        return this._pc.getStats().then((result) => (
          /* Note: this will include stats of all senders that
           *   send a track with the same id as sender.track as
           *   it is not possible to identify the RTCRtpSender.
           */
          filterStats(result, sender.track, true)
        ));
      };
    }
    if (!("getStats" in window2.RTCRtpReceiver.prototype)) {
      const origGetReceivers = window2.RTCPeerConnection.prototype.getReceivers;
      if (origGetReceivers) {
        window2.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
          const receivers = origGetReceivers.apply(this, []);
          receivers.forEach((receiver) => receiver._pc = this);
          return receivers;
        };
      }
      wrapPeerConnectionEvent(window2, "track", (e) => {
        e.receiver._pc = e.srcElement;
        return e;
      });
      window2.RTCRtpReceiver.prototype.getStats = function getStats() {
        const receiver = this;
        return this._pc.getStats().then((result) => filterStats(result, receiver.track, false));
      };
    }
    if (!("getStats" in window2.RTCRtpSender.prototype && "getStats" in window2.RTCRtpReceiver.prototype)) {
      return;
    }
    const origGetStats = window2.RTCPeerConnection.prototype.getStats;
    window2.RTCPeerConnection.prototype.getStats = function getStats() {
      if (arguments.length > 0 && arguments[0] instanceof window2.MediaStreamTrack) {
        const track = arguments[0];
        let sender;
        let receiver;
        let err;
        this.getSenders().forEach((s) => {
          if (s.track === track) {
            if (sender) {
              err = true;
            } else {
              sender = s;
            }
          }
        });
        this.getReceivers().forEach((r2) => {
          if (r2.track === track) {
            if (receiver) {
              err = true;
            } else {
              receiver = r2;
            }
          }
          return r2.track === track;
        });
        if (err || sender && receiver) {
          return Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError"));
        } else if (sender) {
          return sender.getStats();
        } else if (receiver) {
          return receiver.getStats();
        }
        return Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
      }
      return origGetStats.apply(this, arguments);
    };
  }
  function shimAddTrackRemoveTrackWithNative(window2) {
    window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      return Object.keys(this._shimmedLocalStreams).map((streamId) => this._shimmedLocalStreams[streamId][0]);
    };
    const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
    window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream4) {
      if (!stream4) {
        return origAddTrack.apply(this, arguments);
      }
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      const sender = origAddTrack.apply(this, arguments);
      if (!this._shimmedLocalStreams[stream4.id]) {
        this._shimmedLocalStreams[stream4.id] = [stream4, sender];
      } else if (this._shimmedLocalStreams[stream4.id].indexOf(sender) === -1) {
        this._shimmedLocalStreams[stream4.id].push(sender);
      }
      return sender;
    };
    const origAddStream = window2.RTCPeerConnection.prototype.addStream;
    window2.RTCPeerConnection.prototype.addStream = function addStream(stream4) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      stream4.getTracks().forEach((track) => {
        const alreadyExists = this.getSenders().find((s) => s.track === track);
        if (alreadyExists) {
          throw new DOMException("Track already exists.", "InvalidAccessError");
        }
      });
      const existingSenders = this.getSenders();
      origAddStream.apply(this, arguments);
      const newSenders = this.getSenders().filter((newSender) => existingSenders.indexOf(newSender) === -1);
      this._shimmedLocalStreams[stream4.id] = [stream4].concat(newSenders);
    };
    const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
    window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream4) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      delete this._shimmedLocalStreams[stream4.id];
      return origRemoveStream.apply(this, arguments);
    };
    const origRemoveTrack = window2.RTCPeerConnection.prototype.removeTrack;
    window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      if (sender) {
        Object.keys(this._shimmedLocalStreams).forEach((streamId) => {
          const idx = this._shimmedLocalStreams[streamId].indexOf(sender);
          if (idx !== -1) {
            this._shimmedLocalStreams[streamId].splice(idx, 1);
          }
          if (this._shimmedLocalStreams[streamId].length === 1) {
            delete this._shimmedLocalStreams[streamId];
          }
        });
      }
      return origRemoveTrack.apply(this, arguments);
    };
  }
  function shimAddTrackRemoveTrack(window2, browserDetails2) {
    if (!window2.RTCPeerConnection) {
      return;
    }
    if (window2.RTCPeerConnection.prototype.addTrack && browserDetails2.version >= 65) {
      return shimAddTrackRemoveTrackWithNative(window2);
    }
    const origGetLocalStreams = window2.RTCPeerConnection.prototype.getLocalStreams;
    window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
      const nativeStreams = origGetLocalStreams.apply(this);
      this._reverseStreams = this._reverseStreams || {};
      return nativeStreams.map((stream4) => this._reverseStreams[stream4.id]);
    };
    const origAddStream = window2.RTCPeerConnection.prototype.addStream;
    window2.RTCPeerConnection.prototype.addStream = function addStream(stream4) {
      this._streams = this._streams || {};
      this._reverseStreams = this._reverseStreams || {};
      stream4.getTracks().forEach((track) => {
        const alreadyExists = this.getSenders().find((s) => s.track === track);
        if (alreadyExists) {
          throw new DOMException("Track already exists.", "InvalidAccessError");
        }
      });
      if (!this._reverseStreams[stream4.id]) {
        const newStream = new window2.MediaStream(stream4.getTracks());
        this._streams[stream4.id] = newStream;
        this._reverseStreams[newStream.id] = stream4;
        stream4 = newStream;
      }
      origAddStream.apply(this, [stream4]);
    };
    const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
    window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream4) {
      this._streams = this._streams || {};
      this._reverseStreams = this._reverseStreams || {};
      origRemoveStream.apply(this, [this._streams[stream4.id] || stream4]);
      delete this._reverseStreams[this._streams[stream4.id] ? this._streams[stream4.id].id : stream4.id];
      delete this._streams[stream4.id];
    };
    window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream4) {
      if (this.signalingState === "closed") {
        throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
      }
      const streams = [].slice.call(arguments, 1);
      if (streams.length !== 1 || !streams[0].getTracks().find((t) => t === track)) {
        throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
      }
      const alreadyExists = this.getSenders().find((s) => s.track === track);
      if (alreadyExists) {
        throw new DOMException("Track already exists.", "InvalidAccessError");
      }
      this._streams = this._streams || {};
      this._reverseStreams = this._reverseStreams || {};
      const oldStream = this._streams[stream4.id];
      if (oldStream) {
        oldStream.addTrack(track);
        Promise.resolve().then(() => {
          this.dispatchEvent(new Event("negotiationneeded"));
        });
      } else {
        const newStream = new window2.MediaStream([track]);
        this._streams[stream4.id] = newStream;
        this._reverseStreams[newStream.id] = stream4;
        this.addStream(newStream);
      }
      return this.getSenders().find((s) => s.track === track);
    };
    function replaceInternalStreamId(pc, description) {
      let sdp2 = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach((internalId) => {
        const externalStream = pc._reverseStreams[internalId];
        const internalStream = pc._streams[externalStream.id];
        sdp2 = sdp2.replace(new RegExp(internalStream.id, "g"), externalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp: sdp2
      });
    }
    function replaceExternalStreamId(pc, description) {
      let sdp2 = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach((internalId) => {
        const externalStream = pc._reverseStreams[internalId];
        const internalStream = pc._streams[externalStream.id];
        sdp2 = sdp2.replace(new RegExp(externalStream.id, "g"), internalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp: sdp2
      });
    }
    ["createOffer", "createAnswer"].forEach(function(method) {
      const nativeMethod = window2.RTCPeerConnection.prototype[method];
      const methodObj = {
        [method]() {
          const args = arguments;
          const isLegacyCall = arguments.length && typeof arguments[0] === "function";
          if (isLegacyCall) {
            return nativeMethod.apply(this, [(description) => {
              const desc = replaceInternalStreamId(this, description);
              args[0].apply(null, [desc]);
            }, (err) => {
              if (args[1]) {
                args[1].apply(null, err);
              }
            }, arguments[2]]);
          }
          return nativeMethod.apply(this, arguments).then((description) => replaceInternalStreamId(this, description));
        }
      };
      window2.RTCPeerConnection.prototype[method] = methodObj[method];
    });
    const origSetLocalDescription = window2.RTCPeerConnection.prototype.setLocalDescription;
    window2.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
      if (!arguments.length || !arguments[0].type) {
        return origSetLocalDescription.apply(this, arguments);
      }
      arguments[0] = replaceExternalStreamId(this, arguments[0]);
      return origSetLocalDescription.apply(this, arguments);
    };
    const origLocalDescription = Object.getOwnPropertyDescriptor(window2.RTCPeerConnection.prototype, "localDescription");
    Object.defineProperty(window2.RTCPeerConnection.prototype, "localDescription", {
      get() {
        const description = origLocalDescription.get.apply(this);
        if (description.type === "") {
          return description;
        }
        return replaceInternalStreamId(this, description);
      }
    });
    window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
      if (this.signalingState === "closed") {
        throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
      }
      if (!sender._pc) {
        throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
      }
      const isLocal = sender._pc === this;
      if (!isLocal) {
        throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
      }
      this._streams = this._streams || {};
      let stream4;
      Object.keys(this._streams).forEach((streamid) => {
        const hasTrack = this._streams[streamid].getTracks().find((track) => sender.track === track);
        if (hasTrack) {
          stream4 = this._streams[streamid];
        }
      });
      if (stream4) {
        if (stream4.getTracks().length === 1) {
          this.removeStream(this._reverseStreams[stream4.id]);
        } else {
          stream4.removeTrack(sender.track);
        }
        this.dispatchEvent(new Event("negotiationneeded"));
      }
    };
  }
  function shimPeerConnection$1(window2, browserDetails2) {
    if (!window2.RTCPeerConnection && window2.webkitRTCPeerConnection) {
      window2.RTCPeerConnection = window2.webkitRTCPeerConnection;
    }
    if (!window2.RTCPeerConnection) {
      return;
    }
    if (browserDetails2.version < 53) {
      ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(method) {
        const nativeMethod = window2.RTCPeerConnection.prototype[method];
        const methodObj = {
          [method]() {
            arguments[0] = new (method === "addIceCandidate" ? window2.RTCIceCandidate : window2.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          }
        };
        window2.RTCPeerConnection.prototype[method] = methodObj[method];
      });
    }
  }
  function fixNegotiationNeeded(window2, browserDetails2) {
    wrapPeerConnectionEvent(window2, "negotiationneeded", (e) => {
      const pc = e.target;
      if (browserDetails2.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === "plan-b") {
        if (pc.signalingState !== "stable") {
          return;
        }
      }
      return e;
    });
  }
  var chromeShim = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    fixNegotiationNeeded,
    shimAddTrackRemoveTrack,
    shimAddTrackRemoveTrackWithNative,
    shimGetSendersWithDtmf,
    shimGetUserMedia: shimGetUserMedia$2,
    shimMediaStream,
    shimOnTrack: shimOnTrack$1,
    shimPeerConnection: shimPeerConnection$1,
    shimSenderReceiverGetStats
  });
  function shimGetUserMedia$1(window2, browserDetails2) {
    const navigator2 = window2 && window2.navigator;
    const MediaStreamTrack2 = window2 && window2.MediaStreamTrack;
    navigator2.getUserMedia = function(constraints, onSuccess, onError) {
      deprecated("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia");
      navigator2.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
    };
    if (!(browserDetails2.version > 55 && "autoGainControl" in navigator2.mediaDevices.getSupportedConstraints())) {
      const remap = function(obj, a, b) {
        if (a in obj && !(b in obj)) {
          obj[b] = obj[a];
          delete obj[a];
        }
      };
      const nativeGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);
      navigator2.mediaDevices.getUserMedia = function(c) {
        if (typeof c === "object" && typeof c.audio === "object") {
          c = JSON.parse(JSON.stringify(c));
          remap(c.audio, "autoGainControl", "mozAutoGainControl");
          remap(c.audio, "noiseSuppression", "mozNoiseSuppression");
        }
        return nativeGetUserMedia(c);
      };
      if (MediaStreamTrack2 && MediaStreamTrack2.prototype.getSettings) {
        const nativeGetSettings = MediaStreamTrack2.prototype.getSettings;
        MediaStreamTrack2.prototype.getSettings = function() {
          const obj = nativeGetSettings.apply(this, arguments);
          remap(obj, "mozAutoGainControl", "autoGainControl");
          remap(obj, "mozNoiseSuppression", "noiseSuppression");
          return obj;
        };
      }
      if (MediaStreamTrack2 && MediaStreamTrack2.prototype.applyConstraints) {
        const nativeApplyConstraints = MediaStreamTrack2.prototype.applyConstraints;
        MediaStreamTrack2.prototype.applyConstraints = function(c) {
          if (this.kind === "audio" && typeof c === "object") {
            c = JSON.parse(JSON.stringify(c));
            remap(c, "autoGainControl", "mozAutoGainControl");
            remap(c, "noiseSuppression", "mozNoiseSuppression");
          }
          return nativeApplyConstraints.apply(this, [c]);
        };
      }
    }
  }
  function shimGetDisplayMedia(window2, preferredMediaSource) {
    if (window2.navigator.mediaDevices && "getDisplayMedia" in window2.navigator.mediaDevices) {
      return;
    }
    if (!window2.navigator.mediaDevices) {
      return;
    }
    window2.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
      if (!(constraints && constraints.video)) {
        const err = new DOMException("getDisplayMedia without video constraints is undefined");
        err.name = "NotFoundError";
        err.code = 8;
        return Promise.reject(err);
      }
      if (constraints.video === true) {
        constraints.video = {
          mediaSource: preferredMediaSource
        };
      } else {
        constraints.video.mediaSource = preferredMediaSource;
      }
      return window2.navigator.mediaDevices.getUserMedia(constraints);
    };
  }
  function shimOnTrack(window2) {
    if (typeof window2 === "object" && window2.RTCTrackEvent && "receiver" in window2.RTCTrackEvent.prototype && !("transceiver" in window2.RTCTrackEvent.prototype)) {
      Object.defineProperty(window2.RTCTrackEvent.prototype, "transceiver", {
        get() {
          return {
            receiver: this.receiver
          };
        }
      });
    }
  }
  function shimPeerConnection(window2, browserDetails2) {
    if (typeof window2 !== "object" || !(window2.RTCPeerConnection || window2.mozRTCPeerConnection)) {
      return;
    }
    if (!window2.RTCPeerConnection && window2.mozRTCPeerConnection) {
      window2.RTCPeerConnection = window2.mozRTCPeerConnection;
    }
    if (browserDetails2.version < 53) {
      ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(method) {
        const nativeMethod = window2.RTCPeerConnection.prototype[method];
        const methodObj = {
          [method]() {
            arguments[0] = new (method === "addIceCandidate" ? window2.RTCIceCandidate : window2.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          }
        };
        window2.RTCPeerConnection.prototype[method] = methodObj[method];
      });
    }
    const modernStatsTypes = {
      inboundrtp: "inbound-rtp",
      outboundrtp: "outbound-rtp",
      candidatepair: "candidate-pair",
      localcandidate: "local-candidate",
      remotecandidate: "remote-candidate"
    };
    const nativeGetStats = window2.RTCPeerConnection.prototype.getStats;
    window2.RTCPeerConnection.prototype.getStats = function getStats() {
      const [selector, onSucc, onErr] = arguments;
      return nativeGetStats.apply(this, [selector || null]).then((stats) => {
        if (browserDetails2.version < 53 && !onSucc) {
          try {
            stats.forEach((stat) => {
              stat.type = modernStatsTypes[stat.type] || stat.type;
            });
          } catch (e) {
            if (e.name !== "TypeError") {
              throw e;
            }
            stats.forEach((stat, i) => {
              stats.set(i, Object.assign({}, stat, {
                type: modernStatsTypes[stat.type] || stat.type
              }));
            });
          }
        }
        return stats;
      }).then(onSucc, onErr);
    };
  }
  function shimSenderGetStats(window2) {
    if (!(typeof window2 === "object" && window2.RTCPeerConnection && window2.RTCRtpSender)) {
      return;
    }
    if (window2.RTCRtpSender && "getStats" in window2.RTCRtpSender.prototype) {
      return;
    }
    const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
        const senders = origGetSenders.apply(this, []);
        senders.forEach((sender) => sender._pc = this);
        return senders;
      };
    }
    const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window2.RTCPeerConnection.prototype.addTrack = function addTrack() {
        const sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      };
    }
    window2.RTCRtpSender.prototype.getStats = function getStats() {
      return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());
    };
  }
  function shimReceiverGetStats(window2) {
    if (!(typeof window2 === "object" && window2.RTCPeerConnection && window2.RTCRtpSender)) {
      return;
    }
    if (window2.RTCRtpSender && "getStats" in window2.RTCRtpReceiver.prototype) {
      return;
    }
    const origGetReceivers = window2.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window2.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
        const receivers = origGetReceivers.apply(this, []);
        receivers.forEach((receiver) => receiver._pc = this);
        return receivers;
      };
    }
    wrapPeerConnectionEvent(window2, "track", (e) => {
      e.receiver._pc = e.srcElement;
      return e;
    });
    window2.RTCRtpReceiver.prototype.getStats = function getStats() {
      return this._pc.getStats(this.track);
    };
  }
  function shimRemoveStream(window2) {
    if (!window2.RTCPeerConnection || "removeStream" in window2.RTCPeerConnection.prototype) {
      return;
    }
    window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream4) {
      deprecated("removeStream", "removeTrack");
      this.getSenders().forEach((sender) => {
        if (sender.track && stream4.getTracks().includes(sender.track)) {
          this.removeTrack(sender);
        }
      });
    };
  }
  function shimRTCDataChannel(window2) {
    if (window2.DataChannel && !window2.RTCDataChannel) {
      window2.RTCDataChannel = window2.DataChannel;
    }
  }
  function shimAddTransceiver(window2) {
    if (!(typeof window2 === "object" && window2.RTCPeerConnection)) {
      return;
    }
    const origAddTransceiver = window2.RTCPeerConnection.prototype.addTransceiver;
    if (origAddTransceiver) {
      window2.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {
        this.setParametersPromises = [];
        let sendEncodings = arguments[1] && arguments[1].sendEncodings;
        if (sendEncodings === void 0) {
          sendEncodings = [];
        }
        sendEncodings = [...sendEncodings];
        const shouldPerformCheck = sendEncodings.length > 0;
        if (shouldPerformCheck) {
          sendEncodings.forEach((encodingParam) => {
            if ("rid" in encodingParam) {
              const ridRegex = /^[a-z0-9]{0,16}$/i;
              if (!ridRegex.test(encodingParam.rid)) {
                throw new TypeError("Invalid RID value provided.");
              }
            }
            if ("scaleResolutionDownBy" in encodingParam) {
              if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1)) {
                throw new RangeError("scale_resolution_down_by must be >= 1.0");
              }
            }
            if ("maxFramerate" in encodingParam) {
              if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {
                throw new RangeError("max_framerate must be >= 0.0");
              }
            }
          });
        }
        const transceiver = origAddTransceiver.apply(this, arguments);
        if (shouldPerformCheck) {
          const {
            sender
          } = transceiver;
          const params = sender.getParameters();
          if (!("encodings" in params) || // Avoid being fooled by patched getParameters() below.
          params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {
            params.encodings = sendEncodings;
            sender.sendEncodings = sendEncodings;
            this.setParametersPromises.push(sender.setParameters(params).then(() => {
              delete sender.sendEncodings;
            }).catch(() => {
              delete sender.sendEncodings;
            }));
          }
        }
        return transceiver;
      };
    }
  }
  function shimGetParameters(window2) {
    if (!(typeof window2 === "object" && window2.RTCRtpSender)) {
      return;
    }
    const origGetParameters = window2.RTCRtpSender.prototype.getParameters;
    if (origGetParameters) {
      window2.RTCRtpSender.prototype.getParameters = function getParameters() {
        const params = origGetParameters.apply(this, arguments);
        if (!("encodings" in params)) {
          params.encodings = [].concat(this.sendEncodings || [{}]);
        }
        return params;
      };
    }
  }
  function shimCreateOffer(window2) {
    if (!(typeof window2 === "object" && window2.RTCPeerConnection)) {
      return;
    }
    const origCreateOffer = window2.RTCPeerConnection.prototype.createOffer;
    window2.RTCPeerConnection.prototype.createOffer = function createOffer() {
      if (this.setParametersPromises && this.setParametersPromises.length) {
        return Promise.all(this.setParametersPromises).then(() => {
          return origCreateOffer.apply(this, arguments);
        }).finally(() => {
          this.setParametersPromises = [];
        });
      }
      return origCreateOffer.apply(this, arguments);
    };
  }
  function shimCreateAnswer(window2) {
    if (!(typeof window2 === "object" && window2.RTCPeerConnection)) {
      return;
    }
    const origCreateAnswer = window2.RTCPeerConnection.prototype.createAnswer;
    window2.RTCPeerConnection.prototype.createAnswer = function createAnswer() {
      if (this.setParametersPromises && this.setParametersPromises.length) {
        return Promise.all(this.setParametersPromises).then(() => {
          return origCreateAnswer.apply(this, arguments);
        }).finally(() => {
          this.setParametersPromises = [];
        });
      }
      return origCreateAnswer.apply(this, arguments);
    };
  }
  var firefoxShim = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    shimAddTransceiver,
    shimCreateAnswer,
    shimCreateOffer,
    shimGetDisplayMedia,
    shimGetParameters,
    shimGetUserMedia: shimGetUserMedia$1,
    shimOnTrack,
    shimPeerConnection,
    shimRTCDataChannel,
    shimReceiverGetStats,
    shimRemoveStream,
    shimSenderGetStats
  });
  function shimLocalStreamsAPI(window2) {
    if (typeof window2 !== "object" || !window2.RTCPeerConnection) {
      return;
    }
    if (!("getLocalStreams" in window2.RTCPeerConnection.prototype)) {
      window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        return this._localStreams;
      };
    }
    if (!("addStream" in window2.RTCPeerConnection.prototype)) {
      const _addTrack = window2.RTCPeerConnection.prototype.addTrack;
      window2.RTCPeerConnection.prototype.addStream = function addStream(stream4) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        if (!this._localStreams.includes(stream4)) {
          this._localStreams.push(stream4);
        }
        stream4.getAudioTracks().forEach((track) => _addTrack.call(this, track, stream4));
        stream4.getVideoTracks().forEach((track) => _addTrack.call(this, track, stream4));
      };
      window2.RTCPeerConnection.prototype.addTrack = function addTrack(track) {
        for (var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          streams[_key - 1] = arguments[_key];
        }
        if (streams) {
          streams.forEach((stream4) => {
            if (!this._localStreams) {
              this._localStreams = [stream4];
            } else if (!this._localStreams.includes(stream4)) {
              this._localStreams.push(stream4);
            }
          });
        }
        return _addTrack.apply(this, arguments);
      };
    }
    if (!("removeStream" in window2.RTCPeerConnection.prototype)) {
      window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream4) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        const index = this._localStreams.indexOf(stream4);
        if (index === -1) {
          return;
        }
        this._localStreams.splice(index, 1);
        const tracks = stream4.getTracks();
        this.getSenders().forEach((sender) => {
          if (tracks.includes(sender.track)) {
            this.removeTrack(sender);
          }
        });
      };
    }
  }
  function shimRemoteStreamsAPI(window2) {
    if (typeof window2 !== "object" || !window2.RTCPeerConnection) {
      return;
    }
    if (!("getRemoteStreams" in window2.RTCPeerConnection.prototype)) {
      window2.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {
        return this._remoteStreams ? this._remoteStreams : [];
      };
    }
    if (!("onaddstream" in window2.RTCPeerConnection.prototype)) {
      Object.defineProperty(window2.RTCPeerConnection.prototype, "onaddstream", {
        get() {
          return this._onaddstream;
        },
        set(f) {
          if (this._onaddstream) {
            this.removeEventListener("addstream", this._onaddstream);
            this.removeEventListener("track", this._onaddstreampoly);
          }
          this.addEventListener("addstream", this._onaddstream = f);
          this.addEventListener("track", this._onaddstreampoly = (e) => {
            e.streams.forEach((stream4) => {
              if (!this._remoteStreams) {
                this._remoteStreams = [];
              }
              if (this._remoteStreams.includes(stream4)) {
                return;
              }
              this._remoteStreams.push(stream4);
              const event = new Event("addstream");
              event.stream = stream4;
              this.dispatchEvent(event);
            });
          });
        }
      });
      const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
      window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
        const pc = this;
        if (!this._onaddstreampoly) {
          this.addEventListener("track", this._onaddstreampoly = function(e) {
            e.streams.forEach((stream4) => {
              if (!pc._remoteStreams) {
                pc._remoteStreams = [];
              }
              if (pc._remoteStreams.indexOf(stream4) >= 0) {
                return;
              }
              pc._remoteStreams.push(stream4);
              const event = new Event("addstream");
              event.stream = stream4;
              pc.dispatchEvent(event);
            });
          });
        }
        return origSetRemoteDescription.apply(pc, arguments);
      };
    }
  }
  function shimCallbacksAPI(window2) {
    if (typeof window2 !== "object" || !window2.RTCPeerConnection) {
      return;
    }
    const prototype3 = window2.RTCPeerConnection.prototype;
    const origCreateOffer = prototype3.createOffer;
    const origCreateAnswer = prototype3.createAnswer;
    const setLocalDescription = prototype3.setLocalDescription;
    const setRemoteDescription = prototype3.setRemoteDescription;
    const addIceCandidate = prototype3.addIceCandidate;
    prototype3.createOffer = function createOffer(successCallback, failureCallback) {
      const options = arguments.length >= 2 ? arguments[2] : arguments[0];
      const promise = origCreateOffer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype3.createAnswer = function createAnswer(successCallback, failureCallback) {
      const options = arguments.length >= 2 ? arguments[2] : arguments[0];
      const promise = origCreateAnswer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    let withCallback = function(description, successCallback, failureCallback) {
      const promise = setLocalDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype3.setLocalDescription = withCallback;
    withCallback = function(description, successCallback, failureCallback) {
      const promise = setRemoteDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype3.setRemoteDescription = withCallback;
    withCallback = function(candidate, successCallback, failureCallback) {
      const promise = addIceCandidate.apply(this, [candidate]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype3.addIceCandidate = withCallback;
  }
  function shimGetUserMedia(window2) {
    const navigator2 = window2 && window2.navigator;
    if (navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {
      const mediaDevices = navigator2.mediaDevices;
      const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
      navigator2.mediaDevices.getUserMedia = (constraints) => {
        return _getUserMedia(shimConstraints(constraints));
      };
    }
    if (!navigator2.getUserMedia && navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {
      navigator2.getUserMedia = function getUserMedia(constraints, cb, errcb) {
        navigator2.mediaDevices.getUserMedia(constraints).then(cb, errcb);
      }.bind(navigator2);
    }
  }
  function shimConstraints(constraints) {
    if (constraints && constraints.video !== void 0) {
      return Object.assign({}, constraints, {
        video: compactObject(constraints.video)
      });
    }
    return constraints;
  }
  function shimRTCIceServerUrls(window2) {
    if (!window2.RTCPeerConnection) {
      return;
    }
    const OrigPeerConnection = window2.RTCPeerConnection;
    window2.RTCPeerConnection = function RTCPeerConnection2(pcConfig, pcConstraints) {
      if (pcConfig && pcConfig.iceServers) {
        const newIceServers = [];
        for (let i = 0; i < pcConfig.iceServers.length; i++) {
          let server = pcConfig.iceServers[i];
          if (server.urls === void 0 && server.url) {
            deprecated("RTCIceServer.url", "RTCIceServer.urls");
            server = JSON.parse(JSON.stringify(server));
            server.urls = server.url;
            delete server.url;
            newIceServers.push(server);
          } else {
            newIceServers.push(pcConfig.iceServers[i]);
          }
        }
        pcConfig.iceServers = newIceServers;
      }
      return new OrigPeerConnection(pcConfig, pcConstraints);
    };
    window2.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
    if ("generateCertificate" in OrigPeerConnection) {
      Object.defineProperty(window2.RTCPeerConnection, "generateCertificate", {
        get() {
          return OrigPeerConnection.generateCertificate;
        }
      });
    }
  }
  function shimTrackEventTransceiver(window2) {
    if (typeof window2 === "object" && window2.RTCTrackEvent && "receiver" in window2.RTCTrackEvent.prototype && !("transceiver" in window2.RTCTrackEvent.prototype)) {
      Object.defineProperty(window2.RTCTrackEvent.prototype, "transceiver", {
        get() {
          return {
            receiver: this.receiver
          };
        }
      });
    }
  }
  function shimCreateOfferLegacy(window2) {
    const origCreateOffer = window2.RTCPeerConnection.prototype.createOffer;
    window2.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {
      if (offerOptions) {
        if (typeof offerOptions.offerToReceiveAudio !== "undefined") {
          offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
        }
        const audioTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === "audio");
        if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
          if (audioTransceiver.direction === "sendrecv") {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection("sendonly");
            } else {
              audioTransceiver.direction = "sendonly";
            }
          } else if (audioTransceiver.direction === "recvonly") {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection("inactive");
            } else {
              audioTransceiver.direction = "inactive";
            }
          }
        } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
          this.addTransceiver("audio", {
            direction: "recvonly"
          });
        }
        if (typeof offerOptions.offerToReceiveVideo !== "undefined") {
          offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
        }
        const videoTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === "video");
        if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
          if (videoTransceiver.direction === "sendrecv") {
            if (videoTransceiver.setDirection) {
              videoTransceiver.setDirection("sendonly");
            } else {
              videoTransceiver.direction = "sendonly";
            }
          } else if (videoTransceiver.direction === "recvonly") {
            if (videoTransceiver.setDirection) {
              videoTransceiver.setDirection("inactive");
            } else {
              videoTransceiver.direction = "inactive";
            }
          }
        } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
          this.addTransceiver("video", {
            direction: "recvonly"
          });
        }
      }
      return origCreateOffer.apply(this, arguments);
    };
  }
  function shimAudioContext(window2) {
    if (typeof window2 !== "object" || window2.AudioContext) {
      return;
    }
    window2.AudioContext = window2.webkitAudioContext;
  }
  var safariShim = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    shimAudioContext,
    shimCallbacksAPI,
    shimConstraints,
    shimCreateOfferLegacy,
    shimGetUserMedia,
    shimLocalStreamsAPI,
    shimRTCIceServerUrls,
    shimRemoteStreamsAPI,
    shimTrackEventTransceiver
  });
  var sdp$1 = { exports: {} };
  var hasRequiredSdp;
  function requireSdp() {
    if (hasRequiredSdp) return sdp$1.exports;
    hasRequiredSdp = 1;
    (function(module) {
      const SDPUtils2 = {};
      SDPUtils2.generateIdentifier = function() {
        return Math.random().toString(36).substring(2, 12);
      };
      SDPUtils2.localCName = SDPUtils2.generateIdentifier();
      SDPUtils2.splitLines = function(blob) {
        return blob.trim().split("\n").map((line) => line.trim());
      };
      SDPUtils2.splitSections = function(blob) {
        const parts = blob.split("\nm=");
        return parts.map((part, index) => (index > 0 ? "m=" + part : part).trim() + "\r\n");
      };
      SDPUtils2.getDescription = function(blob) {
        const sections = SDPUtils2.splitSections(blob);
        return sections && sections[0];
      };
      SDPUtils2.getMediaSections = function(blob) {
        const sections = SDPUtils2.splitSections(blob);
        sections.shift();
        return sections;
      };
      SDPUtils2.matchPrefix = function(blob, prefix) {
        return SDPUtils2.splitLines(blob).filter((line) => line.indexOf(prefix) === 0);
      };
      SDPUtils2.parseCandidate = function(line) {
        let parts;
        if (line.indexOf("a=candidate:") === 0) {
          parts = line.substring(12).split(" ");
        } else {
          parts = line.substring(10).split(" ");
        }
        const candidate = {
          foundation: parts[0],
          component: {
            1: "rtp",
            2: "rtcp"
          }[parts[1]] || parts[1],
          protocol: parts[2].toLowerCase(),
          priority: parseInt(parts[3], 10),
          ip: parts[4],
          address: parts[4],
          // address is an alias for ip.
          port: parseInt(parts[5], 10),
          // skip parts[6] == 'typ'
          type: parts[7]
        };
        for (let i = 8; i < parts.length; i += 2) {
          switch (parts[i]) {
            case "raddr":
              candidate.relatedAddress = parts[i + 1];
              break;
            case "rport":
              candidate.relatedPort = parseInt(parts[i + 1], 10);
              break;
            case "tcptype":
              candidate.tcpType = parts[i + 1];
              break;
            case "ufrag":
              candidate.ufrag = parts[i + 1];
              candidate.usernameFragment = parts[i + 1];
              break;
            default:
              if (candidate[parts[i]] === void 0) {
                candidate[parts[i]] = parts[i + 1];
              }
              break;
          }
        }
        return candidate;
      };
      SDPUtils2.writeCandidate = function(candidate) {
        const sdp2 = [];
        sdp2.push(candidate.foundation);
        const component = candidate.component;
        if (component === "rtp") {
          sdp2.push(1);
        } else if (component === "rtcp") {
          sdp2.push(2);
        } else {
          sdp2.push(component);
        }
        sdp2.push(candidate.protocol.toUpperCase());
        sdp2.push(candidate.priority);
        sdp2.push(candidate.address || candidate.ip);
        sdp2.push(candidate.port);
        const type = candidate.type;
        sdp2.push("typ");
        sdp2.push(type);
        if (type !== "host" && candidate.relatedAddress && candidate.relatedPort) {
          sdp2.push("raddr");
          sdp2.push(candidate.relatedAddress);
          sdp2.push("rport");
          sdp2.push(candidate.relatedPort);
        }
        if (candidate.tcpType && candidate.protocol.toLowerCase() === "tcp") {
          sdp2.push("tcptype");
          sdp2.push(candidate.tcpType);
        }
        if (candidate.usernameFragment || candidate.ufrag) {
          sdp2.push("ufrag");
          sdp2.push(candidate.usernameFragment || candidate.ufrag);
        }
        return "candidate:" + sdp2.join(" ");
      };
      SDPUtils2.parseIceOptions = function(line) {
        return line.substring(14).split(" ");
      };
      SDPUtils2.parseRtpMap = function(line) {
        let parts = line.substring(9).split(" ");
        const parsed = {
          payloadType: parseInt(parts.shift(), 10)
          // was: id
        };
        parts = parts[0].split("/");
        parsed.name = parts[0];
        parsed.clockRate = parseInt(parts[1], 10);
        parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
        parsed.numChannels = parsed.channels;
        return parsed;
      };
      SDPUtils2.writeRtpMap = function(codec) {
        let pt = codec.payloadType;
        if (codec.preferredPayloadType !== void 0) {
          pt = codec.preferredPayloadType;
        }
        const channels = codec.channels || codec.numChannels || 1;
        return "a=rtpmap:" + pt + " " + codec.name + "/" + codec.clockRate + (channels !== 1 ? "/" + channels : "") + "\r\n";
      };
      SDPUtils2.parseExtmap = function(line) {
        const parts = line.substring(9).split(" ");
        return {
          id: parseInt(parts[0], 10),
          direction: parts[0].indexOf("/") > 0 ? parts[0].split("/")[1] : "sendrecv",
          uri: parts[1],
          attributes: parts.slice(2).join(" ")
        };
      };
      SDPUtils2.writeExtmap = function(headerExtension) {
        return "a=extmap:" + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== "sendrecv" ? "/" + headerExtension.direction : "") + " " + headerExtension.uri + (headerExtension.attributes ? " " + headerExtension.attributes : "") + "\r\n";
      };
      SDPUtils2.parseFmtp = function(line) {
        const parsed = {};
        let kv;
        const parts = line.substring(line.indexOf(" ") + 1).split(";");
        for (let j = 0; j < parts.length; j++) {
          kv = parts[j].trim().split("=");
          parsed[kv[0].trim()] = kv[1];
        }
        return parsed;
      };
      SDPUtils2.writeFmtp = function(codec) {
        let line = "";
        let pt = codec.payloadType;
        if (codec.preferredPayloadType !== void 0) {
          pt = codec.preferredPayloadType;
        }
        if (codec.parameters && Object.keys(codec.parameters).length) {
          const params = [];
          Object.keys(codec.parameters).forEach((param) => {
            if (codec.parameters[param] !== void 0) {
              params.push(param + "=" + codec.parameters[param]);
            } else {
              params.push(param);
            }
          });
          line += "a=fmtp:" + pt + " " + params.join(";") + "\r\n";
        }
        return line;
      };
      SDPUtils2.parseRtcpFb = function(line) {
        const parts = line.substring(line.indexOf(" ") + 1).split(" ");
        return {
          type: parts.shift(),
          parameter: parts.join(" ")
        };
      };
      SDPUtils2.writeRtcpFb = function(codec) {
        let lines = "";
        let pt = codec.payloadType;
        if (codec.preferredPayloadType !== void 0) {
          pt = codec.preferredPayloadType;
        }
        if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
          codec.rtcpFeedback.forEach((fb) => {
            lines += "a=rtcp-fb:" + pt + " " + fb.type + (fb.parameter && fb.parameter.length ? " " + fb.parameter : "") + "\r\n";
          });
        }
        return lines;
      };
      SDPUtils2.parseSsrcMedia = function(line) {
        const sp = line.indexOf(" ");
        const parts = {
          ssrc: parseInt(line.substring(7, sp), 10)
        };
        const colon = line.indexOf(":", sp);
        if (colon > -1) {
          parts.attribute = line.substring(sp + 1, colon);
          parts.value = line.substring(colon + 1);
        } else {
          parts.attribute = line.substring(sp + 1);
        }
        return parts;
      };
      SDPUtils2.parseSsrcGroup = function(line) {
        const parts = line.substring(13).split(" ");
        return {
          semantics: parts.shift(),
          ssrcs: parts.map((ssrc) => parseInt(ssrc, 10))
        };
      };
      SDPUtils2.getMid = function(mediaSection) {
        const mid = SDPUtils2.matchPrefix(mediaSection, "a=mid:")[0];
        if (mid) {
          return mid.substring(6);
        }
      };
      SDPUtils2.parseFingerprint = function(line) {
        const parts = line.substring(14).split(" ");
        return {
          algorithm: parts[0].toLowerCase(),
          // algorithm is case-sensitive in Edge.
          value: parts[1].toUpperCase()
          // the definition is upper-case in RFC 4572.
        };
      };
      SDPUtils2.getDtlsParameters = function(mediaSection, sessionpart) {
        const lines = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=fingerprint:");
        return {
          role: "auto",
          fingerprints: lines.map(SDPUtils2.parseFingerprint)
        };
      };
      SDPUtils2.writeDtlsParameters = function(params, setupType) {
        let sdp2 = "a=setup:" + setupType + "\r\n";
        params.fingerprints.forEach((fp) => {
          sdp2 += "a=fingerprint:" + fp.algorithm + " " + fp.value + "\r\n";
        });
        return sdp2;
      };
      SDPUtils2.parseCryptoLine = function(line) {
        const parts = line.substring(9).split(" ");
        return {
          tag: parseInt(parts[0], 10),
          cryptoSuite: parts[1],
          keyParams: parts[2],
          sessionParams: parts.slice(3)
        };
      };
      SDPUtils2.writeCryptoLine = function(parameters) {
        return "a=crypto:" + parameters.tag + " " + parameters.cryptoSuite + " " + (typeof parameters.keyParams === "object" ? SDPUtils2.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? " " + parameters.sessionParams.join(" ") : "") + "\r\n";
      };
      SDPUtils2.parseCryptoKeyParams = function(keyParams) {
        if (keyParams.indexOf("inline:") !== 0) {
          return null;
        }
        const parts = keyParams.substring(7).split("|");
        return {
          keyMethod: "inline",
          keySalt: parts[0],
          lifeTime: parts[1],
          mkiValue: parts[2] ? parts[2].split(":")[0] : void 0,
          mkiLength: parts[2] ? parts[2].split(":")[1] : void 0
        };
      };
      SDPUtils2.writeCryptoKeyParams = function(keyParams) {
        return keyParams.keyMethod + ":" + keyParams.keySalt + (keyParams.lifeTime ? "|" + keyParams.lifeTime : "") + (keyParams.mkiValue && keyParams.mkiLength ? "|" + keyParams.mkiValue + ":" + keyParams.mkiLength : "");
      };
      SDPUtils2.getCryptoParameters = function(mediaSection, sessionpart) {
        const lines = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=crypto:");
        return lines.map(SDPUtils2.parseCryptoLine);
      };
      SDPUtils2.getIceParameters = function(mediaSection, sessionpart) {
        const ufrag = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=ice-ufrag:")[0];
        const pwd = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=ice-pwd:")[0];
        if (!(ufrag && pwd)) {
          return null;
        }
        return {
          usernameFragment: ufrag.substring(12),
          password: pwd.substring(10)
        };
      };
      SDPUtils2.writeIceParameters = function(params) {
        let sdp2 = "a=ice-ufrag:" + params.usernameFragment + "\r\na=ice-pwd:" + params.password + "\r\n";
        if (params.iceLite) {
          sdp2 += "a=ice-lite\r\n";
        }
        return sdp2;
      };
      SDPUtils2.parseRtpParameters = function(mediaSection) {
        const description = {
          codecs: [],
          headerExtensions: [],
          fecMechanisms: [],
          rtcp: []
        };
        const lines = SDPUtils2.splitLines(mediaSection);
        const mline = lines[0].split(" ");
        description.profile = mline[2];
        for (let i = 3; i < mline.length; i++) {
          const pt = mline[i];
          const rtpmapline = SDPUtils2.matchPrefix(mediaSection, "a=rtpmap:" + pt + " ")[0];
          if (rtpmapline) {
            const codec = SDPUtils2.parseRtpMap(rtpmapline);
            const fmtps = SDPUtils2.matchPrefix(mediaSection, "a=fmtp:" + pt + " ");
            codec.parameters = fmtps.length ? SDPUtils2.parseFmtp(fmtps[0]) : {};
            codec.rtcpFeedback = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-fb:" + pt + " ").map(SDPUtils2.parseRtcpFb);
            description.codecs.push(codec);
            switch (codec.name.toUpperCase()) {
              case "RED":
              case "ULPFEC":
                description.fecMechanisms.push(codec.name.toUpperCase());
                break;
            }
          }
        }
        SDPUtils2.matchPrefix(mediaSection, "a=extmap:").forEach((line) => {
          description.headerExtensions.push(SDPUtils2.parseExtmap(line));
        });
        const wildcardRtcpFb = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-fb:* ").map(SDPUtils2.parseRtcpFb);
        description.codecs.forEach((codec) => {
          wildcardRtcpFb.forEach((fb) => {
            const duplicate = codec.rtcpFeedback.find((existingFeedback) => {
              return existingFeedback.type === fb.type && existingFeedback.parameter === fb.parameter;
            });
            if (!duplicate) {
              codec.rtcpFeedback.push(fb);
            }
          });
        });
        return description;
      };
      SDPUtils2.writeRtpDescription = function(kind, caps) {
        let sdp2 = "";
        sdp2 += "m=" + kind + " ";
        sdp2 += caps.codecs.length > 0 ? "9" : "0";
        sdp2 += " " + (caps.profile || "UDP/TLS/RTP/SAVPF") + " ";
        sdp2 += caps.codecs.map((codec) => {
          if (codec.preferredPayloadType !== void 0) {
            return codec.preferredPayloadType;
          }
          return codec.payloadType;
        }).join(" ") + "\r\n";
        sdp2 += "c=IN IP4 0.0.0.0\r\n";
        sdp2 += "a=rtcp:9 IN IP4 0.0.0.0\r\n";
        caps.codecs.forEach((codec) => {
          sdp2 += SDPUtils2.writeRtpMap(codec);
          sdp2 += SDPUtils2.writeFmtp(codec);
          sdp2 += SDPUtils2.writeRtcpFb(codec);
        });
        let maxptime = 0;
        caps.codecs.forEach((codec) => {
          if (codec.maxptime > maxptime) {
            maxptime = codec.maxptime;
          }
        });
        if (maxptime > 0) {
          sdp2 += "a=maxptime:" + maxptime + "\r\n";
        }
        if (caps.headerExtensions) {
          caps.headerExtensions.forEach((extension) => {
            sdp2 += SDPUtils2.writeExtmap(extension);
          });
        }
        return sdp2;
      };
      SDPUtils2.parseRtpEncodingParameters = function(mediaSection) {
        const encodingParameters = [];
        const description = SDPUtils2.parseRtpParameters(mediaSection);
        const hasRed = description.fecMechanisms.indexOf("RED") !== -1;
        const hasUlpfec = description.fecMechanisms.indexOf("ULPFEC") !== -1;
        const ssrcs = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((parts) => parts.attribute === "cname");
        const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
        let secondarySsrc;
        const flows = SDPUtils2.matchPrefix(mediaSection, "a=ssrc-group:FID").map((line) => {
          const parts = line.substring(17).split(" ");
          return parts.map((part) => parseInt(part, 10));
        });
        if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
          secondarySsrc = flows[0][1];
        }
        description.codecs.forEach((codec) => {
          if (codec.name.toUpperCase() === "RTX" && codec.parameters.apt) {
            let encParam = {
              ssrc: primarySsrc,
              codecPayloadType: parseInt(codec.parameters.apt, 10)
            };
            if (primarySsrc && secondarySsrc) {
              encParam.rtx = {
                ssrc: secondarySsrc
              };
            }
            encodingParameters.push(encParam);
            if (hasRed) {
              encParam = JSON.parse(JSON.stringify(encParam));
              encParam.fec = {
                ssrc: primarySsrc,
                mechanism: hasUlpfec ? "red+ulpfec" : "red"
              };
              encodingParameters.push(encParam);
            }
          }
        });
        if (encodingParameters.length === 0 && primarySsrc) {
          encodingParameters.push({
            ssrc: primarySsrc
          });
        }
        let bandwidth = SDPUtils2.matchPrefix(mediaSection, "b=");
        if (bandwidth.length) {
          if (bandwidth[0].indexOf("b=TIAS:") === 0) {
            bandwidth = parseInt(bandwidth[0].substring(7), 10);
          } else if (bandwidth[0].indexOf("b=AS:") === 0) {
            bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1e3 * 0.95 - 50 * 40 * 8;
          } else {
            bandwidth = void 0;
          }
          encodingParameters.forEach((params) => {
            params.maxBitrate = bandwidth;
          });
        }
        return encodingParameters;
      };
      SDPUtils2.parseRtcpParameters = function(mediaSection) {
        const rtcpParameters = {};
        const remoteSsrc = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((obj) => obj.attribute === "cname")[0];
        if (remoteSsrc) {
          rtcpParameters.cname = remoteSsrc.value;
          rtcpParameters.ssrc = remoteSsrc.ssrc;
        }
        const rsize = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-rsize");
        rtcpParameters.reducedSize = rsize.length > 0;
        rtcpParameters.compound = rsize.length === 0;
        const mux = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-mux");
        rtcpParameters.mux = mux.length > 0;
        return rtcpParameters;
      };
      SDPUtils2.writeRtcpParameters = function(rtcpParameters) {
        let sdp2 = "";
        if (rtcpParameters.reducedSize) {
          sdp2 += "a=rtcp-rsize\r\n";
        }
        if (rtcpParameters.mux) {
          sdp2 += "a=rtcp-mux\r\n";
        }
        if (rtcpParameters.ssrc !== void 0 && rtcpParameters.cname) {
          sdp2 += "a=ssrc:" + rtcpParameters.ssrc + " cname:" + rtcpParameters.cname + "\r\n";
        }
        return sdp2;
      };
      SDPUtils2.parseMsid = function(mediaSection) {
        let parts;
        const spec = SDPUtils2.matchPrefix(mediaSection, "a=msid:");
        if (spec.length === 1) {
          parts = spec[0].substring(7).split(" ");
          return {
            stream: parts[0],
            track: parts[1]
          };
        }
        const planB = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((msidParts) => msidParts.attribute === "msid");
        if (planB.length > 0) {
          parts = planB[0].value.split(" ");
          return {
            stream: parts[0],
            track: parts[1]
          };
        }
      };
      SDPUtils2.parseSctpDescription = function(mediaSection) {
        const mline = SDPUtils2.parseMLine(mediaSection);
        const maxSizeLine = SDPUtils2.matchPrefix(mediaSection, "a=max-message-size:");
        let maxMessageSize;
        if (maxSizeLine.length > 0) {
          maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);
        }
        if (isNaN(maxMessageSize)) {
          maxMessageSize = 65536;
        }
        const sctpPort = SDPUtils2.matchPrefix(mediaSection, "a=sctp-port:");
        if (sctpPort.length > 0) {
          return {
            port: parseInt(sctpPort[0].substring(12), 10),
            protocol: mline.fmt,
            maxMessageSize
          };
        }
        const sctpMapLines = SDPUtils2.matchPrefix(mediaSection, "a=sctpmap:");
        if (sctpMapLines.length > 0) {
          const parts = sctpMapLines[0].substring(10).split(" ");
          return {
            port: parseInt(parts[0], 10),
            protocol: parts[1],
            maxMessageSize
          };
        }
      };
      SDPUtils2.writeSctpDescription = function(media, sctp) {
        let output = [];
        if (media.protocol !== "DTLS/SCTP") {
          output = ["m=" + media.kind + " 9 " + media.protocol + " " + sctp.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + sctp.port + "\r\n"];
        } else {
          output = ["m=" + media.kind + " 9 " + media.protocol + " " + sctp.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + sctp.port + " " + sctp.protocol + " 65535\r\n"];
        }
        if (sctp.maxMessageSize !== void 0) {
          output.push("a=max-message-size:" + sctp.maxMessageSize + "\r\n");
        }
        return output.join("");
      };
      SDPUtils2.generateSessionId = function() {
        return Math.random().toString().substr(2, 22);
      };
      SDPUtils2.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
        let sessionId;
        const version2 = sessVer !== void 0 ? sessVer : 2;
        if (sessId) {
          sessionId = sessId;
        } else {
          sessionId = SDPUtils2.generateSessionId();
        }
        const user = sessUser || "thisisadapterortc";
        return "v=0\r\no=" + user + " " + sessionId + " " + version2 + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
      };
      SDPUtils2.getDirection = function(mediaSection, sessionpart) {
        const lines = SDPUtils2.splitLines(mediaSection);
        for (let i = 0; i < lines.length; i++) {
          switch (lines[i]) {
            case "a=sendrecv":
            case "a=sendonly":
            case "a=recvonly":
            case "a=inactive":
              return lines[i].substring(2);
          }
        }
        if (sessionpart) {
          return SDPUtils2.getDirection(sessionpart);
        }
        return "sendrecv";
      };
      SDPUtils2.getKind = function(mediaSection) {
        const lines = SDPUtils2.splitLines(mediaSection);
        const mline = lines[0].split(" ");
        return mline[0].substring(2);
      };
      SDPUtils2.isRejected = function(mediaSection) {
        return mediaSection.split(" ", 2)[1] === "0";
      };
      SDPUtils2.parseMLine = function(mediaSection) {
        const lines = SDPUtils2.splitLines(mediaSection);
        const parts = lines[0].substring(2).split(" ");
        return {
          kind: parts[0],
          port: parseInt(parts[1], 10),
          protocol: parts[2],
          fmt: parts.slice(3).join(" ")
        };
      };
      SDPUtils2.parseOLine = function(mediaSection) {
        const line = SDPUtils2.matchPrefix(mediaSection, "o=")[0];
        const parts = line.substring(2).split(" ");
        return {
          username: parts[0],
          sessionId: parts[1],
          sessionVersion: parseInt(parts[2], 10),
          netType: parts[3],
          addressType: parts[4],
          address: parts[5]
        };
      };
      SDPUtils2.isValidSDP = function(blob) {
        if (typeof blob !== "string" || blob.length === 0) {
          return false;
        }
        const lines = SDPUtils2.splitLines(blob);
        for (let i = 0; i < lines.length; i++) {
          if (lines[i].length < 2 || lines[i].charAt(1) !== "=") {
            return false;
          }
        }
        return true;
      };
      {
        module.exports = SDPUtils2;
      }
    })(sdp$1);
    return sdp$1.exports;
  }
  var sdpExports = requireSdp();
  var SDPUtils = /* @__PURE__ */ getDefaultExportFromCjs(sdpExports);
  var sdp = /* @__PURE__ */ _mergeNamespaces({
    __proto__: null,
    default: SDPUtils
  }, [sdpExports]);
  function shimRTCIceCandidate(window2) {
    if (!window2.RTCIceCandidate || window2.RTCIceCandidate && "foundation" in window2.RTCIceCandidate.prototype) {
      return;
    }
    const NativeRTCIceCandidate = window2.RTCIceCandidate;
    window2.RTCIceCandidate = function RTCIceCandidate2(args) {
      if (typeof args === "object" && args.candidate && args.candidate.indexOf("a=") === 0) {
        args = JSON.parse(JSON.stringify(args));
        args.candidate = args.candidate.substring(2);
      }
      if (args.candidate && args.candidate.length) {
        const nativeCandidate = new NativeRTCIceCandidate(args);
        const parsedCandidate = SDPUtils.parseCandidate(args.candidate);
        for (const key in parsedCandidate) {
          if (!(key in nativeCandidate)) {
            Object.defineProperty(nativeCandidate, key, {
              value: parsedCandidate[key]
            });
          }
        }
        nativeCandidate.toJSON = function toJSON2() {
          return {
            candidate: nativeCandidate.candidate,
            sdpMid: nativeCandidate.sdpMid,
            sdpMLineIndex: nativeCandidate.sdpMLineIndex,
            usernameFragment: nativeCandidate.usernameFragment
          };
        };
        return nativeCandidate;
      }
      return new NativeRTCIceCandidate(args);
    };
    window2.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;
    wrapPeerConnectionEvent(window2, "icecandidate", (e) => {
      if (e.candidate) {
        Object.defineProperty(e, "candidate", {
          value: new window2.RTCIceCandidate(e.candidate),
          writable: "false"
        });
      }
      return e;
    });
  }
  function shimRTCIceCandidateRelayProtocol(window2) {
    if (!window2.RTCIceCandidate || window2.RTCIceCandidate && "relayProtocol" in window2.RTCIceCandidate.prototype) {
      return;
    }
    wrapPeerConnectionEvent(window2, "icecandidate", (e) => {
      if (e.candidate) {
        const parsedCandidate = SDPUtils.parseCandidate(e.candidate.candidate);
        if (parsedCandidate.type === "relay") {
          e.candidate.relayProtocol = {
            0: "tls",
            1: "tcp",
            2: "udp"
          }[parsedCandidate.priority >> 24];
        }
      }
      return e;
    });
  }
  function shimMaxMessageSize(window2, browserDetails2) {
    if (!window2.RTCPeerConnection) {
      return;
    }
    if (!("sctp" in window2.RTCPeerConnection.prototype)) {
      Object.defineProperty(window2.RTCPeerConnection.prototype, "sctp", {
        get() {
          return typeof this._sctp === "undefined" ? null : this._sctp;
        }
      });
    }
    const sctpInDescription = function(description) {
      if (!description || !description.sdp) {
        return false;
      }
      const sections = SDPUtils.splitSections(description.sdp);
      sections.shift();
      return sections.some((mediaSection) => {
        const mLine = SDPUtils.parseMLine(mediaSection);
        return mLine && mLine.kind === "application" && mLine.protocol.indexOf("SCTP") !== -1;
      });
    };
    const getRemoteFirefoxVersion = function(description) {
      const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
      if (match === null || match.length < 2) {
        return -1;
      }
      const version2 = parseInt(match[1], 10);
      return version2 !== version2 ? -1 : version2;
    };
    const getCanSendMaxMessageSize = function(remoteIsFirefox) {
      let canSendMaxMessageSize = 65536;
      if (browserDetails2.browser === "firefox") {
        if (browserDetails2.version < 57) {
          if (remoteIsFirefox === -1) {
            canSendMaxMessageSize = 16384;
          } else {
            canSendMaxMessageSize = 2147483637;
          }
        } else if (browserDetails2.version < 60) {
          canSendMaxMessageSize = browserDetails2.version === 57 ? 65535 : 65536;
        } else {
          canSendMaxMessageSize = 2147483637;
        }
      }
      return canSendMaxMessageSize;
    };
    const getMaxMessageSize = function(description, remoteIsFirefox) {
      let maxMessageSize = 65536;
      if (browserDetails2.browser === "firefox" && browserDetails2.version === 57) {
        maxMessageSize = 65535;
      }
      const match = SDPUtils.matchPrefix(description.sdp, "a=max-message-size:");
      if (match.length > 0) {
        maxMessageSize = parseInt(match[0].substring(19), 10);
      } else if (browserDetails2.browser === "firefox" && remoteIsFirefox !== -1) {
        maxMessageSize = 2147483637;
      }
      return maxMessageSize;
    };
    const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
    window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
      this._sctp = null;
      if (browserDetails2.browser === "chrome" && browserDetails2.version >= 76) {
        const {
          sdpSemantics
        } = this.getConfiguration();
        if (sdpSemantics === "plan-b") {
          Object.defineProperty(this, "sctp", {
            get() {
              return typeof this._sctp === "undefined" ? null : this._sctp;
            },
            enumerable: true,
            configurable: true
          });
        }
      }
      if (sctpInDescription(arguments[0])) {
        const isFirefox = getRemoteFirefoxVersion(arguments[0]);
        const canSendMMS = getCanSendMaxMessageSize(isFirefox);
        const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);
        let maxMessageSize;
        if (canSendMMS === 0 && remoteMMS === 0) {
          maxMessageSize = Number.POSITIVE_INFINITY;
        } else if (canSendMMS === 0 || remoteMMS === 0) {
          maxMessageSize = Math.max(canSendMMS, remoteMMS);
        } else {
          maxMessageSize = Math.min(canSendMMS, remoteMMS);
        }
        const sctp = {};
        Object.defineProperty(sctp, "maxMessageSize", {
          get() {
            return maxMessageSize;
          }
        });
        this._sctp = sctp;
      }
      return origSetRemoteDescription.apply(this, arguments);
    };
  }
  function shimSendThrowTypeError(window2) {
    if (!(window2.RTCPeerConnection && "createDataChannel" in window2.RTCPeerConnection.prototype)) {
      return;
    }
    function wrapDcSend(dc, pc) {
      const origDataChannelSend = dc.send;
      dc.send = function send() {
        const data = arguments[0];
        const length = data.length || data.size || data.byteLength;
        if (dc.readyState === "open" && pc.sctp && length > pc.sctp.maxMessageSize) {
          throw new TypeError("Message too large (can send a maximum of " + pc.sctp.maxMessageSize + " bytes)");
        }
        return origDataChannelSend.apply(dc, arguments);
      };
    }
    const origCreateDataChannel = window2.RTCPeerConnection.prototype.createDataChannel;
    window2.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {
      const dataChannel = origCreateDataChannel.apply(this, arguments);
      wrapDcSend(dataChannel, this);
      return dataChannel;
    };
    wrapPeerConnectionEvent(window2, "datachannel", (e) => {
      wrapDcSend(e.channel, e.target);
      return e;
    });
  }
  function shimConnectionState(window2) {
    if (!window2.RTCPeerConnection || "connectionState" in window2.RTCPeerConnection.prototype) {
      return;
    }
    const proto = window2.RTCPeerConnection.prototype;
    Object.defineProperty(proto, "connectionState", {
      get() {
        return {
          completed: "connected",
          checking: "connecting"
        }[this.iceConnectionState] || this.iceConnectionState;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(proto, "onconnectionstatechange", {
      get() {
        return this._onconnectionstatechange || null;
      },
      set(cb) {
        if (this._onconnectionstatechange) {
          this.removeEventListener("connectionstatechange", this._onconnectionstatechange);
          delete this._onconnectionstatechange;
        }
        if (cb) {
          this.addEventListener("connectionstatechange", this._onconnectionstatechange = cb);
        }
      },
      enumerable: true,
      configurable: true
    });
    ["setLocalDescription", "setRemoteDescription"].forEach((method) => {
      const origMethod = proto[method];
      proto[method] = function() {
        if (!this._connectionstatechangepoly) {
          this._connectionstatechangepoly = (e) => {
            const pc = e.target;
            if (pc._lastConnectionState !== pc.connectionState) {
              pc._lastConnectionState = pc.connectionState;
              const newEvent = new Event("connectionstatechange", e);
              pc.dispatchEvent(newEvent);
            }
            return e;
          };
          this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly);
        }
        return origMethod.apply(this, arguments);
      };
    });
  }
  function removeExtmapAllowMixed(window2, browserDetails2) {
    if (!window2.RTCPeerConnection) {
      return;
    }
    if (browserDetails2.browser === "chrome" && browserDetails2.version >= 71) {
      return;
    }
    if (browserDetails2.browser === "safari" && browserDetails2.version >= 605) {
      return;
    }
    const nativeSRD = window2.RTCPeerConnection.prototype.setRemoteDescription;
    window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {
      if (desc && desc.sdp && desc.sdp.indexOf("\na=extmap-allow-mixed") !== -1) {
        const sdp2 = desc.sdp.split("\n").filter((line) => {
          return line.trim() !== "a=extmap-allow-mixed";
        }).join("\n");
        if (window2.RTCSessionDescription && desc instanceof window2.RTCSessionDescription) {
          arguments[0] = new window2.RTCSessionDescription({
            type: desc.type,
            sdp: sdp2
          });
        } else {
          desc.sdp = sdp2;
        }
      }
      return nativeSRD.apply(this, arguments);
    };
  }
  function shimAddIceCandidateNullOrEmpty(window2, browserDetails2) {
    if (!(window2.RTCPeerConnection && window2.RTCPeerConnection.prototype)) {
      return;
    }
    const nativeAddIceCandidate = window2.RTCPeerConnection.prototype.addIceCandidate;
    if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {
      return;
    }
    window2.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      if ((browserDetails2.browser === "chrome" && browserDetails2.version < 78 || browserDetails2.browser === "firefox" && browserDetails2.version < 68 || browserDetails2.browser === "safari") && arguments[0] && arguments[0].candidate === "") {
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };
  }
  function shimParameterlessSetLocalDescription(window2, browserDetails2) {
    if (!(window2.RTCPeerConnection && window2.RTCPeerConnection.prototype)) {
      return;
    }
    const nativeSetLocalDescription = window2.RTCPeerConnection.prototype.setLocalDescription;
    if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {
      return;
    }
    window2.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
      let desc = arguments[0] || {};
      if (typeof desc !== "object" || desc.type && desc.sdp) {
        return nativeSetLocalDescription.apply(this, arguments);
      }
      desc = {
        type: desc.type,
        sdp: desc.sdp
      };
      if (!desc.type) {
        switch (this.signalingState) {
          case "stable":
          case "have-local-offer":
          case "have-remote-pranswer":
            desc.type = "offer";
            break;
          default:
            desc.type = "answer";
            break;
        }
      }
      if (desc.sdp || desc.type !== "offer" && desc.type !== "answer") {
        return nativeSetLocalDescription.apply(this, [desc]);
      }
      const func = desc.type === "offer" ? this.createOffer : this.createAnswer;
      return func.apply(this).then((d) => nativeSetLocalDescription.apply(this, [d]));
    };
  }
  var commonShim = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    removeExtmapAllowMixed,
    shimAddIceCandidateNullOrEmpty,
    shimConnectionState,
    shimMaxMessageSize,
    shimParameterlessSetLocalDescription,
    shimRTCIceCandidate,
    shimRTCIceCandidateRelayProtocol,
    shimSendThrowTypeError
  });
  function adapterFactory() {
    let {
      window: window2
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      shimChrome: true,
      shimFirefox: true,
      shimSafari: true
    };
    const logging2 = log;
    const browserDetails2 = detectBrowser(window2);
    const adapter = {
      browserDetails: browserDetails2,
      commonShim,
      extractVersion,
      disableLog,
      disableWarnings,
      // Expose sdp as a convenience. For production apps include directly.
      sdp
    };
    switch (browserDetails2.browser) {
      case "chrome":
        if (!chromeShim || !shimPeerConnection$1 || !options.shimChrome) {
          logging2("Chrome shim is not included in this adapter release.");
          return adapter;
        }
        if (browserDetails2.version === null) {
          logging2("Chrome shim can not determine version, not shimming.");
          return adapter;
        }
        logging2("adapter.js shimming chrome.");
        adapter.browserShim = chromeShim;
        shimAddIceCandidateNullOrEmpty(window2, browserDetails2);
        shimParameterlessSetLocalDescription(window2);
        shimGetUserMedia$2(window2, browserDetails2);
        shimMediaStream(window2);
        shimPeerConnection$1(window2, browserDetails2);
        shimOnTrack$1(window2);
        shimAddTrackRemoveTrack(window2, browserDetails2);
        shimGetSendersWithDtmf(window2);
        shimSenderReceiverGetStats(window2);
        fixNegotiationNeeded(window2, browserDetails2);
        shimRTCIceCandidate(window2);
        shimRTCIceCandidateRelayProtocol(window2);
        shimConnectionState(window2);
        shimMaxMessageSize(window2, browserDetails2);
        shimSendThrowTypeError(window2);
        removeExtmapAllowMixed(window2, browserDetails2);
        break;
      case "firefox":
        if (!firefoxShim || !shimPeerConnection || !options.shimFirefox) {
          logging2("Firefox shim is not included in this adapter release.");
          return adapter;
        }
        logging2("adapter.js shimming firefox.");
        adapter.browserShim = firefoxShim;
        shimAddIceCandidateNullOrEmpty(window2, browserDetails2);
        shimParameterlessSetLocalDescription(window2);
        shimGetUserMedia$1(window2, browserDetails2);
        shimPeerConnection(window2, browserDetails2);
        shimOnTrack(window2);
        shimRemoveStream(window2);
        shimSenderGetStats(window2);
        shimReceiverGetStats(window2);
        shimRTCDataChannel(window2);
        shimAddTransceiver(window2);
        shimGetParameters(window2);
        shimCreateOffer(window2);
        shimCreateAnswer(window2);
        shimRTCIceCandidate(window2);
        shimConnectionState(window2);
        shimMaxMessageSize(window2, browserDetails2);
        shimSendThrowTypeError(window2);
        break;
      case "safari":
        if (!safariShim || !options.shimSafari) {
          logging2("Safari shim is not included in this adapter release.");
          return adapter;
        }
        logging2("adapter.js shimming safari.");
        adapter.browserShim = safariShim;
        shimAddIceCandidateNullOrEmpty(window2, browserDetails2);
        shimParameterlessSetLocalDescription(window2);
        shimRTCIceServerUrls(window2);
        shimCreateOfferLegacy(window2);
        shimCallbacksAPI(window2);
        shimLocalStreamsAPI(window2);
        shimRemoteStreamsAPI(window2);
        shimTrackEventTransceiver(window2);
        shimGetUserMedia(window2);
        shimAudioContext(window2);
        shimRTCIceCandidate(window2);
        shimRTCIceCandidateRelayProtocol(window2);
        shimMaxMessageSize(window2, browserDetails2);
        shimSendThrowTypeError(window2);
        removeExtmapAllowMixed(window2, browserDetails2);
        break;
      default:
        logging2("Unsupported browser!");
        break;
    }
    return adapter;
  }
  adapterFactory({
    window: typeof window === "undefined" ? void 0 : window
  });
  var DECRYPTION_FAILURE_TOLERANCE = 10;
  var E2EE_FLAG = "lk_e2ee";
  var SALT = "LKFrameEncryptionKey";
  var KEY_PROVIDER_DEFAULTS = {
    sharedKey: false,
    ratchetSalt: SALT,
    ratchetWindowSize: 8,
    failureTolerance: DECRYPTION_FAILURE_TOLERANCE,
    keyringSize: 16
  };
  var KeyProviderEvent;
  (function(KeyProviderEvent2) {
    KeyProviderEvent2["SetKey"] = "setKey";
    KeyProviderEvent2["RatchetRequest"] = "ratchetRequest";
    KeyProviderEvent2["KeyRatcheted"] = "keyRatcheted";
  })(KeyProviderEvent || (KeyProviderEvent = {}));
  var KeyHandlerEvent;
  (function(KeyHandlerEvent2) {
    KeyHandlerEvent2["KeyRatcheted"] = "keyRatcheted";
  })(KeyHandlerEvent || (KeyHandlerEvent = {}));
  var EncryptionEvent;
  (function(EncryptionEvent2) {
    EncryptionEvent2["ParticipantEncryptionStatusChanged"] = "participantEncryptionStatusChanged";
    EncryptionEvent2["EncryptionError"] = "encryptionError";
  })(EncryptionEvent || (EncryptionEvent = {}));
  var CryptorEvent;
  (function(CryptorEvent2) {
    CryptorEvent2["Error"] = "cryptorError";
  })(CryptorEvent || (CryptorEvent = {}));
  function isE2EESupported() {
    return isInsertableStreamSupported() || isScriptTransformSupported();
  }
  function isScriptTransformSupported() {
    return typeof window.RTCRtpScriptTransform !== "undefined";
  }
  function isInsertableStreamSupported() {
    return typeof window.RTCRtpSender !== "undefined" && // @ts-ignore
    typeof window.RTCRtpSender.prototype.createEncodedStreams !== "undefined";
  }
  var BaseKeyProvider = class extends eventsExports.EventEmitter {
    constructor() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      super();
      this.onKeyRatcheted = (material, keyIndex) => {
        livekitLogger.debug("key ratcheted event received", {
          material,
          keyIndex
        });
      };
      this.keyInfoMap = /* @__PURE__ */ new Map();
      this.options = Object.assign(Object.assign({}, KEY_PROVIDER_DEFAULTS), options);
      this.on(KeyProviderEvent.KeyRatcheted, this.onKeyRatcheted);
    }
    /**
     * callback to invoke once a key has been set for a participant
     * @param key
     * @param participantIdentity
     * @param keyIndex
     */
    onSetEncryptionKey(key, participantIdentity, keyIndex) {
      const keyInfo = {
        key,
        participantIdentity,
        keyIndex
      };
      if (!this.options.sharedKey && !participantIdentity) {
        throw new Error("participant identity needs to be passed for encryption key if sharedKey option is false");
      }
      this.keyInfoMap.set("".concat(participantIdentity !== null && participantIdentity !== void 0 ? participantIdentity : "shared", "-").concat(keyIndex !== null && keyIndex !== void 0 ? keyIndex : 0), keyInfo);
      this.emit(KeyProviderEvent.SetKey, keyInfo);
    }
    getKeys() {
      return Array.from(this.keyInfoMap.values());
    }
    getOptions() {
      return this.options;
    }
    ratchetKey(participantIdentity, keyIndex) {
      this.emit(KeyProviderEvent.RatchetRequest, participantIdentity, keyIndex);
    }
  };
  var LivekitError = class extends Error {
    constructor(code, message) {
      super(message || "an error has occured");
      this.code = code;
    }
  };
  var ConnectionErrorReason;
  (function(ConnectionErrorReason2) {
    ConnectionErrorReason2[ConnectionErrorReason2["NotAllowed"] = 0] = "NotAllowed";
    ConnectionErrorReason2[ConnectionErrorReason2["ServerUnreachable"] = 1] = "ServerUnreachable";
    ConnectionErrorReason2[ConnectionErrorReason2["InternalError"] = 2] = "InternalError";
    ConnectionErrorReason2[ConnectionErrorReason2["Cancelled"] = 3] = "Cancelled";
    ConnectionErrorReason2[ConnectionErrorReason2["LeaveRequest"] = 4] = "LeaveRequest";
  })(ConnectionErrorReason || (ConnectionErrorReason = {}));
  var ConnectionError = class extends LivekitError {
    constructor(message, reason, status, context) {
      super(1, message);
      this.status = status;
      this.reason = reason;
      this.context = context;
    }
  };
  var DeviceUnsupportedError = class extends LivekitError {
    constructor(message) {
      super(21, message !== null && message !== void 0 ? message : "device is unsupported");
    }
  };
  var TrackInvalidError = class extends LivekitError {
    constructor(message) {
      super(20, message !== null && message !== void 0 ? message : "track is invalid");
    }
  };
  var UnsupportedServer = class extends LivekitError {
    constructor(message) {
      super(10, message !== null && message !== void 0 ? message : "unsupported server");
    }
  };
  var UnexpectedConnectionState = class extends LivekitError {
    constructor(message) {
      super(12, message !== null && message !== void 0 ? message : "unexpected connection state");
    }
  };
  var NegotiationError = class extends LivekitError {
    constructor(message) {
      super(13, message !== null && message !== void 0 ? message : "unable to negotiate");
    }
  };
  var SignalRequestError = class extends LivekitError {
    constructor(message, reason) {
      super(15, message);
      this.reason = reason;
    }
  };
  var MediaDeviceFailure;
  (function(MediaDeviceFailure2) {
    MediaDeviceFailure2["PermissionDenied"] = "PermissionDenied";
    MediaDeviceFailure2["NotFound"] = "NotFound";
    MediaDeviceFailure2["DeviceInUse"] = "DeviceInUse";
    MediaDeviceFailure2["Other"] = "Other";
  })(MediaDeviceFailure || (MediaDeviceFailure = {}));
  (function(MediaDeviceFailure2) {
    function getFailure(error) {
      if (error && "name" in error) {
        if (error.name === "NotFoundError" || error.name === "DevicesNotFoundError") {
          return MediaDeviceFailure2.NotFound;
        }
        if (error.name === "NotAllowedError" || error.name === "PermissionDeniedError") {
          return MediaDeviceFailure2.PermissionDenied;
        }
        if (error.name === "NotReadableError" || error.name === "TrackStartError") {
          return MediaDeviceFailure2.DeviceInUse;
        }
        return MediaDeviceFailure2.Other;
      }
    }
    MediaDeviceFailure2.getFailure = getFailure;
  })(MediaDeviceFailure || (MediaDeviceFailure = {}));
  var CryptorErrorReason;
  (function(CryptorErrorReason2) {
    CryptorErrorReason2[CryptorErrorReason2["InvalidKey"] = 0] = "InvalidKey";
    CryptorErrorReason2[CryptorErrorReason2["MissingKey"] = 1] = "MissingKey";
    CryptorErrorReason2[CryptorErrorReason2["InternalError"] = 2] = "InternalError";
  })(CryptorErrorReason || (CryptorErrorReason = {}));
  var RoomEvent;
  (function(RoomEvent2) {
    RoomEvent2["Connected"] = "connected";
    RoomEvent2["Reconnecting"] = "reconnecting";
    RoomEvent2["SignalReconnecting"] = "signalReconnecting";
    RoomEvent2["Reconnected"] = "reconnected";
    RoomEvent2["Disconnected"] = "disconnected";
    RoomEvent2["ConnectionStateChanged"] = "connectionStateChanged";
    RoomEvent2["MediaDevicesChanged"] = "mediaDevicesChanged";
    RoomEvent2["ParticipantConnected"] = "participantConnected";
    RoomEvent2["ParticipantDisconnected"] = "participantDisconnected";
    RoomEvent2["TrackPublished"] = "trackPublished";
    RoomEvent2["TrackSubscribed"] = "trackSubscribed";
    RoomEvent2["TrackSubscriptionFailed"] = "trackSubscriptionFailed";
    RoomEvent2["TrackUnpublished"] = "trackUnpublished";
    RoomEvent2["TrackUnsubscribed"] = "trackUnsubscribed";
    RoomEvent2["TrackMuted"] = "trackMuted";
    RoomEvent2["TrackUnmuted"] = "trackUnmuted";
    RoomEvent2["LocalTrackPublished"] = "localTrackPublished";
    RoomEvent2["LocalTrackUnpublished"] = "localTrackUnpublished";
    RoomEvent2["LocalAudioSilenceDetected"] = "localAudioSilenceDetected";
    RoomEvent2["ActiveSpeakersChanged"] = "activeSpeakersChanged";
    RoomEvent2["ParticipantMetadataChanged"] = "participantMetadataChanged";
    RoomEvent2["ParticipantNameChanged"] = "participantNameChanged";
    RoomEvent2["ParticipantAttributesChanged"] = "participantAttributesChanged";
    RoomEvent2["RoomMetadataChanged"] = "roomMetadataChanged";
    RoomEvent2["DataReceived"] = "dataReceived";
    RoomEvent2["SipDTMFReceived"] = "sipDTMFReceived";
    RoomEvent2["TranscriptionReceived"] = "transcriptionReceived";
    RoomEvent2["ConnectionQualityChanged"] = "connectionQualityChanged";
    RoomEvent2["TrackStreamStateChanged"] = "trackStreamStateChanged";
    RoomEvent2["TrackSubscriptionPermissionChanged"] = "trackSubscriptionPermissionChanged";
    RoomEvent2["TrackSubscriptionStatusChanged"] = "trackSubscriptionStatusChanged";
    RoomEvent2["AudioPlaybackStatusChanged"] = "audioPlaybackChanged";
    RoomEvent2["VideoPlaybackStatusChanged"] = "videoPlaybackChanged";
    RoomEvent2["MediaDevicesError"] = "mediaDevicesError";
    RoomEvent2["ParticipantPermissionsChanged"] = "participantPermissionsChanged";
    RoomEvent2["SignalConnected"] = "signalConnected";
    RoomEvent2["RecordingStatusChanged"] = "recordingStatusChanged";
    RoomEvent2["ParticipantEncryptionStatusChanged"] = "participantEncryptionStatusChanged";
    RoomEvent2["EncryptionError"] = "encryptionError";
    RoomEvent2["DCBufferStatusChanged"] = "dcBufferStatusChanged";
    RoomEvent2["ActiveDeviceChanged"] = "activeDeviceChanged";
    RoomEvent2["ChatMessage"] = "chatMessage";
    RoomEvent2["LocalTrackSubscribed"] = "localTrackSubscribed";
    RoomEvent2["MetricsReceived"] = "metricsReceived";
  })(RoomEvent || (RoomEvent = {}));
  var ParticipantEvent;
  (function(ParticipantEvent2) {
    ParticipantEvent2["TrackPublished"] = "trackPublished";
    ParticipantEvent2["TrackSubscribed"] = "trackSubscribed";
    ParticipantEvent2["TrackSubscriptionFailed"] = "trackSubscriptionFailed";
    ParticipantEvent2["TrackUnpublished"] = "trackUnpublished";
    ParticipantEvent2["TrackUnsubscribed"] = "trackUnsubscribed";
    ParticipantEvent2["TrackMuted"] = "trackMuted";
    ParticipantEvent2["TrackUnmuted"] = "trackUnmuted";
    ParticipantEvent2["LocalTrackPublished"] = "localTrackPublished";
    ParticipantEvent2["LocalTrackUnpublished"] = "localTrackUnpublished";
    ParticipantEvent2["ParticipantMetadataChanged"] = "participantMetadataChanged";
    ParticipantEvent2["ParticipantNameChanged"] = "participantNameChanged";
    ParticipantEvent2["DataReceived"] = "dataReceived";
    ParticipantEvent2["SipDTMFReceived"] = "sipDTMFReceived";
    ParticipantEvent2["TranscriptionReceived"] = "transcriptionReceived";
    ParticipantEvent2["IsSpeakingChanged"] = "isSpeakingChanged";
    ParticipantEvent2["ConnectionQualityChanged"] = "connectionQualityChanged";
    ParticipantEvent2["TrackStreamStateChanged"] = "trackStreamStateChanged";
    ParticipantEvent2["TrackSubscriptionPermissionChanged"] = "trackSubscriptionPermissionChanged";
    ParticipantEvent2["TrackSubscriptionStatusChanged"] = "trackSubscriptionStatusChanged";
    ParticipantEvent2["MediaDevicesError"] = "mediaDevicesError";
    ParticipantEvent2["AudioStreamAcquired"] = "audioStreamAcquired";
    ParticipantEvent2["ParticipantPermissionsChanged"] = "participantPermissionsChanged";
    ParticipantEvent2["PCTrackAdded"] = "pcTrackAdded";
    ParticipantEvent2["AttributesChanged"] = "attributesChanged";
    ParticipantEvent2["LocalTrackSubscribed"] = "localTrackSubscribed";
    ParticipantEvent2["ChatMessage"] = "chatMessage";
  })(ParticipantEvent || (ParticipantEvent = {}));
  var EngineEvent;
  (function(EngineEvent2) {
    EngineEvent2["TransportsCreated"] = "transportsCreated";
    EngineEvent2["Connected"] = "connected";
    EngineEvent2["Disconnected"] = "disconnected";
    EngineEvent2["Resuming"] = "resuming";
    EngineEvent2["Resumed"] = "resumed";
    EngineEvent2["Restarting"] = "restarting";
    EngineEvent2["Restarted"] = "restarted";
    EngineEvent2["SignalResumed"] = "signalResumed";
    EngineEvent2["SignalRestarted"] = "signalRestarted";
    EngineEvent2["Closing"] = "closing";
    EngineEvent2["MediaTrackAdded"] = "mediaTrackAdded";
    EngineEvent2["ActiveSpeakersUpdate"] = "activeSpeakersUpdate";
    EngineEvent2["DataPacketReceived"] = "dataPacketReceived";
    EngineEvent2["RTPVideoMapUpdate"] = "rtpVideoMapUpdate";
    EngineEvent2["DCBufferStatusChanged"] = "dcBufferStatusChanged";
    EngineEvent2["ParticipantUpdate"] = "participantUpdate";
    EngineEvent2["RoomUpdate"] = "roomUpdate";
    EngineEvent2["SpeakersChanged"] = "speakersChanged";
    EngineEvent2["StreamStateChanged"] = "streamStateChanged";
    EngineEvent2["ConnectionQualityUpdate"] = "connectionQualityUpdate";
    EngineEvent2["SubscriptionError"] = "subscriptionError";
    EngineEvent2["SubscriptionPermissionUpdate"] = "subscriptionPermissionUpdate";
    EngineEvent2["RemoteMute"] = "remoteMute";
    EngineEvent2["SubscribedQualityUpdate"] = "subscribedQualityUpdate";
    EngineEvent2["LocalTrackUnpublished"] = "localTrackUnpublished";
    EngineEvent2["LocalTrackSubscribed"] = "localTrackSubscribed";
    EngineEvent2["Offline"] = "offline";
    EngineEvent2["SignalRequestResponse"] = "signalRequestResponse";
  })(EngineEvent || (EngineEvent = {}));
  var TrackEvent;
  (function(TrackEvent2) {
    TrackEvent2["Message"] = "message";
    TrackEvent2["Muted"] = "muted";
    TrackEvent2["Unmuted"] = "unmuted";
    TrackEvent2["Restarted"] = "restarted";
    TrackEvent2["Ended"] = "ended";
    TrackEvent2["Subscribed"] = "subscribed";
    TrackEvent2["Unsubscribed"] = "unsubscribed";
    TrackEvent2["UpdateSettings"] = "updateSettings";
    TrackEvent2["UpdateSubscription"] = "updateSubscription";
    TrackEvent2["AudioPlaybackStarted"] = "audioPlaybackStarted";
    TrackEvent2["AudioPlaybackFailed"] = "audioPlaybackFailed";
    TrackEvent2["AudioSilenceDetected"] = "audioSilenceDetected";
    TrackEvent2["VisibilityChanged"] = "visibilityChanged";
    TrackEvent2["VideoDimensionsChanged"] = "videoDimensionsChanged";
    TrackEvent2["VideoPlaybackStarted"] = "videoPlaybackStarted";
    TrackEvent2["VideoPlaybackFailed"] = "videoPlaybackFailed";
    TrackEvent2["ElementAttached"] = "elementAttached";
    TrackEvent2["ElementDetached"] = "elementDetached";
    TrackEvent2["UpstreamPaused"] = "upstreamPaused";
    TrackEvent2["UpstreamResumed"] = "upstreamResumed";
    TrackEvent2["SubscriptionPermissionChanged"] = "subscriptionPermissionChanged";
    TrackEvent2["SubscriptionStatusChanged"] = "subscriptionStatusChanged";
    TrackEvent2["SubscriptionFailed"] = "subscriptionFailed";
    TrackEvent2["TrackProcessorUpdate"] = "trackProcessorUpdate";
    TrackEvent2["AudioTrackFeatureUpdate"] = "audioTrackFeatureUpdate";
    TrackEvent2["TranscriptionReceived"] = "transcriptionReceived";
    TrackEvent2["TimeSyncUpdate"] = "timeSyncUpdate";
  })(TrackEvent || (TrackEvent = {}));
  function r(r2, e, n2) {
    var i, t, o;
    void 0 === e && (e = 50), void 0 === n2 && (n2 = {});
    var a = null != (i = n2.isImmediate) && i, u = null != (t = n2.callback) && t, c = n2.maxWait, v = Date.now(), l2 = [];
    function f() {
      if (void 0 !== c) {
        var r3 = Date.now() - v;
        if (r3 + e >= c) return c - r3;
      }
      return e;
    }
    var d = function() {
      var e2 = [].slice.call(arguments), n3 = this;
      return new Promise(function(i2, t2) {
        var c2 = a && void 0 === o;
        if (void 0 !== o && clearTimeout(o), o = setTimeout(function() {
          if (o = void 0, v = Date.now(), !a) {
            var i3 = r2.apply(n3, e2);
            u && u(i3), l2.forEach(function(r3) {
              return (0, r3.resolve)(i3);
            }), l2 = [];
          }
        }, f()), c2) {
          var d2 = r2.apply(n3, e2);
          return u && u(d2), i2(d2);
        }
        l2.push({
          resolve: i2,
          reject: t2
        });
      });
    };
    return d.cancel = function(r3) {
      void 0 !== o && clearTimeout(o), l2.forEach(function(e2) {
        return (0, e2.reject)(r3);
      }), l2 = [];
    }, d;
  }
  var commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
  var browserDetails;
  function getBrowser(userAgent) {
    let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if (typeof userAgent === "undefined" && typeof navigator === "undefined") {
      return;
    }
    const ua = (userAgent !== null && userAgent !== void 0 ? userAgent : navigator.userAgent).toLowerCase();
    if (browserDetails === void 0 || force) {
      const browser = browsersList.find((_ref) => {
        let {
          test: test2
        } = _ref;
        return test2.test(ua);
      });
      browserDetails = browser === null || browser === void 0 ? void 0 : browser.describe(ua);
    }
    return browserDetails;
  }
  var browsersList = [
    {
      test: /firefox|iceweasel|fxios/i,
      describe(ua) {
        const browser = {
          name: "Firefox",
          version: getMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, ua),
          os: ua.toLowerCase().includes("fxios") ? "iOS" : void 0,
          osVersion: getOSVersion(ua)
        };
        return browser;
      }
    },
    {
      test: /chrom|crios|crmo/i,
      describe(ua) {
        const browser = {
          name: "Chrome",
          version: getMatch(/(?:chrome|chromium|crios|crmo)\/(\d+(\.?_?\d+)+)/i, ua),
          os: ua.toLowerCase().includes("crios") ? "iOS" : void 0,
          osVersion: getOSVersion(ua)
        };
        return browser;
      }
    },
    /* Safari */
    {
      test: /safari|applewebkit/i,
      describe(ua) {
        const browser = {
          name: "Safari",
          version: getMatch(commonVersionIdentifier, ua),
          os: ua.includes("mobile/") ? "iOS" : "macOS",
          osVersion: getOSVersion(ua)
        };
        return browser;
      }
    }
  ];
  function getMatch(exp, ua) {
    let id = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    const match = ua.match(exp);
    return match && match.length >= id && match[id] || "";
  }
  function getOSVersion(ua) {
    return ua.includes("mac os") ? getMatch(/\(.+?(\d+_\d+(:?_\d+)?)/, ua, 1).replace(/_/g, ".") : void 0;
  }
  var version$1 = "2.7.5";
  var version = version$1;
  var protocolVersion = 15;
  var CriticalTimers = class {
  };
  CriticalTimers.setTimeout = function() {
    return setTimeout(...arguments);
  };
  CriticalTimers.setInterval = // eslint-disable-next-line @typescript-eslint/no-implied-eval
  function() {
    return setInterval(...arguments);
  };
  CriticalTimers.clearTimeout = function() {
    return clearTimeout(...arguments);
  };
  CriticalTimers.clearInterval = function() {
    return clearInterval(...arguments);
  };
  var VideoPreset = class {
    constructor(widthOrOptions, height, maxBitrate, maxFramerate, priority) {
      if (typeof widthOrOptions === "object") {
        this.width = widthOrOptions.width;
        this.height = widthOrOptions.height;
        this.aspectRatio = widthOrOptions.aspectRatio;
        this.encoding = {
          maxBitrate: widthOrOptions.maxBitrate,
          maxFramerate: widthOrOptions.maxFramerate,
          priority: widthOrOptions.priority
        };
      } else if (height !== void 0 && maxBitrate !== void 0) {
        this.width = widthOrOptions;
        this.height = height;
        this.aspectRatio = widthOrOptions / height;
        this.encoding = {
          maxBitrate,
          maxFramerate,
          priority
        };
      } else {
        throw new TypeError("Unsupported options: provide at least width, height and maxBitrate");
      }
    }
    get resolution() {
      return {
        width: this.width,
        height: this.height,
        frameRate: this.encoding.maxFramerate,
        aspectRatio: this.aspectRatio
      };
    }
  };
  var backupCodecs = ["vp8", "h264"];
  var videoCodecs = ["vp8", "h264", "vp9", "av1"];
  function isBackupCodec(codec) {
    return !!backupCodecs.find((backup) => backup === codec);
  }
  var AudioPresets;
  (function(AudioPresets2) {
    AudioPresets2.telephone = {
      maxBitrate: 12e3
    };
    AudioPresets2.speech = {
      maxBitrate: 24e3
    };
    AudioPresets2.music = {
      maxBitrate: 48e3
    };
    AudioPresets2.musicStereo = {
      maxBitrate: 64e3
    };
    AudioPresets2.musicHighQuality = {
      maxBitrate: 96e3
    };
    AudioPresets2.musicHighQualityStereo = {
      maxBitrate: 128e3
    };
  })(AudioPresets || (AudioPresets = {}));
  var VideoPresets = {
    h90: new VideoPreset(160, 90, 9e4, 20),
    h180: new VideoPreset(320, 180, 16e4, 20),
    h216: new VideoPreset(384, 216, 18e4, 20),
    h360: new VideoPreset(640, 360, 45e4, 20),
    h540: new VideoPreset(960, 540, 8e5, 25),
    h720: new VideoPreset(1280, 720, 17e5, 30),
    h1080: new VideoPreset(1920, 1080, 3e6, 30),
    h1440: new VideoPreset(2560, 1440, 5e6, 30),
    h2160: new VideoPreset(3840, 2160, 8e6, 30)
  };
  var VideoPresets43 = {
    h120: new VideoPreset(160, 120, 7e4, 20),
    h180: new VideoPreset(240, 180, 125e3, 20),
    h240: new VideoPreset(320, 240, 14e4, 20),
    h360: new VideoPreset(480, 360, 33e4, 20),
    h480: new VideoPreset(640, 480, 5e5, 20),
    h540: new VideoPreset(720, 540, 6e5, 25),
    h720: new VideoPreset(960, 720, 13e5, 30),
    h1080: new VideoPreset(1440, 1080, 23e5, 30),
    h1440: new VideoPreset(1920, 1440, 38e5, 30)
  };
  var ScreenSharePresets = {
    h360fps3: new VideoPreset(640, 360, 2e5, 3, "medium"),
    h360fps15: new VideoPreset(640, 360, 4e5, 15, "medium"),
    h720fps5: new VideoPreset(1280, 720, 8e5, 5, "medium"),
    h720fps15: new VideoPreset(1280, 720, 15e5, 15, "medium"),
    h720fps30: new VideoPreset(1280, 720, 2e6, 30, "medium"),
    h1080fps15: new VideoPreset(1920, 1080, 25e5, 15, "medium"),
    h1080fps30: new VideoPreset(1920, 1080, 5e6, 30, "medium"),
    // original resolution, without resizing
    original: new VideoPreset(0, 0, 7e6, 30, "medium")
  };
  function cloneDeep(value) {
    if (typeof value === "undefined") {
      return;
    }
    if (typeof structuredClone === "function") {
      return structuredClone(value);
    } else {
      return JSON.parse(JSON.stringify(value));
    }
  }
  var BACKGROUND_REACTION_DELAY = 5e3;
  var recycledElements = [];
  var VideoQuality;
  (function(VideoQuality2) {
    VideoQuality2[VideoQuality2["LOW"] = 0] = "LOW";
    VideoQuality2[VideoQuality2["MEDIUM"] = 1] = "MEDIUM";
    VideoQuality2[VideoQuality2["HIGH"] = 2] = "HIGH";
  })(VideoQuality || (VideoQuality = {}));
  var Track = class _Track extends eventsExports.EventEmitter {
    constructor(mediaTrack, kind) {
      let loggerOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var _a;
      super();
      this.attachedElements = [];
      this.isMuted = false;
      this.streamState = _Track.StreamState.Active;
      this.isInBackground = false;
      this._currentBitrate = 0;
      this.log = livekitLogger;
      this.appVisibilityChangedListener = () => {
        if (this.backgroundTimeout) {
          clearTimeout(this.backgroundTimeout);
        }
        if (document.visibilityState === "hidden") {
          this.backgroundTimeout = setTimeout(() => this.handleAppVisibilityChanged(), BACKGROUND_REACTION_DELAY);
        } else {
          this.handleAppVisibilityChanged();
        }
      };
      this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Track);
      this.loggerContextCb = loggerOptions.loggerContextCb;
      this.setMaxListeners(100);
      this.kind = kind;
      this._mediaStreamTrack = mediaTrack;
      this._mediaStreamID = mediaTrack.id;
      this.source = _Track.Source.Unknown;
    }
    get logContext() {
      var _a;
      return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));
    }
    /** current receive bits per second */
    get currentBitrate() {
      return this._currentBitrate;
    }
    get mediaStreamTrack() {
      return this._mediaStreamTrack;
    }
    /**
     * @internal
     * used for keep mediaStream's first id, since it's id might change
     * if we disable/enable a track
     */
    get mediaStreamID() {
      return this._mediaStreamID;
    }
    attach(element) {
      let elementType = "audio";
      if (this.kind === _Track.Kind.Video) {
        elementType = "video";
      }
      if (this.attachedElements.length === 0 && this.kind === _Track.Kind.Video) {
        this.addAppVisibilityListener();
      }
      if (!element) {
        if (elementType === "audio") {
          recycledElements.forEach((e) => {
            if (e.parentElement === null && !element) {
              element = e;
            }
          });
          if (element) {
            recycledElements.splice(recycledElements.indexOf(element), 1);
          }
        }
        if (!element) {
          element = document.createElement(elementType);
        }
      }
      if (!this.attachedElements.includes(element)) {
        this.attachedElements.push(element);
      }
      attachToElement(this.mediaStreamTrack, element);
      const allMediaStreamTracks = element.srcObject.getTracks();
      const hasAudio = allMediaStreamTracks.some((tr) => tr.kind === "audio");
      element.play().then(() => {
        this.emit(hasAudio ? TrackEvent.AudioPlaybackStarted : TrackEvent.VideoPlaybackStarted);
      }).catch((e) => {
        if (e.name === "NotAllowedError") {
          this.emit(hasAudio ? TrackEvent.AudioPlaybackFailed : TrackEvent.VideoPlaybackFailed, e);
        } else if (e.name === "AbortError") {
          livekitLogger.debug("".concat(hasAudio ? "audio" : "video", " playback aborted, likely due to new play request"));
        } else {
          livekitLogger.warn("could not playback ".concat(hasAudio ? "audio" : "video"), e);
        }
        if (hasAudio && element && allMediaStreamTracks.some((tr) => tr.kind === "video") && e.name === "NotAllowedError") {
          element.muted = true;
          element.play().catch(() => {
          });
        }
      });
      this.emit(TrackEvent.ElementAttached, element);
      return element;
    }
    detach(element) {
      try {
        if (element) {
          detachTrack(this.mediaStreamTrack, element);
          const idx = this.attachedElements.indexOf(element);
          if (idx >= 0) {
            this.attachedElements.splice(idx, 1);
            this.recycleElement(element);
            this.emit(TrackEvent.ElementDetached, element);
          }
          return element;
        }
        const detached = [];
        this.attachedElements.forEach((elm) => {
          detachTrack(this.mediaStreamTrack, elm);
          detached.push(elm);
          this.recycleElement(elm);
          this.emit(TrackEvent.ElementDetached, elm);
        });
        this.attachedElements = [];
        return detached;
      } finally {
        if (this.attachedElements.length === 0) {
          this.removeAppVisibilityListener();
        }
      }
    }
    stop() {
      this.stopMonitor();
      this._mediaStreamTrack.stop();
    }
    enable() {
      this._mediaStreamTrack.enabled = true;
    }
    disable() {
      this._mediaStreamTrack.enabled = false;
    }
    /* @internal */
    stopMonitor() {
      if (this.monitorInterval) {
        clearInterval(this.monitorInterval);
      }
      if (this.timeSyncHandle) {
        cancelAnimationFrame(this.timeSyncHandle);
      }
    }
    /** @internal */
    updateLoggerOptions(loggerOptions) {
      if (loggerOptions.loggerName) {
        this.log = getLogger(loggerOptions.loggerName);
      }
      if (loggerOptions.loggerContextCb) {
        this.loggerContextCb = loggerOptions.loggerContextCb;
      }
    }
    recycleElement(element) {
      if (element instanceof HTMLAudioElement) {
        let shouldCache = true;
        element.pause();
        recycledElements.forEach((e) => {
          if (!e.parentElement) {
            shouldCache = false;
          }
        });
        if (shouldCache) {
          recycledElements.push(element);
        }
      }
    }
    handleAppVisibilityChanged() {
      return __awaiter(this, void 0, void 0, function* () {
        this.isInBackground = document.visibilityState === "hidden";
        if (!this.isInBackground && this.kind === _Track.Kind.Video) {
          setTimeout(() => this.attachedElements.forEach((el) => el.play().catch(() => {
          })), 0);
        }
      });
    }
    addAppVisibilityListener() {
      if (isWeb()) {
        this.isInBackground = document.visibilityState === "hidden";
        document.addEventListener("visibilitychange", this.appVisibilityChangedListener);
      } else {
        this.isInBackground = false;
      }
    }
    removeAppVisibilityListener() {
      if (isWeb()) {
        document.removeEventListener("visibilitychange", this.appVisibilityChangedListener);
      }
    }
  };
  function attachToElement(track, element) {
    let mediaStream;
    if (element.srcObject instanceof MediaStream) {
      mediaStream = element.srcObject;
    } else {
      mediaStream = new MediaStream();
    }
    let existingTracks;
    if (track.kind === "audio") {
      existingTracks = mediaStream.getAudioTracks();
    } else {
      existingTracks = mediaStream.getVideoTracks();
    }
    if (!existingTracks.includes(track)) {
      existingTracks.forEach((et) => {
        mediaStream.removeTrack(et);
      });
      mediaStream.addTrack(track);
    }
    if (!isSafari() || !(element instanceof HTMLVideoElement)) {
      element.autoplay = true;
    }
    element.muted = mediaStream.getAudioTracks().length === 0;
    if (element instanceof HTMLVideoElement) {
      element.playsInline = true;
    }
    if (element.srcObject !== mediaStream) {
      element.srcObject = mediaStream;
      if ((isSafari() || isFireFox()) && element instanceof HTMLVideoElement) {
        setTimeout(() => {
          element.srcObject = mediaStream;
          element.play().catch(() => {
          });
        }, 0);
      }
    }
  }
  function detachTrack(track, element) {
    if (element.srcObject instanceof MediaStream) {
      const mediaStream = element.srcObject;
      mediaStream.removeTrack(track);
      if (mediaStream.getTracks().length > 0) {
        element.srcObject = mediaStream;
      } else {
        element.srcObject = null;
      }
    }
  }
  (function(Track2) {
    let Kind;
    (function(Kind2) {
      Kind2["Audio"] = "audio";
      Kind2["Video"] = "video";
      Kind2["Unknown"] = "unknown";
    })(Kind = Track2.Kind || (Track2.Kind = {}));
    let Source;
    (function(Source2) {
      Source2["Camera"] = "camera";
      Source2["Microphone"] = "microphone";
      Source2["ScreenShare"] = "screen_share";
      Source2["ScreenShareAudio"] = "screen_share_audio";
      Source2["Unknown"] = "unknown";
    })(Source = Track2.Source || (Track2.Source = {}));
    let StreamState$1;
    (function(StreamState2) {
      StreamState2["Active"] = "active";
      StreamState2["Paused"] = "paused";
      StreamState2["Unknown"] = "unknown";
    })(StreamState$1 = Track2.StreamState || (Track2.StreamState = {}));
    function kindToProto(k2) {
      switch (k2) {
        case Kind.Audio:
          return TrackType.AUDIO;
        case Kind.Video:
          return TrackType.VIDEO;
        default:
          return TrackType.DATA;
      }
    }
    Track2.kindToProto = kindToProto;
    function kindFromProto(t) {
      switch (t) {
        case TrackType.AUDIO:
          return Kind.Audio;
        case TrackType.VIDEO:
          return Kind.Video;
        default:
          return Kind.Unknown;
      }
    }
    Track2.kindFromProto = kindFromProto;
    function sourceToProto(s) {
      switch (s) {
        case Source.Camera:
          return TrackSource.CAMERA;
        case Source.Microphone:
          return TrackSource.MICROPHONE;
        case Source.ScreenShare:
          return TrackSource.SCREEN_SHARE;
        case Source.ScreenShareAudio:
          return TrackSource.SCREEN_SHARE_AUDIO;
        default:
          return TrackSource.UNKNOWN;
      }
    }
    Track2.sourceToProto = sourceToProto;
    function sourceFromProto(s) {
      switch (s) {
        case TrackSource.CAMERA:
          return Source.Camera;
        case TrackSource.MICROPHONE:
          return Source.Microphone;
        case TrackSource.SCREEN_SHARE:
          return Source.ScreenShare;
        case TrackSource.SCREEN_SHARE_AUDIO:
          return Source.ScreenShareAudio;
        default:
          return Source.Unknown;
      }
    }
    Track2.sourceFromProto = sourceFromProto;
    function streamStateFromProto(s) {
      switch (s) {
        case StreamState.ACTIVE:
          return StreamState$1.Active;
        case StreamState.PAUSED:
          return StreamState$1.Paused;
        default:
          return StreamState$1.Unknown;
      }
    }
    Track2.streamStateFromProto = streamStateFromProto;
  })(Track || (Track = {}));
  function mergeDefaultOptions(options, audioDefaults2, videoDefaults2) {
    var _a;
    const {
      optionsWithoutProcessor,
      audioProcessor,
      videoProcessor
    } = extractProcessorsFromOptions(options !== null && options !== void 0 ? options : {});
    const clonedOptions = (_a = cloneDeep(optionsWithoutProcessor)) !== null && _a !== void 0 ? _a : {};
    if (clonedOptions.audio === true) clonedOptions.audio = {};
    if (clonedOptions.video === true) clonedOptions.video = {};
    if (clonedOptions.audio) {
      mergeObjectWithoutOverwriting(clonedOptions.audio, audioDefaults2);
      if (audioProcessor) {
        clonedOptions.audio.processor = audioProcessor;
      }
    }
    if (clonedOptions.video) {
      mergeObjectWithoutOverwriting(clonedOptions.video, videoDefaults2);
      if (videoProcessor) {
        clonedOptions.video.processor = videoProcessor;
      }
    }
    return clonedOptions;
  }
  function mergeObjectWithoutOverwriting(mainObject, objectToMerge) {
    Object.keys(objectToMerge).forEach((key) => {
      if (mainObject[key] === void 0) mainObject[key] = objectToMerge[key];
    });
    return mainObject;
  }
  function constraintsForOptions(options) {
    const constraints = {};
    if (options.video) {
      if (typeof options.video === "object") {
        const videoOptions = {};
        const target = videoOptions;
        const source = options.video;
        Object.keys(source).forEach((key) => {
          switch (key) {
            case "resolution":
              mergeObjectWithoutOverwriting(target, source.resolution);
              break;
            default:
              target[key] = source[key];
          }
        });
        constraints.video = videoOptions;
      } else {
        constraints.video = options.video;
      }
    } else {
      constraints.video = false;
    }
    if (options.audio) {
      if (typeof options.audio === "object") {
        constraints.audio = options.audio;
      } else {
        constraints.audio = true;
      }
    } else {
      constraints.audio = false;
    }
    return constraints;
  }
  function detectSilence(track_1) {
    return __awaiter(this, arguments, void 0, function(track) {
      let timeOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;
      return function* () {
        const ctx = getNewAudioContext();
        if (ctx) {
          const analyser = ctx.createAnalyser();
          analyser.fftSize = 2048;
          const bufferLength = analyser.frequencyBinCount;
          const dataArray = new Uint8Array(bufferLength);
          const source = ctx.createMediaStreamSource(new MediaStream([track.mediaStreamTrack]));
          source.connect(analyser);
          yield sleep(timeOffset);
          analyser.getByteTimeDomainData(dataArray);
          const someNoise = dataArray.some((sample) => sample !== 128 && sample !== 0);
          ctx.close();
          return !someNoise;
        }
        return false;
      }();
    });
  }
  function getNewAudioContext() {
    const AudioContext2 = (
      // @ts-ignore
      typeof window !== "undefined" && (window.AudioContext || window.webkitAudioContext)
    );
    if (AudioContext2) {
      return new AudioContext2({
        latencyHint: "interactive"
      });
    }
  }
  function sourceToKind(source) {
    if (source === Track.Source.Microphone) {
      return "audioinput";
    } else if (source === Track.Source.Camera) {
      return "videoinput";
    } else {
      return void 0;
    }
  }
  function screenCaptureToDisplayMediaStreamOptions(options) {
    var _a, _b;
    let videoConstraints = (_a = options.video) !== null && _a !== void 0 ? _a : true;
    if (options.resolution && options.resolution.width > 0 && options.resolution.height > 0) {
      videoConstraints = typeof videoConstraints === "boolean" ? {} : videoConstraints;
      if (isSafari()) {
        videoConstraints = Object.assign(Object.assign({}, videoConstraints), {
          width: {
            max: options.resolution.width
          },
          height: {
            max: options.resolution.height
          },
          frameRate: options.resolution.frameRate
        });
      } else {
        videoConstraints = Object.assign(Object.assign({}, videoConstraints), {
          width: {
            ideal: options.resolution.width
          },
          height: {
            ideal: options.resolution.height
          },
          frameRate: options.resolution.frameRate
        });
      }
    }
    return {
      audio: (_b = options.audio) !== null && _b !== void 0 ? _b : false,
      video: videoConstraints,
      // @ts-expect-error support for experimental display media features
      controller: options.controller,
      selfBrowserSurface: options.selfBrowserSurface,
      surfaceSwitching: options.surfaceSwitching,
      systemAudio: options.systemAudio,
      preferCurrentTab: options.preferCurrentTab
    };
  }
  function mimeTypeToVideoCodecString(mimeType) {
    return mimeType.split("/")[1].toLowerCase();
  }
  function getTrackPublicationInfo(tracks) {
    const infos = [];
    tracks.forEach((track) => {
      if (track.track !== void 0) {
        infos.push(new TrackPublishedResponse({
          cid: track.track.mediaStreamID,
          track: track.trackInfo
        }));
      }
    });
    return infos;
  }
  function getLogContextFromTrack(track) {
    if (track instanceof Track) {
      return {
        trackID: track.sid,
        source: track.source,
        muted: track.isMuted,
        enabled: track.mediaStreamTrack.enabled,
        kind: track.kind,
        streamID: track.mediaStreamID,
        streamTrackID: track.mediaStreamTrack.id
      };
    } else {
      return {
        trackID: track.trackSid,
        enabled: track.isEnabled,
        muted: track.isMuted,
        trackInfo: Object.assign({
          mimeType: track.mimeType,
          name: track.trackName,
          encrypted: track.isEncrypted,
          kind: track.kind,
          source: track.source
        }, track.track ? getLogContextFromTrack(track.track) : {})
      };
    }
  }
  function supportsSynchronizationSources() {
    return typeof RTCRtpReceiver !== "undefined" && "getSynchronizationSources" in RTCRtpReceiver;
  }
  function diffAttributes(oldValues, newValues) {
    var _a;
    if (oldValues === void 0) {
      oldValues = {};
    }
    if (newValues === void 0) {
      newValues = {};
    }
    const allKeys = [...Object.keys(newValues), ...Object.keys(oldValues)];
    const diff = {};
    for (const key of allKeys) {
      if (oldValues[key] !== newValues[key]) {
        diff[key] = (_a = newValues[key]) !== null && _a !== void 0 ? _a : "";
      }
    }
    return diff;
  }
  function extractProcessorsFromOptions(options) {
    const newOptions = Object.assign({}, options);
    let audioProcessor;
    let videoProcessor;
    if (typeof newOptions.audio === "object" && newOptions.audio.processor) {
      audioProcessor = newOptions.audio.processor;
      newOptions.audio = Object.assign(Object.assign({}, newOptions.audio), {
        processor: void 0
      });
    }
    if (typeof newOptions.video === "object" && newOptions.video.processor) {
      videoProcessor = newOptions.video.processor;
      newOptions.video = Object.assign(Object.assign({}, newOptions.video), {
        processor: void 0
      });
    }
    return {
      audioProcessor,
      videoProcessor,
      optionsWithoutProcessor: newOptions
    };
  }
  var separator = "|";
  var ddExtensionURI = "https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension";
  function unpackStreamId(packed) {
    const parts = packed.split(separator);
    if (parts.length > 1) {
      return [parts[0], packed.substr(parts[0].length + 1)];
    }
    return [packed, ""];
  }
  function sleep(duration) {
    return __awaiter(this, void 0, void 0, function* () {
      return new Promise((resolve) => CriticalTimers.setTimeout(resolve, duration));
    });
  }
  function supportsTransceiver() {
    return "addTransceiver" in RTCPeerConnection.prototype;
  }
  function supportsAddTrack() {
    return "addTrack" in RTCPeerConnection.prototype;
  }
  function supportsAV1() {
    if (!("getCapabilities" in RTCRtpSender)) {
      return false;
    }
    if (isSafari()) {
      return false;
    }
    const capabilities = RTCRtpSender.getCapabilities("video");
    let hasAV1 = false;
    if (capabilities) {
      for (const codec of capabilities.codecs) {
        if (codec.mimeType === "video/AV1") {
          hasAV1 = true;
          break;
        }
      }
    }
    return hasAV1;
  }
  function supportsVP9() {
    if (!("getCapabilities" in RTCRtpSender)) {
      return false;
    }
    if (isFireFox()) {
      return false;
    }
    if (isSafari()) {
      const browser = getBrowser();
      if ((browser === null || browser === void 0 ? void 0 : browser.version) && compareVersions(browser.version, "16") < 0) {
        return false;
      }
    }
    const capabilities = RTCRtpSender.getCapabilities("video");
    let hasVP9 = false;
    if (capabilities) {
      for (const codec of capabilities.codecs) {
        if (codec.mimeType === "video/VP9") {
          hasVP9 = true;
          break;
        }
      }
    }
    return hasVP9;
  }
  function isSVCCodec(codec) {
    return codec === "av1" || codec === "vp9";
  }
  function supportsSetSinkId(elm) {
    if (!document) {
      return false;
    }
    if (!elm) {
      elm = document.createElement("audio");
    }
    return "setSinkId" in elm;
  }
  function isBrowserSupported() {
    if (typeof RTCPeerConnection === "undefined") {
      return false;
    }
    return supportsTransceiver() || supportsAddTrack();
  }
  function isFireFox() {
    var _a;
    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === "Firefox";
  }
  function isSafari() {
    var _a;
    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === "Safari";
  }
  function isSafari17() {
    const b = getBrowser();
    return (b === null || b === void 0 ? void 0 : b.name) === "Safari" && b.version.startsWith("17.");
  }
  function isMobile() {
    var _a, _b;
    if (!isWeb()) return false;
    return (
      // @ts-expect-error `userAgentData` is not yet part of typescript
      (_b = (_a = navigator.userAgentData) === null || _a === void 0 ? void 0 : _a.mobile) !== null && _b !== void 0 ? _b : /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent)
    );
  }
  function isE2EESimulcastSupported() {
    const browser = getBrowser();
    const supportedSafariVersion = "17.2";
    if (browser) {
      if (browser.name !== "Safari" && browser.os !== "iOS") {
        return true;
      } else if (browser.os === "iOS" && browser.osVersion && compareVersions(supportedSafariVersion, browser.osVersion) >= 0) {
        return true;
      } else if (browser.name === "Safari" && compareVersions(supportedSafariVersion, browser.version) >= 0) {
        return true;
      } else {
        return false;
      }
    }
  }
  function isWeb() {
    return typeof document !== "undefined";
  }
  function isReactNative() {
    return navigator.product == "ReactNative";
  }
  function isCloud(serverUrl) {
    return serverUrl.hostname.endsWith(".livekit.cloud") || serverUrl.hostname.endsWith(".livekit.run");
  }
  function getLKReactNativeInfo() {
    if (global && global.LiveKitReactNativeGlobal) {
      return global.LiveKitReactNativeGlobal;
    }
    return void 0;
  }
  function getReactNativeOs() {
    if (!isReactNative()) {
      return void 0;
    }
    let info = getLKReactNativeInfo();
    if (info) {
      return info.platform;
    }
    return void 0;
  }
  function getDevicePixelRatio() {
    if (isWeb()) {
      return window.devicePixelRatio;
    }
    if (isReactNative()) {
      let info = getLKReactNativeInfo();
      if (info) {
        return info.devicePixelRatio;
      }
    }
    return 1;
  }
  function compareVersions(v1, v2) {
    const parts1 = v1.split(".");
    const parts2 = v2.split(".");
    const k2 = Math.min(parts1.length, parts2.length);
    for (let i = 0; i < k2; ++i) {
      const p1 = parseInt(parts1[i], 10);
      const p2 = parseInt(parts2[i], 10);
      if (p1 > p2) return 1;
      if (p1 < p2) return -1;
      if (i === k2 - 1 && p1 === p2) return 0;
    }
    if (v1 === "" && v2 !== "") {
      return -1;
    } else if (v2 === "") {
      return 1;
    }
    return parts1.length == parts2.length ? 0 : parts1.length < parts2.length ? -1 : 1;
  }
  function roDispatchCallback(entries) {
    for (const entry of entries) {
      entry.target.handleResize(entry);
    }
  }
  function ioDispatchCallback(entries) {
    for (const entry of entries) {
      entry.target.handleVisibilityChanged(entry);
    }
  }
  var resizeObserver = null;
  var getResizeObserver = () => {
    if (!resizeObserver) resizeObserver = new ResizeObserver(roDispatchCallback);
    return resizeObserver;
  };
  var intersectionObserver = null;
  var getIntersectionObserver = () => {
    if (!intersectionObserver) {
      intersectionObserver = new IntersectionObserver(ioDispatchCallback, {
        root: null,
        rootMargin: "0px"
      });
    }
    return intersectionObserver;
  };
  function getClientInfo() {
    var _a;
    const info = new ClientInfo({
      sdk: ClientInfo_SDK.JS,
      protocol: protocolVersion,
      version
    });
    if (isReactNative()) {
      info.os = (_a = getReactNativeOs()) !== null && _a !== void 0 ? _a : "";
    }
    return info;
  }
  function createDummyVideoStreamTrack() {
    let width = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16;
    let height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 16;
    let enabled = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    let paintContent = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    ctx === null || ctx === void 0 ? void 0 : ctx.fillRect(0, 0, canvas.width, canvas.height);
    if (paintContent && ctx) {
      ctx.beginPath();
      ctx.arc(width / 2, height / 2, 50, 0, Math.PI * 2, true);
      ctx.closePath();
      ctx.fillStyle = "grey";
      ctx.fill();
    }
    const dummyStream = canvas.captureStream();
    const [dummyTrack] = dummyStream.getTracks();
    if (!dummyTrack) {
      throw Error("Could not get empty media stream video track");
    }
    dummyTrack.enabled = enabled;
    return dummyTrack;
  }
  var emptyAudioStreamTrack;
  function getEmptyAudioStreamTrack() {
    if (!emptyAudioStreamTrack) {
      const ctx = new AudioContext();
      const oscillator = ctx.createOscillator();
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0, 0);
      const dst = ctx.createMediaStreamDestination();
      oscillator.connect(gain);
      gain.connect(dst);
      oscillator.start();
      [emptyAudioStreamTrack] = dst.stream.getAudioTracks();
      if (!emptyAudioStreamTrack) {
        throw Error("Could not get empty media stream audio track");
      }
      emptyAudioStreamTrack.enabled = false;
    }
    return emptyAudioStreamTrack.clone();
  }
  var Future = class {
    constructor(futureBase, onFinally) {
      this.onFinally = onFinally;
      this.promise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
        this.resolve = resolve;
        this.reject = reject;
        if (futureBase) {
          yield futureBase(resolve, reject);
        }
      })).finally(() => {
        var _a;
        return (_a = this.onFinally) === null || _a === void 0 ? void 0 : _a.call(this);
      });
    }
  };
  function createAudioAnalyser(track, options) {
    const opts = Object.assign({
      cloneTrack: false,
      fftSize: 2048,
      smoothingTimeConstant: 0.8,
      minDecibels: -100,
      maxDecibels: -80
    }, options);
    const audioContext = getNewAudioContext();
    if (!audioContext) {
      throw new Error("Audio Context not supported on this browser");
    }
    const streamTrack = opts.cloneTrack ? track.mediaStreamTrack.clone() : track.mediaStreamTrack;
    const mediaStreamSource = audioContext.createMediaStreamSource(new MediaStream([streamTrack]));
    const analyser = audioContext.createAnalyser();
    analyser.minDecibels = opts.minDecibels;
    analyser.maxDecibels = opts.maxDecibels;
    analyser.fftSize = opts.fftSize;
    analyser.smoothingTimeConstant = opts.smoothingTimeConstant;
    mediaStreamSource.connect(analyser);
    const dataArray = new Uint8Array(analyser.frequencyBinCount);
    const calculateVolume = () => {
      analyser.getByteFrequencyData(dataArray);
      let sum = 0;
      for (const amplitude of dataArray) {
        sum += Math.pow(amplitude / 255, 2);
      }
      const volume = Math.sqrt(sum / dataArray.length);
      return volume;
    };
    const cleanup = () => __awaiter(this, void 0, void 0, function* () {
      yield audioContext.close();
      if (opts.cloneTrack) {
        streamTrack.stop();
      }
    });
    return {
      calculateVolume,
      analyser,
      cleanup
    };
  }
  function isVideoCodec(maybeCodec) {
    return videoCodecs.includes(maybeCodec);
  }
  function unwrapConstraint(constraint) {
    if (typeof constraint === "string" || typeof constraint === "number") {
      return constraint;
    }
    if (Array.isArray(constraint)) {
      return constraint[0];
    }
    if (constraint.exact) {
      if (Array.isArray(constraint.exact)) {
        return constraint.exact[0];
      }
      return constraint.exact;
    }
    if (constraint.ideal) {
      if (Array.isArray(constraint.ideal)) {
        return constraint.ideal[0];
      }
      return constraint.ideal;
    }
    throw Error("could not unwrap constraint");
  }
  function toWebsocketUrl(url2) {
    if (url2.startsWith("http")) {
      return url2.replace(/^(http)/, "ws");
    }
    return url2;
  }
  function toHttpUrl(url2) {
    if (url2.startsWith("ws")) {
      return url2.replace(/^(ws)/, "http");
    }
    return url2;
  }
  function extractTranscriptionSegments(transcription, firstReceivedTimesMap) {
    return transcription.segments.map((_ref) => {
      let {
        id,
        text,
        language,
        startTime,
        endTime,
        final
      } = _ref;
      var _a;
      const firstReceivedTime = (_a = firstReceivedTimesMap.get(id)) !== null && _a !== void 0 ? _a : Date.now();
      const lastReceivedTime = Date.now();
      if (final) {
        firstReceivedTimesMap.delete(id);
      } else {
        firstReceivedTimesMap.set(id, firstReceivedTime);
      }
      return {
        id,
        text,
        startTime: Number.parseInt(startTime.toString()),
        endTime: Number.parseInt(endTime.toString()),
        final,
        language,
        firstReceivedTime,
        lastReceivedTime
      };
    });
  }
  function extractChatMessage(msg) {
    const {
      id,
      timestamp,
      message,
      editTimestamp
    } = msg;
    return {
      id,
      timestamp: Number.parseInt(timestamp.toString()),
      editTimestamp: editTimestamp ? Number.parseInt(editTimestamp.toString()) : void 0,
      message
    };
  }
  function getDisconnectReasonFromConnectionError(e) {
    switch (e.reason) {
      case ConnectionErrorReason.LeaveRequest:
        return e.context;
      case ConnectionErrorReason.Cancelled:
        return DisconnectReason.CLIENT_INITIATED;
      case ConnectionErrorReason.NotAllowed:
        return DisconnectReason.USER_REJECTED;
      case ConnectionErrorReason.ServerUnreachable:
        return DisconnectReason.JOIN_FAILURE;
      default:
        return DisconnectReason.UNKNOWN_REASON;
    }
  }
  var defaultId = "default";
  var DeviceManager = class _DeviceManager {
    static getInstance() {
      if (this.instance === void 0) {
        this.instance = new _DeviceManager();
      }
      return this.instance;
    }
    getDevices(kind_1) {
      return __awaiter(this, arguments, void 0, function(kind) {
        var _this = this;
        let requestPermissions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        return function* () {
          var _a;
          if (((_a = _DeviceManager.userMediaPromiseMap) === null || _a === void 0 ? void 0 : _a.size) > 0) {
            livekitLogger.debug("awaiting getUserMedia promise");
            try {
              if (kind) {
                yield _DeviceManager.userMediaPromiseMap.get(kind);
              } else {
                yield Promise.all(_DeviceManager.userMediaPromiseMap.values());
              }
            } catch (e) {
              livekitLogger.warn("error waiting for media permissons");
            }
          }
          let devices = yield navigator.mediaDevices.enumerateDevices();
          if (requestPermissions && // for safari we need to skip this check, as otherwise it will re-acquire user media and fail on iOS https://bugs.webkit.org/show_bug.cgi?id=179363
          !(isSafari() && _this.hasDeviceInUse(kind))) {
            const isDummyDeviceOrEmpty = devices.filter((d) => d.kind === kind).length === 0 || devices.some((device) => {
              const noLabel = device.label === "";
              const isRelevant = kind ? device.kind === kind : true;
              return noLabel && isRelevant;
            });
            if (isDummyDeviceOrEmpty) {
              const permissionsToAcquire = {
                video: kind !== "audioinput" && kind !== "audiooutput",
                audio: kind !== "videoinput"
              };
              const stream4 = yield navigator.mediaDevices.getUserMedia(permissionsToAcquire);
              devices = yield navigator.mediaDevices.enumerateDevices();
              stream4.getTracks().forEach((track) => {
                track.stop();
              });
            }
          }
          if (kind) {
            devices = devices.filter((device) => device.kind === kind);
          }
          return devices;
        }();
      });
    }
    normalizeDeviceId(kind, deviceId, groupId) {
      return __awaiter(this, void 0, void 0, function* () {
        if (deviceId !== defaultId) {
          return deviceId;
        }
        const devices = yield this.getDevices(kind);
        const defaultDevice = devices.find((d) => d.deviceId === defaultId);
        if (!defaultDevice) {
          livekitLogger.warn("could not reliably determine default device");
          return void 0;
        }
        const device = devices.find((d) => d.deviceId !== defaultId && d.groupId === (groupId !== null && groupId !== void 0 ? groupId : defaultDevice.groupId));
        if (!device) {
          livekitLogger.warn("could not reliably determine default device");
          return void 0;
        }
        return device === null || device === void 0 ? void 0 : device.deviceId;
      });
    }
    hasDeviceInUse(kind) {
      return kind ? _DeviceManager.userMediaPromiseMap.has(kind) : _DeviceManager.userMediaPromiseMap.size > 0;
    }
  };
  DeviceManager.mediaDeviceKinds = ["audioinput", "audiooutput", "videoinput"];
  DeviceManager.userMediaPromiseMap = /* @__PURE__ */ new Map();
  var defaultDimensionsTimeout = 1e3;
  var LocalTrack = class extends Track {
    /** @internal */
    get sender() {
      return this._sender;
    }
    /** @internal */
    set sender(sender) {
      this._sender = sender;
    }
    get constraints() {
      return this._constraints;
    }
    /**
     *
     * @param mediaTrack
     * @param kind
     * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
     * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
     */
    constructor(mediaTrack, kind, constraints) {
      let userProvidedTrack = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      let loggerOptions = arguments.length > 4 ? arguments[4] : void 0;
      super(mediaTrack, kind, loggerOptions);
      this.manuallyStopped = false;
      this._isUpstreamPaused = false;
      this.handleTrackMuteEvent = () => this.debouncedTrackMuteHandler().catch(() => this.log.debug("track mute bounce got cancelled by an unmute event", this.logContext));
      this.debouncedTrackMuteHandler = r(() => __awaiter(this, void 0, void 0, function* () {
        yield this.pauseUpstream();
      }), 5e3);
      this.handleTrackUnmuteEvent = () => __awaiter(this, void 0, void 0, function* () {
        this.debouncedTrackMuteHandler.cancel("unmute");
        yield this.resumeUpstream();
      });
      this.handleEnded = () => {
        if (this.isInBackground) {
          this.reacquireTrack = true;
        }
        this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent);
        this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent);
        this.emit(TrackEvent.Ended, this);
      };
      this.reacquireTrack = false;
      this.providedByUser = userProvidedTrack;
      this.muteLock = new h();
      this.pauseUpstreamLock = new h();
      this.processorLock = new h();
      this.restartLock = new h();
      this.setMediaStreamTrack(mediaTrack, true);
      this._constraints = mediaTrack.getConstraints();
      if (constraints) {
        this._constraints = constraints;
      }
    }
    get id() {
      return this._mediaStreamTrack.id;
    }
    get dimensions() {
      if (this.kind !== Track.Kind.Video) {
        return void 0;
      }
      const {
        width,
        height
      } = this._mediaStreamTrack.getSettings();
      if (width && height) {
        return {
          width,
          height
        };
      }
      return void 0;
    }
    get isUpstreamPaused() {
      return this._isUpstreamPaused;
    }
    get isUserProvided() {
      return this.providedByUser;
    }
    get mediaStreamTrack() {
      var _a, _b;
      return (_b = (_a = this.processor) === null || _a === void 0 ? void 0 : _a.processedTrack) !== null && _b !== void 0 ? _b : this._mediaStreamTrack;
    }
    /**
     * @internal
     * returns mediaStreamTrack settings of the capturing mediastreamtrack source - ignoring processors
     */
    getSourceTrackSettings() {
      return this._mediaStreamTrack.getSettings();
    }
    setMediaStreamTrack(newTrack, force) {
      return __awaiter(this, void 0, void 0, function* () {
        if (newTrack === this._mediaStreamTrack && !force) {
          return;
        }
        if (this._mediaStreamTrack) {
          this.attachedElements.forEach((el) => {
            detachTrack(this._mediaStreamTrack, el);
          });
          this.debouncedTrackMuteHandler.cancel("new-track");
          this._mediaStreamTrack.removeEventListener("ended", this.handleEnded);
          this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent);
          this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent);
        }
        this.mediaStream = new MediaStream([newTrack]);
        if (newTrack) {
          newTrack.addEventListener("ended", this.handleEnded);
          newTrack.addEventListener("mute", this.handleTrackMuteEvent);
          newTrack.addEventListener("unmute", this.handleTrackUnmuteEvent);
          this._constraints = newTrack.getConstraints();
        }
        let processedTrack;
        if (this.processor && newTrack) {
          const unlock = yield this.processorLock.lock();
          try {
            this.log.debug("restarting processor", this.logContext);
            if (this.kind === "unknown") {
              throw TypeError("cannot set processor on track of unknown kind");
            }
            if (this.processorElement) {
              attachToElement(newTrack, this.processorElement);
              this.processorElement.muted = true;
            }
            yield this.processor.restart({
              track: newTrack,
              kind: this.kind,
              element: this.processorElement
            });
            processedTrack = this.processor.processedTrack;
          } finally {
            unlock();
          }
        }
        if (this.sender) {
          yield this.sender.replaceTrack(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack);
        }
        if (!this.providedByUser && this._mediaStreamTrack !== newTrack) {
          this._mediaStreamTrack.stop();
        }
        this._mediaStreamTrack = newTrack;
        if (newTrack) {
          this._mediaStreamTrack.enabled = !this.isMuted;
          yield this.resumeUpstream();
          this.attachedElements.forEach((el) => {
            attachToElement(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack, el);
          });
        }
      });
    }
    waitForDimensions() {
      return __awaiter(this, arguments, void 0, function() {
        var _this = this;
        let timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultDimensionsTimeout;
        return function* () {
          var _a;
          if (_this.kind === Track.Kind.Audio) {
            throw new Error("cannot get dimensions for audio tracks");
          }
          if (((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.os) === "iOS") {
            yield sleep(10);
          }
          const started = Date.now();
          while (Date.now() - started < timeout) {
            const dims = _this.dimensions;
            if (dims) {
              return dims;
            }
            yield sleep(50);
          }
          throw new TrackInvalidError("unable to get track dimensions after timeout");
        }();
      });
    }
    /**
     * @returns DeviceID of the device that is currently being used for this track
     */
    getDeviceId() {
      return __awaiter(this, arguments, void 0, function() {
        var _this2 = this;
        let normalize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        return function* () {
          if (_this2.source === Track.Source.ScreenShare) {
            return;
          }
          const {
            deviceId,
            groupId
          } = _this2._mediaStreamTrack.getSettings();
          const kind = _this2.kind === Track.Kind.Audio ? "audioinput" : "videoinput";
          return normalize ? DeviceManager.getInstance().normalizeDeviceId(kind, deviceId, groupId) : deviceId;
        }();
      });
    }
    mute() {
      return __awaiter(this, void 0, void 0, function* () {
        this.setTrackMuted(true);
        return this;
      });
    }
    unmute() {
      return __awaiter(this, void 0, void 0, function* () {
        this.setTrackMuted(false);
        return this;
      });
    }
    replaceTrack(track, userProvidedOrOptions) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.sender) {
          throw new TrackInvalidError("unable to replace an unpublished track");
        }
        let userProvidedTrack;
        let stopProcessor;
        if (typeof userProvidedOrOptions === "boolean") {
          userProvidedTrack = userProvidedOrOptions;
        } else if (userProvidedOrOptions !== void 0) {
          userProvidedTrack = userProvidedOrOptions.userProvidedTrack;
          stopProcessor = userProvidedOrOptions.stopProcessor;
        }
        this.providedByUser = userProvidedTrack !== null && userProvidedTrack !== void 0 ? userProvidedTrack : true;
        this.log.debug("replace MediaStreamTrack", this.logContext);
        yield this.setMediaStreamTrack(track);
        if (stopProcessor && this.processor) {
          yield this.stopProcessor();
        }
        return this;
      });
    }
    restart(constraints) {
      return __awaiter(this, void 0, void 0, function* () {
        this.manuallyStopped = false;
        const unlock = yield this.restartLock.lock();
        try {
          if (!constraints) {
            constraints = this._constraints;
          }
          this.log.debug("restarting track with constraints", Object.assign(Object.assign({}, this.logContext), {
            constraints
          }));
          const streamConstraints = {
            audio: false,
            video: false
          };
          if (this.kind === Track.Kind.Video) {
            streamConstraints.video = constraints;
          } else {
            streamConstraints.audio = constraints;
          }
          this.attachedElements.forEach((el) => {
            detachTrack(this.mediaStreamTrack, el);
          });
          this._mediaStreamTrack.removeEventListener("ended", this.handleEnded);
          this._mediaStreamTrack.stop();
          const mediaStream = yield navigator.mediaDevices.getUserMedia(streamConstraints);
          const newTrack = mediaStream.getTracks()[0];
          newTrack.addEventListener("ended", this.handleEnded);
          this.log.debug("re-acquired MediaStreamTrack", this.logContext);
          yield this.setMediaStreamTrack(newTrack);
          this._constraints = constraints;
          this.emit(TrackEvent.Restarted, this);
          if (this.manuallyStopped) {
            this.log.warn("track was stopped during a restart, stopping restarted track", this.logContext);
            this.stop();
          }
          return this;
        } finally {
          unlock();
        }
      });
    }
    setTrackMuted(muted) {
      this.log.debug("setting ".concat(this.kind, " track ").concat(muted ? "muted" : "unmuted"), this.logContext);
      if (this.isMuted === muted && this._mediaStreamTrack.enabled !== muted) {
        return;
      }
      this.isMuted = muted;
      this._mediaStreamTrack.enabled = !muted;
      this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);
    }
    get needsReAcquisition() {
      return this._mediaStreamTrack.readyState !== "live" || this._mediaStreamTrack.muted || !this._mediaStreamTrack.enabled || this.reacquireTrack;
    }
    handleAppVisibilityChanged() {
      const _super = Object.create(null, {
        handleAppVisibilityChanged: {
          get: () => super.handleAppVisibilityChanged
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        yield _super.handleAppVisibilityChanged.call(this);
        if (!isMobile()) return;
        this.log.debug("visibility changed, is in Background: ".concat(this.isInBackground), this.logContext);
        if (!this.isInBackground && this.needsReAcquisition && !this.isUserProvided && !this.isMuted) {
          this.log.debug("track needs to be reacquired, restarting ".concat(this.source), this.logContext);
          yield this.restart();
          this.reacquireTrack = false;
        }
      });
    }
    stop() {
      var _a;
      this.manuallyStopped = true;
      super.stop();
      this._mediaStreamTrack.removeEventListener("ended", this.handleEnded);
      this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent);
      this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent);
      (_a = this.processor) === null || _a === void 0 ? void 0 : _a.destroy();
      this.processor = void 0;
    }
    /**
     * pauses publishing to the server without disabling the local MediaStreamTrack
     * this is used to display a user's own video locally while pausing publishing to
     * the server.
     * this API is unsupported on Safari < 12 due to a bug
     **/
    pauseUpstream() {
      return __awaiter(this, void 0, void 0, function* () {
        const unlock = yield this.pauseUpstreamLock.lock();
        try {
          if (this._isUpstreamPaused === true) {
            return;
          }
          if (!this.sender) {
            this.log.warn("unable to pause upstream for an unpublished track", this.logContext);
            return;
          }
          this._isUpstreamPaused = true;
          this.emit(TrackEvent.UpstreamPaused, this);
          const browser = getBrowser();
          if ((browser === null || browser === void 0 ? void 0 : browser.name) === "Safari" && compareVersions(browser.version, "12.0") < 0) {
            throw new DeviceUnsupportedError("pauseUpstream is not supported on Safari < 12.");
          }
          yield this.sender.replaceTrack(null);
        } finally {
          unlock();
        }
      });
    }
    resumeUpstream() {
      return __awaiter(this, void 0, void 0, function* () {
        const unlock = yield this.pauseUpstreamLock.lock();
        try {
          if (this._isUpstreamPaused === false) {
            return;
          }
          if (!this.sender) {
            this.log.warn("unable to resume upstream for an unpublished track", this.logContext);
            return;
          }
          this._isUpstreamPaused = false;
          this.emit(TrackEvent.UpstreamResumed, this);
          yield this.sender.replaceTrack(this.mediaStreamTrack);
        } finally {
          unlock();
        }
      });
    }
    /**
     * Gets the RTCStatsReport for the LocalTrack's underlying RTCRtpSender
     * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport
     *
     * @returns Promise<RTCStatsReport> | undefined
     */
    getRTCStatsReport() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {
          return;
        }
        const statsReport = yield this.sender.getStats();
        return statsReport;
      });
    }
    /**
     * Sets a processor on this track.
     * See https://github.com/livekit/track-processors-js for example usage
     *
     * @experimental
     *
     * @param processor
     * @param showProcessedStreamLocally
     * @returns
     */
    setProcessor(processor_1) {
      return __awaiter(this, arguments, void 0, function(processor) {
        var _this3 = this;
        let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        return function* () {
          var _a;
          const unlock = yield _this3.processorLock.lock();
          try {
            _this3.log.debug("setting up processor", _this3.logContext);
            const processorElement = document.createElement(_this3.kind);
            const processorOptions = {
              kind: _this3.kind,
              track: _this3._mediaStreamTrack,
              element: processorElement,
              audioContext: _this3.audioContext
            };
            yield processor.init(processorOptions);
            _this3.log.debug("processor initialized", _this3.logContext);
            if (_this3.processor) {
              yield _this3.stopProcessor();
            }
            if (_this3.kind === "unknown") {
              throw TypeError("cannot set processor on track of unknown kind");
            }
            attachToElement(_this3._mediaStreamTrack, processorElement);
            processorElement.muted = true;
            processorElement.play().catch((error) => _this3.log.error("failed to play processor element", Object.assign(Object.assign({}, _this3.logContext), {
              error
            })));
            _this3.processor = processor;
            _this3.processorElement = processorElement;
            if (_this3.processor.processedTrack) {
              for (const el of _this3.attachedElements) {
                if (el !== _this3.processorElement && showProcessedStreamLocally) {
                  detachTrack(_this3._mediaStreamTrack, el);
                  attachToElement(_this3.processor.processedTrack, el);
                }
              }
              yield (_a = _this3.sender) === null || _a === void 0 ? void 0 : _a.replaceTrack(_this3.processor.processedTrack);
            }
            _this3.emit(TrackEvent.TrackProcessorUpdate, _this3.processor);
          } finally {
            unlock();
          }
        }();
      });
    }
    getProcessor() {
      return this.processor;
    }
    /**
     * Stops the track processor
     * See https://github.com/livekit/track-processors-js for example usage
     *
     * @experimental
     * @returns
     */
    stopProcessor() {
      return __awaiter(this, arguments, void 0, function() {
        var _this4 = this;
        let keepElement = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        return function* () {
          var _a, _b;
          if (!_this4.processor) return;
          _this4.log.debug("stopping processor", _this4.logContext);
          (_a = _this4.processor.processedTrack) === null || _a === void 0 ? void 0 : _a.stop();
          yield _this4.processor.destroy();
          _this4.processor = void 0;
          if (!keepElement) {
            (_b = _this4.processorElement) === null || _b === void 0 ? void 0 : _b.remove();
            _this4.processorElement = void 0;
          }
          yield _this4._mediaStreamTrack.applyConstraints(_this4._constraints);
          yield _this4.setMediaStreamTrack(_this4._mediaStreamTrack, true);
          _this4.emit(TrackEvent.TrackProcessorUpdate);
        }();
      });
    }
  };
  var E2EEManager = class extends eventsExports.EventEmitter {
    constructor(options) {
      super();
      this.onWorkerMessage = (ev) => {
        var _a, _b;
        const {
          kind,
          data
        } = ev.data;
        switch (kind) {
          case "error":
            livekitLogger.error(data.error.message);
            this.emit(EncryptionEvent.EncryptionError, data.error);
            break;
          case "initAck":
            if (data.enabled) {
              this.keyProvider.getKeys().forEach((keyInfo) => {
                this.postKey(keyInfo);
              });
            }
            break;
          case "enable":
            if (data.enabled) {
              this.keyProvider.getKeys().forEach((keyInfo) => {
                this.postKey(keyInfo);
              });
            }
            if (this.encryptionEnabled !== data.enabled && data.participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {
              this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, this.room.localParticipant);
              this.encryptionEnabled = data.enabled;
            } else if (data.participantIdentity) {
              const participant = (_b = this.room) === null || _b === void 0 ? void 0 : _b.getParticipantByIdentity(data.participantIdentity);
              if (!participant) {
                throw TypeError("couldn't set encryption status, participant not found".concat(data.participantIdentity));
              }
              this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, participant);
            }
            break;
          case "ratchetKey":
            this.keyProvider.emit(KeyProviderEvent.KeyRatcheted, data.material, data.keyIndex);
            break;
        }
      };
      this.onWorkerError = (ev) => {
        livekitLogger.error("e2ee worker encountered an error:", {
          error: ev.error
        });
        this.emit(EncryptionEvent.EncryptionError, ev.error);
      };
      this.keyProvider = options.keyProvider;
      this.worker = options.worker;
      this.encryptionEnabled = false;
    }
    /**
     * @internal
     */
    setup(room) {
      if (!isE2EESupported()) {
        throw new DeviceUnsupportedError("tried to setup end-to-end encryption on an unsupported browser");
      }
      livekitLogger.info("setting up e2ee");
      if (room !== this.room) {
        this.room = room;
        this.setupEventListeners(room, this.keyProvider);
        const msg = {
          kind: "init",
          data: {
            keyProviderOptions: this.keyProvider.getOptions(),
            loglevel: workerLogger.getLevel()
          }
        };
        if (this.worker) {
          livekitLogger.info("initializing worker", {
            worker: this.worker
          });
          this.worker.onmessage = this.onWorkerMessage;
          this.worker.onerror = this.onWorkerError;
          this.worker.postMessage(msg);
        }
      }
    }
    /**
     * @internal
     */
    setParticipantCryptorEnabled(enabled, participantIdentity) {
      livekitLogger.debug("set e2ee to ".concat(enabled, " for participant ").concat(participantIdentity));
      this.postEnable(enabled, participantIdentity);
    }
    /**
     * @internal
     */
    setSifTrailer(trailer) {
      if (!trailer || trailer.length === 0) {
        livekitLogger.warn("ignoring server sent trailer as it's empty");
      } else {
        this.postSifTrailer(trailer);
      }
    }
    setupEngine(engine) {
      engine.on(EngineEvent.RTPVideoMapUpdate, (rtpMap) => {
        this.postRTPMap(rtpMap);
      });
    }
    setupEventListeners(room, keyProvider) {
      room.on(RoomEvent.TrackPublished, (pub, participant) => this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity));
      room.on(RoomEvent.ConnectionStateChanged, (state) => {
        if (state === ConnectionState.Connected) {
          room.remoteParticipants.forEach((participant) => {
            participant.trackPublications.forEach((pub) => {
              this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity);
            });
          });
        }
      }).on(RoomEvent.TrackUnsubscribed, (track, _, participant) => {
        var _a;
        const msg = {
          kind: "removeTransform",
          data: {
            participantIdentity: participant.identity,
            trackId: track.mediaStreamID
          }
        };
        (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage(msg);
      }).on(RoomEvent.TrackSubscribed, (track, pub, participant) => {
        this.setupE2EEReceiver(track, participant.identity, pub.trackInfo);
      }).on(RoomEvent.SignalConnected, () => {
        if (!this.room) {
          throw new TypeError("expected room to be present on signal connect");
        }
        keyProvider.getKeys().forEach((keyInfo) => {
          this.postKey(keyInfo);
        });
        this.setParticipantCryptorEnabled(this.room.localParticipant.isE2EEEnabled, this.room.localParticipant.identity);
      });
      room.localParticipant.on(ParticipantEvent.LocalTrackPublished, (publication) => __awaiter(this, void 0, void 0, function* () {
        this.setupE2EESender(publication.track, publication.track.sender);
      }));
      keyProvider.on(KeyProviderEvent.SetKey, (keyInfo) => this.postKey(keyInfo)).on(KeyProviderEvent.RatchetRequest, (participantId, keyIndex) => this.postRatchetRequest(participantId, keyIndex));
    }
    postRatchetRequest(participantIdentity, keyIndex) {
      if (!this.worker) {
        throw Error("could not ratchet key, worker is missing");
      }
      const msg = {
        kind: "ratchetRequest",
        data: {
          participantIdentity,
          keyIndex
        }
      };
      this.worker.postMessage(msg);
    }
    postKey(_ref) {
      let {
        key,
        participantIdentity,
        keyIndex
      } = _ref;
      var _a;
      if (!this.worker) {
        throw Error("could not set key, worker is missing");
      }
      const msg = {
        kind: "setKey",
        data: {
          participantIdentity,
          isPublisher: participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity),
          key,
          keyIndex
        }
      };
      this.worker.postMessage(msg);
    }
    postEnable(enabled, participantIdentity) {
      if (this.worker) {
        const enableMsg = {
          kind: "enable",
          data: {
            enabled,
            participantIdentity
          }
        };
        this.worker.postMessage(enableMsg);
      } else {
        throw new ReferenceError("failed to enable e2ee, worker is not ready");
      }
    }
    postRTPMap(map) {
      var _a;
      if (!this.worker) {
        throw TypeError("could not post rtp map, worker is missing");
      }
      if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {
        throw TypeError("could not post rtp map, local participant identity is missing");
      }
      const msg = {
        kind: "setRTPMap",
        data: {
          map,
          participantIdentity: this.room.localParticipant.identity
        }
      };
      this.worker.postMessage(msg);
    }
    postSifTrailer(trailer) {
      if (!this.worker) {
        throw Error("could not post SIF trailer, worker is missing");
      }
      const msg = {
        kind: "setSifTrailer",
        data: {
          trailer
        }
      };
      this.worker.postMessage(msg);
    }
    setupE2EEReceiver(track, remoteId, trackInfo) {
      if (!track.receiver) {
        return;
      }
      if (!(trackInfo === null || trackInfo === void 0 ? void 0 : trackInfo.mimeType) || trackInfo.mimeType === "") {
        throw new TypeError("MimeType missing from trackInfo, cannot set up E2EE cryptor");
      }
      this.handleReceiver(track.receiver, track.mediaStreamID, remoteId, track.kind === "video" ? mimeTypeToVideoCodecString(trackInfo.mimeType) : void 0);
    }
    setupE2EESender(track, sender) {
      if (!(track instanceof LocalTrack) || !sender) {
        if (!sender) livekitLogger.warn("early return because sender is not ready");
        return;
      }
      this.handleSender(sender, track.mediaStreamID, void 0);
    }
    /**
     * Handles the given {@code RTCRtpReceiver} by creating a {@code TransformStream} which will inject
     * a frame decoder.
     *
     */
    handleReceiver(receiver, trackId, participantIdentity, codec) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.worker) {
          return;
        }
        if (isScriptTransformSupported()) {
          const options = {
            kind: "decode",
            participantIdentity,
            trackId,
            codec
          };
          receiver.transform = new RTCRtpScriptTransform(this.worker, options);
        } else {
          if (E2EE_FLAG in receiver && codec) {
            const msg2 = {
              kind: "updateCodec",
              data: {
                trackId,
                codec,
                participantIdentity
              }
            };
            this.worker.postMessage(msg2);
            return;
          }
          let writable = receiver.writableStream;
          let readable = receiver.readableStream;
          if (!writable || !readable) {
            const receiverStreams = receiver.createEncodedStreams();
            receiver.writableStream = receiverStreams.writable;
            writable = receiverStreams.writable;
            receiver.readableStream = receiverStreams.readable;
            readable = receiverStreams.readable;
          }
          const msg = {
            kind: "decode",
            data: {
              readableStream: readable,
              writableStream: writable,
              trackId,
              codec,
              participantIdentity
            }
          };
          this.worker.postMessage(msg, [readable, writable]);
        }
        receiver[E2EE_FLAG] = true;
      });
    }
    /**
     * Handles the given {@code RTCRtpSender} by creating a {@code TransformStream} which will inject
     * a frame encoder.
     *
     */
    handleSender(sender, trackId, codec) {
      var _a;
      if (E2EE_FLAG in sender || !this.worker) {
        return;
      }
      if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity) || this.room.localParticipant.identity === "") {
        throw TypeError("local identity needs to be known in order to set up encrypted sender");
      }
      if (isScriptTransformSupported()) {
        livekitLogger.info("initialize script transform");
        const options = {
          kind: "encode",
          participantIdentity: this.room.localParticipant.identity,
          trackId,
          codec
        };
        sender.transform = new RTCRtpScriptTransform(this.worker, options);
      } else {
        livekitLogger.info("initialize encoded streams");
        const senderStreams = sender.createEncodedStreams();
        const msg = {
          kind: "encode",
          data: {
            readableStream: senderStreams.readable,
            writableStream: senderStreams.writable,
            codec,
            trackId,
            participantIdentity: this.room.localParticipant.identity
          }
        };
        this.worker.postMessage(msg, [senderStreams.readable, senderStreams.writable]);
      }
      sender[E2EE_FLAG] = true;
    }
  };
  var QueueTaskStatus;
  (function(QueueTaskStatus2) {
    QueueTaskStatus2[QueueTaskStatus2["WAITING"] = 0] = "WAITING";
    QueueTaskStatus2[QueueTaskStatus2["RUNNING"] = 1] = "RUNNING";
    QueueTaskStatus2[QueueTaskStatus2["COMPLETED"] = 2] = "COMPLETED";
  })(QueueTaskStatus || (QueueTaskStatus = {}));
  var AsyncQueue = class {
    constructor() {
      this.pendingTasks = /* @__PURE__ */ new Map();
      this.taskMutex = new h();
      this.nextTaskIndex = 0;
    }
    run(task) {
      return __awaiter(this, void 0, void 0, function* () {
        const taskInfo = {
          id: this.nextTaskIndex++,
          enqueuedAt: Date.now(),
          status: QueueTaskStatus.WAITING
        };
        this.pendingTasks.set(taskInfo.id, taskInfo);
        const unlock = yield this.taskMutex.lock();
        try {
          taskInfo.executedAt = Date.now();
          taskInfo.status = QueueTaskStatus.RUNNING;
          return yield task();
        } finally {
          taskInfo.status = QueueTaskStatus.COMPLETED;
          this.pendingTasks.delete(taskInfo.id);
          unlock();
        }
      });
    }
    flush() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.run(() => __awaiter(this, void 0, void 0, function* () {
        }));
      });
    }
    snapshot() {
      return Array.from(this.pendingTasks.values());
    }
  };
  var passThroughQueueSignals = ["syncState", "trickle", "offer", "answer", "simulate", "leave"];
  function canPassThroughQueue(req) {
    const canPass = passThroughQueueSignals.indexOf(req.case) >= 0;
    livekitLogger.trace("request allowed to bypass queue:", {
      canPass,
      req
    });
    return canPass;
  }
  var SignalConnectionState;
  (function(SignalConnectionState2) {
    SignalConnectionState2[SignalConnectionState2["CONNECTING"] = 0] = "CONNECTING";
    SignalConnectionState2[SignalConnectionState2["CONNECTED"] = 1] = "CONNECTED";
    SignalConnectionState2[SignalConnectionState2["RECONNECTING"] = 2] = "RECONNECTING";
    SignalConnectionState2[SignalConnectionState2["DISCONNECTING"] = 3] = "DISCONNECTING";
    SignalConnectionState2[SignalConnectionState2["DISCONNECTED"] = 4] = "DISCONNECTED";
  })(SignalConnectionState || (SignalConnectionState = {}));
  var SignalClient = class {
    get currentState() {
      return this.state;
    }
    get isDisconnected() {
      return this.state === SignalConnectionState.DISCONNECTING || this.state === SignalConnectionState.DISCONNECTED;
    }
    get isEstablishingConnection() {
      return this.state === SignalConnectionState.CONNECTING || this.state === SignalConnectionState.RECONNECTING;
    }
    getNextRequestId() {
      this._requestId += 1;
      return this._requestId;
    }
    constructor() {
      let useJSON = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      let loggerOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var _a;
      this.rtt = 0;
      this.state = SignalConnectionState.DISCONNECTED;
      this.log = livekitLogger;
      this._requestId = 0;
      this.resetCallbacks = () => {
        this.onAnswer = void 0;
        this.onLeave = void 0;
        this.onLocalTrackPublished = void 0;
        this.onLocalTrackUnpublished = void 0;
        this.onNegotiateRequested = void 0;
        this.onOffer = void 0;
        this.onRemoteMuteChanged = void 0;
        this.onSubscribedQualityUpdate = void 0;
        this.onTokenRefresh = void 0;
        this.onTrickle = void 0;
        this.onClose = void 0;
      };
      this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Signal);
      this.loggerContextCb = loggerOptions.loggerContextCb;
      this.useJSON = useJSON;
      this.requestQueue = new AsyncQueue();
      this.queuedRequests = [];
      this.closingLock = new h();
      this.connectionLock = new h();
      this.state = SignalConnectionState.DISCONNECTED;
    }
    get logContext() {
      var _a, _b;
      return (_b = (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)) !== null && _b !== void 0 ? _b : {};
    }
    join(url2, token, opts, abortSignal) {
      return __awaiter(this, void 0, void 0, function* () {
        this.state = SignalConnectionState.CONNECTING;
        this.options = opts;
        const res = yield this.connect(url2, token, opts, abortSignal);
        return res;
      });
    }
    reconnect(url2, token, sid, reason) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.options) {
          this.log.warn("attempted to reconnect without signal options being set, ignoring", this.logContext);
          return;
        }
        this.state = SignalConnectionState.RECONNECTING;
        this.clearPingInterval();
        const res = yield this.connect(url2, token, Object.assign(Object.assign({}, this.options), {
          reconnect: true,
          sid,
          reconnectReason: reason
        }));
        return res;
      });
    }
    connect(url2, token, opts, abortSignal) {
      this.connectOptions = opts;
      url2 = toWebsocketUrl(url2);
      url2 = url2.replace(/\/$/, "");
      url2 += "/rtc";
      const clientInfo = getClientInfo();
      const params = createConnectionParams(token, clientInfo, opts);
      return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
        const unlock = yield this.connectionLock.lock();
        try {
          const abortHandler = () => __awaiter(this, void 0, void 0, function* () {
            this.close();
            clearTimeout(wsTimeout);
            reject(new ConnectionError("room connection has been cancelled (signal)", ConnectionErrorReason.Cancelled));
          });
          const wsTimeout = setTimeout(() => {
            this.close();
            reject(new ConnectionError("room connection has timed out (signal)", ConnectionErrorReason.ServerUnreachable));
          }, opts.websocketTimeout);
          if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
            abortHandler();
          }
          abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.addEventListener("abort", abortHandler);
          this.log.debug("connecting to ".concat(url2 + params), this.logContext);
          if (this.ws) {
            yield this.close(false);
          }
          this.ws = new WebSocket(url2 + params);
          this.ws.binaryType = "arraybuffer";
          this.ws.onopen = () => {
            clearTimeout(wsTimeout);
          };
          this.ws.onerror = (ev) => __awaiter(this, void 0, void 0, function* () {
            if (this.state !== SignalConnectionState.CONNECTED) {
              this.state = SignalConnectionState.DISCONNECTED;
              clearTimeout(wsTimeout);
              try {
                const resp = yield fetch("http".concat(url2.substring(2), "/validate").concat(params));
                if (resp.status.toFixed(0).startsWith("4")) {
                  const msg = yield resp.text();
                  reject(new ConnectionError(msg, ConnectionErrorReason.NotAllowed, resp.status));
                } else {
                  reject(new ConnectionError("Internal error", ConnectionErrorReason.InternalError, resp.status));
                }
              } catch (e) {
                reject(new ConnectionError("server was not reachable", ConnectionErrorReason.ServerUnreachable));
              }
              return;
            }
            this.handleWSError(ev);
          });
          this.ws.onmessage = (ev) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            let resp;
            if (typeof ev.data === "string") {
              const json = JSON.parse(ev.data);
              resp = SignalResponse.fromJson(json, {
                ignoreUnknownFields: true
              });
            } else if (ev.data instanceof ArrayBuffer) {
              resp = SignalResponse.fromBinary(new Uint8Array(ev.data));
            } else {
              this.log.error("could not decode websocket message: ".concat(typeof ev.data), this.logContext);
              return;
            }
            if (this.state !== SignalConnectionState.CONNECTED) {
              let shouldProcessMessage = false;
              if (((_a = resp.message) === null || _a === void 0 ? void 0 : _a.case) === "join") {
                this.state = SignalConnectionState.CONNECTED;
                abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener("abort", abortHandler);
                this.pingTimeoutDuration = resp.message.value.pingTimeout;
                this.pingIntervalDuration = resp.message.value.pingInterval;
                if (this.pingTimeoutDuration && this.pingTimeoutDuration > 0) {
                  this.log.debug("ping config", Object.assign(Object.assign({}, this.logContext), {
                    timeout: this.pingTimeoutDuration,
                    interval: this.pingIntervalDuration
                  }));
                  this.startPingInterval();
                }
                resolve(resp.message.value);
              } else if (this.state === SignalConnectionState.RECONNECTING && resp.message.case !== "leave") {
                this.state = SignalConnectionState.CONNECTED;
                abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener("abort", abortHandler);
                this.startPingInterval();
                if (((_b = resp.message) === null || _b === void 0 ? void 0 : _b.case) === "reconnect") {
                  resolve(resp.message.value);
                } else {
                  this.log.debug("declaring signal reconnected without reconnect response received", this.logContext);
                  resolve(void 0);
                  shouldProcessMessage = true;
                }
              } else if (this.isEstablishingConnection && resp.message.case === "leave") {
                reject(new ConnectionError("Received leave request while trying to (re)connect", ConnectionErrorReason.LeaveRequest, void 0, resp.message.value.reason));
              } else if (!opts.reconnect) {
                reject(new ConnectionError("did not receive join response, got ".concat((_c = resp.message) === null || _c === void 0 ? void 0 : _c.case, " instead"), ConnectionErrorReason.InternalError));
              }
              if (!shouldProcessMessage) {
                return;
              }
            }
            if (this.signalLatency) {
              yield sleep(this.signalLatency);
            }
            this.handleSignalResponse(resp);
          });
          this.ws.onclose = (ev) => {
            if (this.isEstablishingConnection) {
              reject(new ConnectionError("Websocket got closed during a (re)connection attempt", ConnectionErrorReason.InternalError));
            }
            this.log.warn("websocket closed", Object.assign(Object.assign({}, this.logContext), {
              reason: ev.reason,
              code: ev.code,
              wasClean: ev.wasClean,
              state: this.state
            }));
            this.handleOnClose(ev.reason);
          };
        } finally {
          unlock();
        }
      }));
    }
    close() {
      return __awaiter(this, arguments, void 0, function() {
        var _this = this;
        let updateState = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        return function* () {
          const unlock = yield _this.closingLock.lock();
          try {
            _this.clearPingInterval();
            if (updateState) {
              _this.state = SignalConnectionState.DISCONNECTING;
            }
            if (_this.ws) {
              _this.ws.onmessage = null;
              _this.ws.onopen = null;
              _this.ws.onclose = null;
              const closePromise = new Promise((resolve) => {
                if (_this.ws) {
                  _this.ws.onclose = () => {
                    resolve();
                  };
                } else {
                  resolve();
                }
              });
              if (_this.ws.readyState < _this.ws.CLOSING) {
                _this.ws.close();
                yield Promise.race([closePromise, sleep(250)]);
              }
              _this.ws = void 0;
            }
          } finally {
            if (updateState) {
              _this.state = SignalConnectionState.DISCONNECTED;
            }
            unlock();
          }
        }();
      });
    }
    // initial offer after joining
    sendOffer(offer) {
      this.log.debug("sending offer", Object.assign(Object.assign({}, this.logContext), {
        offerSdp: offer.sdp
      }));
      this.sendRequest({
        case: "offer",
        value: toProtoSessionDescription(offer)
      });
    }
    // answer a server-initiated offer
    sendAnswer(answer) {
      this.log.debug("sending answer", Object.assign(Object.assign({}, this.logContext), {
        answerSdp: answer.sdp
      }));
      return this.sendRequest({
        case: "answer",
        value: toProtoSessionDescription(answer)
      });
    }
    sendIceCandidate(candidate, target) {
      this.log.trace("sending ice candidate", Object.assign(Object.assign({}, this.logContext), {
        candidate
      }));
      return this.sendRequest({
        case: "trickle",
        value: new TrickleRequest({
          candidateInit: JSON.stringify(candidate),
          target
        })
      });
    }
    sendMuteTrack(trackSid, muted) {
      return this.sendRequest({
        case: "mute",
        value: new MuteTrackRequest({
          sid: trackSid,
          muted
        })
      });
    }
    sendAddTrack(req) {
      return this.sendRequest({
        case: "addTrack",
        value: req
      });
    }
    sendUpdateLocalMetadata(metadata_1, name_1) {
      return __awaiter(this, arguments, void 0, function(metadata, name) {
        var _this2 = this;
        let attributes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return function* () {
          const requestId = _this2.getNextRequestId();
          yield _this2.sendRequest({
            case: "updateMetadata",
            value: new UpdateParticipantMetadata({
              requestId,
              metadata,
              name,
              attributes
            })
          });
          return requestId;
        }();
      });
    }
    sendUpdateTrackSettings(settings) {
      this.sendRequest({
        case: "trackSetting",
        value: settings
      });
    }
    sendUpdateSubscription(sub) {
      return this.sendRequest({
        case: "subscription",
        value: sub
      });
    }
    sendSyncState(sync) {
      return this.sendRequest({
        case: "syncState",
        value: sync
      });
    }
    sendUpdateVideoLayers(trackSid, layers) {
      return this.sendRequest({
        case: "updateLayers",
        value: new UpdateVideoLayers({
          trackSid,
          layers
        })
      });
    }
    sendUpdateSubscriptionPermissions(allParticipants, trackPermissions) {
      return this.sendRequest({
        case: "subscriptionPermission",
        value: new SubscriptionPermission({
          allParticipants,
          trackPermissions
        })
      });
    }
    sendSimulateScenario(scenario) {
      return this.sendRequest({
        case: "simulate",
        value: scenario
      });
    }
    sendPing() {
      return Promise.all([this.sendRequest({
        case: "ping",
        value: protoInt64.parse(Date.now())
      }), this.sendRequest({
        case: "pingReq",
        value: new Ping({
          timestamp: protoInt64.parse(Date.now()),
          rtt: protoInt64.parse(this.rtt)
        })
      })]);
    }
    sendUpdateLocalAudioTrack(trackSid, features) {
      return this.sendRequest({
        case: "updateAudioTrack",
        value: new UpdateLocalAudioTrack({
          trackSid,
          features
        })
      });
    }
    sendLeave() {
      return this.sendRequest({
        case: "leave",
        value: new LeaveRequest({
          reason: DisconnectReason.CLIENT_INITIATED,
          // server doesn't process this field, keeping it here to indicate the intent of a full disconnect
          action: LeaveRequest_Action.DISCONNECT
        })
      });
    }
    sendRequest(message_1) {
      return __awaiter(this, arguments, void 0, function(message) {
        var _this3 = this;
        let fromQueue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        return function* () {
          const canQueue = !fromQueue && !canPassThroughQueue(message);
          if (canQueue && _this3.state === SignalConnectionState.RECONNECTING) {
            _this3.queuedRequests.push(() => __awaiter(_this3, void 0, void 0, function* () {
              yield this.sendRequest(message, true);
            }));
            return;
          }
          if (!fromQueue) {
            yield _this3.requestQueue.flush();
          }
          if (_this3.signalLatency) {
            yield sleep(_this3.signalLatency);
          }
          if (!_this3.ws || _this3.ws.readyState !== _this3.ws.OPEN) {
            _this3.log.error("cannot send signal request before connected, type: ".concat(message === null || message === void 0 ? void 0 : message.case), _this3.logContext);
            return;
          }
          const req = new SignalRequest({
            message
          });
          try {
            if (_this3.useJSON) {
              _this3.ws.send(req.toJsonString());
            } else {
              _this3.ws.send(req.toBinary());
            }
          } catch (e) {
            _this3.log.error("error sending signal message", Object.assign(Object.assign({}, _this3.logContext), {
              error: e
            }));
          }
        }();
      });
    }
    handleSignalResponse(res) {
      var _a, _b;
      const msg = res.message;
      if (msg == void 0) {
        this.log.debug("received unsupported message", this.logContext);
        return;
      }
      let pingHandled = false;
      if (msg.case === "answer") {
        const sd = fromProtoSessionDescription(msg.value);
        if (this.onAnswer) {
          this.onAnswer(sd);
        }
      } else if (msg.case === "offer") {
        const sd = fromProtoSessionDescription(msg.value);
        if (this.onOffer) {
          this.onOffer(sd);
        }
      } else if (msg.case === "trickle") {
        const candidate = JSON.parse(msg.value.candidateInit);
        if (this.onTrickle) {
          this.onTrickle(candidate, msg.value.target);
        }
      } else if (msg.case === "update") {
        if (this.onParticipantUpdate) {
          this.onParticipantUpdate((_a = msg.value.participants) !== null && _a !== void 0 ? _a : []);
        }
      } else if (msg.case === "trackPublished") {
        if (this.onLocalTrackPublished) {
          this.onLocalTrackPublished(msg.value);
        }
      } else if (msg.case === "speakersChanged") {
        if (this.onSpeakersChanged) {
          this.onSpeakersChanged((_b = msg.value.speakers) !== null && _b !== void 0 ? _b : []);
        }
      } else if (msg.case === "leave") {
        if (this.onLeave) {
          this.onLeave(msg.value);
        }
      } else if (msg.case === "mute") {
        if (this.onRemoteMuteChanged) {
          this.onRemoteMuteChanged(msg.value.sid, msg.value.muted);
        }
      } else if (msg.case === "roomUpdate") {
        if (this.onRoomUpdate && msg.value.room) {
          this.onRoomUpdate(msg.value.room);
        }
      } else if (msg.case === "connectionQuality") {
        if (this.onConnectionQuality) {
          this.onConnectionQuality(msg.value);
        }
      } else if (msg.case === "streamStateUpdate") {
        if (this.onStreamStateUpdate) {
          this.onStreamStateUpdate(msg.value);
        }
      } else if (msg.case === "subscribedQualityUpdate") {
        if (this.onSubscribedQualityUpdate) {
          this.onSubscribedQualityUpdate(msg.value);
        }
      } else if (msg.case === "subscriptionPermissionUpdate") {
        if (this.onSubscriptionPermissionUpdate) {
          this.onSubscriptionPermissionUpdate(msg.value);
        }
      } else if (msg.case === "refreshToken") {
        if (this.onTokenRefresh) {
          this.onTokenRefresh(msg.value);
        }
      } else if (msg.case === "trackUnpublished") {
        if (this.onLocalTrackUnpublished) {
          this.onLocalTrackUnpublished(msg.value);
        }
      } else if (msg.case === "subscriptionResponse") {
        if (this.onSubscriptionError) {
          this.onSubscriptionError(msg.value);
        }
      } else if (msg.case === "pong") ;
      else if (msg.case === "pongResp") {
        this.rtt = Date.now() - Number.parseInt(msg.value.lastPingTimestamp.toString());
        this.resetPingTimeout();
        pingHandled = true;
      } else if (msg.case === "requestResponse") {
        if (this.onRequestResponse) {
          this.onRequestResponse(msg.value);
        }
      } else if (msg.case === "trackSubscribed") {
        if (this.onLocalTrackSubscribed) {
          this.onLocalTrackSubscribed(msg.value.trackSid);
        }
      } else {
        this.log.debug("unsupported message", Object.assign(Object.assign({}, this.logContext), {
          msgCase: msg.case
        }));
      }
      if (!pingHandled) {
        this.resetPingTimeout();
      }
    }
    setReconnected() {
      while (this.queuedRequests.length > 0) {
        const req = this.queuedRequests.shift();
        if (req) {
          this.requestQueue.run(req);
        }
      }
    }
    handleOnClose(reason) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.state === SignalConnectionState.DISCONNECTED) return;
        const onCloseCallback = this.onClose;
        yield this.close();
        this.log.debug("websocket connection closed: ".concat(reason), Object.assign(Object.assign({}, this.logContext), {
          reason
        }));
        if (onCloseCallback) {
          onCloseCallback(reason);
        }
      });
    }
    handleWSError(ev) {
      this.log.error("websocket error", Object.assign(Object.assign({}, this.logContext), {
        error: ev
      }));
    }
    /**
     * Resets the ping timeout and starts a new timeout.
     * Call this after receiving a pong message
     */
    resetPingTimeout() {
      this.clearPingTimeout();
      if (!this.pingTimeoutDuration) {
        this.log.warn("ping timeout duration not set", this.logContext);
        return;
      }
      this.pingTimeout = CriticalTimers.setTimeout(() => {
        this.log.warn("ping timeout triggered. last pong received at: ".concat(new Date(Date.now() - this.pingTimeoutDuration * 1e3).toUTCString()), this.logContext);
        this.handleOnClose("ping timeout");
      }, this.pingTimeoutDuration * 1e3);
    }
    /**
     * Clears ping timeout (does not start a new timeout)
     */
    clearPingTimeout() {
      if (this.pingTimeout) {
        CriticalTimers.clearTimeout(this.pingTimeout);
      }
    }
    startPingInterval() {
      this.clearPingInterval();
      this.resetPingTimeout();
      if (!this.pingIntervalDuration) {
        this.log.warn("ping interval duration not set", this.logContext);
        return;
      }
      this.log.debug("start ping interval", this.logContext);
      this.pingInterval = CriticalTimers.setInterval(() => {
        this.sendPing();
      }, this.pingIntervalDuration * 1e3);
    }
    clearPingInterval() {
      this.log.debug("clearing ping interval", this.logContext);
      this.clearPingTimeout();
      if (this.pingInterval) {
        CriticalTimers.clearInterval(this.pingInterval);
      }
    }
  };
  function fromProtoSessionDescription(sd) {
    const rsd = {
      type: "offer",
      sdp: sd.sdp
    };
    switch (sd.type) {
      case "answer":
      case "offer":
      case "pranswer":
      case "rollback":
        rsd.type = sd.type;
        break;
    }
    return rsd;
  }
  function toProtoSessionDescription(rsd) {
    const sd = new SessionDescription({
      sdp: rsd.sdp,
      type: rsd.type
    });
    return sd;
  }
  function createConnectionParams(token, info, opts) {
    var _a;
    const params = new URLSearchParams();
    params.set("access_token", token);
    if (opts.reconnect) {
      params.set("reconnect", "1");
      if (opts.sid) {
        params.set("sid", opts.sid);
      }
    }
    params.set("auto_subscribe", opts.autoSubscribe ? "1" : "0");
    params.set("sdk", isReactNative() ? "reactnative" : "js");
    params.set("version", info.version);
    params.set("protocol", info.protocol.toString());
    if (info.deviceModel) {
      params.set("device_model", info.deviceModel);
    }
    if (info.os) {
      params.set("os", info.os);
    }
    if (info.osVersion) {
      params.set("os_version", info.osVersion);
    }
    if (info.browser) {
      params.set("browser", info.browser);
    }
    if (info.browserVersion) {
      params.set("browser_version", info.browserVersion);
    }
    if (opts.adaptiveStream) {
      params.set("adaptive_stream", "1");
    }
    if (opts.reconnectReason) {
      params.set("reconnect_reason", opts.reconnectReason.toString());
    }
    if ((_a = navigator.connection) === null || _a === void 0 ? void 0 : _a.type) {
      params.set("network", navigator.connection.type);
    }
    return "?".concat(params.toString());
  }
  var lib = {};
  var parser = {};
  var grammar = { exports: {} };
  var hasRequiredGrammar;
  function requireGrammar() {
    if (hasRequiredGrammar) return grammar.exports;
    hasRequiredGrammar = 1;
    var grammar$1 = grammar.exports = {
      v: [{
        name: "version",
        reg: /^(\d*)$/
      }],
      o: [{
        // o=- 20518 0 IN IP4 203.0.113.1
        // NB: sessionId will be a String in most cases because it is huge
        name: "origin",
        reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
        names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
        format: "%s %s %d %s IP%d %s"
      }],
      // default parsing of these only (though some of these feel outdated)
      s: [{
        name: "name"
      }],
      i: [{
        name: "description"
      }],
      u: [{
        name: "uri"
      }],
      e: [{
        name: "email"
      }],
      p: [{
        name: "phone"
      }],
      z: [{
        name: "timezones"
      }],
      // TODO: this one can actually be parsed properly...
      r: [{
        name: "repeats"
      }],
      // TODO: this one can also be parsed properly
      // k: [{}], // outdated thing ignored
      t: [{
        // t=0 0
        name: "timing",
        reg: /^(\d*) (\d*)/,
        names: ["start", "stop"],
        format: "%d %d"
      }],
      c: [{
        // c=IN IP4 10.47.197.26
        name: "connection",
        reg: /^IN IP(\d) (\S*)/,
        names: ["version", "ip"],
        format: "IN IP%d %s"
      }],
      b: [{
        // b=AS:4000
        push: "bandwidth",
        reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
        names: ["type", "limit"],
        format: "%s:%s"
      }],
      m: [{
        // m=video 51744 RTP/AVP 126 97 98 34 31
        // NB: special - pushes to session
        // TODO: rtp/fmtp should be filtered by the payloads found here?
        reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
        names: ["type", "port", "protocol", "payloads"],
        format: "%s %d %s %s"
      }],
      a: [
        {
          // a=rtpmap:110 opus/48000/2
          push: "rtp",
          reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
          names: ["payload", "codec", "rate", "encoding"],
          format: function(o) {
            return o.encoding ? "rtpmap:%d %s/%s/%s" : o.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
          }
        },
        {
          // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
          // a=fmtp:111 minptime=10; useinbandfec=1
          push: "fmtp",
          reg: /^fmtp:(\d*) ([\S| ]*)/,
          names: ["payload", "config"],
          format: "fmtp:%d %s"
        },
        {
          // a=control:streamid=0
          name: "control",
          reg: /^control:(.*)/,
          format: "control:%s"
        },
        {
          // a=rtcp:65179 IN IP4 193.84.77.194
          name: "rtcp",
          reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
          names: ["port", "netType", "ipVer", "address"],
          format: function(o) {
            return o.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
          }
        },
        {
          // a=rtcp-fb:98 trr-int 100
          push: "rtcpFbTrrInt",
          reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
          names: ["payload", "value"],
          format: "rtcp-fb:%s trr-int %d"
        },
        {
          // a=rtcp-fb:98 nack rpsi
          push: "rtcpFb",
          reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
          names: ["payload", "type", "subtype"],
          format: function(o) {
            return o.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
          }
        },
        {
          // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
          // a=extmap:1/recvonly URI-gps-string
          // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
          push: "ext",
          reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
          names: ["value", "direction", "encrypt-uri", "uri", "config"],
          format: function(o) {
            return "extmap:%d" + (o.direction ? "/%s" : "%v") + (o["encrypt-uri"] ? " %s" : "%v") + " %s" + (o.config ? " %s" : "");
          }
        },
        {
          // a=extmap-allow-mixed
          name: "extmapAllowMixed",
          reg: /^(extmap-allow-mixed)/
        },
        {
          // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
          push: "crypto",
          reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
          names: ["id", "suite", "config", "sessionConfig"],
          format: function(o) {
            return o.sessionConfig != null ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
          }
        },
        {
          // a=setup:actpass
          name: "setup",
          reg: /^setup:(\w*)/,
          format: "setup:%s"
        },
        {
          // a=connection:new
          name: "connectionType",
          reg: /^connection:(new|existing)/,
          format: "connection:%s"
        },
        {
          // a=mid:1
          name: "mid",
          reg: /^mid:([^\s]*)/,
          format: "mid:%s"
        },
        {
          // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
          name: "msid",
          reg: /^msid:(.*)/,
          format: "msid:%s"
        },
        {
          // a=ptime:20
          name: "ptime",
          reg: /^ptime:(\d*(?:\.\d*)*)/,
          format: "ptime:%d"
        },
        {
          // a=maxptime:60
          name: "maxptime",
          reg: /^maxptime:(\d*(?:\.\d*)*)/,
          format: "maxptime:%d"
        },
        {
          // a=sendrecv
          name: "direction",
          reg: /^(sendrecv|recvonly|sendonly|inactive)/
        },
        {
          // a=ice-lite
          name: "icelite",
          reg: /^(ice-lite)/
        },
        {
          // a=ice-ufrag:F7gI
          name: "iceUfrag",
          reg: /^ice-ufrag:(\S*)/,
          format: "ice-ufrag:%s"
        },
        {
          // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
          name: "icePwd",
          reg: /^ice-pwd:(\S*)/,
          format: "ice-pwd:%s"
        },
        {
          // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
          name: "fingerprint",
          reg: /^fingerprint:(\S*) (\S*)/,
          names: ["type", "hash"],
          format: "fingerprint:%s %s"
        },
        {
          // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
          // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
          // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
          // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
          // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
          push: "candidates",
          reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
          names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
          format: function(o) {
            var str = "candidate:%s %d %s %d %s %d typ %s";
            str += o.raddr != null ? " raddr %s rport %d" : "%v%v";
            str += o.tcptype != null ? " tcptype %s" : "%v";
            if (o.generation != null) {
              str += " generation %d";
            }
            str += o["network-id"] != null ? " network-id %d" : "%v";
            str += o["network-cost"] != null ? " network-cost %d" : "%v";
            return str;
          }
        },
        {
          // a=end-of-candidates (keep after the candidates line for readability)
          name: "endOfCandidates",
          reg: /^(end-of-candidates)/
        },
        {
          // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
          name: "remoteCandidates",
          reg: /^remote-candidates:(.*)/,
          format: "remote-candidates:%s"
        },
        {
          // a=ice-options:google-ice
          name: "iceOptions",
          reg: /^ice-options:(\S*)/,
          format: "ice-options:%s"
        },
        {
          // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
          push: "ssrcs",
          reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
          names: ["id", "attribute", "value"],
          format: function(o) {
            var str = "ssrc:%d";
            if (o.attribute != null) {
              str += " %s";
              if (o.value != null) {
                str += ":%s";
              }
            }
            return str;
          }
        },
        {
          // a=ssrc-group:FEC 1 2
          // a=ssrc-group:FEC-FR 3004364195 1080772241
          push: "ssrcGroups",
          // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
          reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
          names: ["semantics", "ssrcs"],
          format: "ssrc-group:%s %s"
        },
        {
          // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
          name: "msidSemantic",
          reg: /^msid-semantic:\s?(\w*) (\S*)/,
          names: ["semantic", "token"],
          format: "msid-semantic: %s %s"
          // space after ':' is not accidental
        },
        {
          // a=group:BUNDLE audio video
          push: "groups",
          reg: /^group:(\w*) (.*)/,
          names: ["type", "mids"],
          format: "group:%s %s"
        },
        {
          // a=rtcp-mux
          name: "rtcpMux",
          reg: /^(rtcp-mux)/
        },
        {
          // a=rtcp-rsize
          name: "rtcpRsize",
          reg: /^(rtcp-rsize)/
        },
        {
          // a=sctpmap:5000 webrtc-datachannel 1024
          name: "sctpmap",
          reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
          names: ["sctpmapNumber", "app", "maxMessageSize"],
          format: function(o) {
            return o.maxMessageSize != null ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
          }
        },
        {
          // a=x-google-flag:conference
          name: "xGoogleFlag",
          reg: /^x-google-flag:([^\s]*)/,
          format: "x-google-flag:%s"
        },
        {
          // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
          push: "rids",
          reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
          names: ["id", "direction", "params"],
          format: function(o) {
            return o.params ? "rid:%s %s %s" : "rid:%s %s";
          }
        },
        {
          // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
          // a=imageattr:* send [x=800,y=640] recv *
          // a=imageattr:100 recv [x=320,y=240]
          push: "imageattrs",
          reg: new RegExp(
            // a=imageattr:97
            "^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"
          ),
          names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
          format: function(o) {
            return "imageattr:%s %s %s" + (o.dir2 ? " %s %s" : "");
          }
        },
        {
          // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
          // a=simulcast:recv 1;4,5 send 6;7
          name: "simulcast",
          reg: new RegExp(
            // a=simulcast:
            "^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"
          ),
          names: ["dir1", "list1", "dir2", "list2"],
          format: function(o) {
            return "simulcast:%s %s" + (o.dir2 ? " %s %s" : "");
          }
        },
        {
          // old simulcast draft 03 (implemented by Firefox)
          //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
          // a=simulcast: recv pt=97;98 send pt=97
          // a=simulcast: send rid=5;6;7 paused=6,7
          name: "simulcast_03",
          reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
          names: ["value"],
          format: "simulcast: %s"
        },
        {
          // a=framerate:25
          // a=framerate:29.97
          name: "framerate",
          reg: /^framerate:(\d+(?:$|\.\d+))/,
          format: "framerate:%s"
        },
        {
          // RFC4570
          // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
          name: "sourceFilter",
          reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
          names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
          format: "source-filter: %s %s %s %s %s"
        },
        {
          // a=bundle-only
          name: "bundleOnly",
          reg: /^(bundle-only)/
        },
        {
          // a=label:1
          name: "label",
          reg: /^label:(.+)/,
          format: "label:%s"
        },
        {
          // RFC version 26 for SCTP over DTLS
          // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
          name: "sctpPort",
          reg: /^sctp-port:(\d+)$/,
          format: "sctp-port:%s"
        },
        {
          // RFC version 26 for SCTP over DTLS
          // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
          name: "maxMessageSize",
          reg: /^max-message-size:(\d+)$/,
          format: "max-message-size:%s"
        },
        {
          // RFC7273
          // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
          push: "tsRefClocks",
          reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
          names: ["clksrc", "clksrcExt"],
          format: function(o) {
            return "ts-refclk:%s" + (o.clksrcExt != null ? "=%s" : "");
          }
        },
        {
          // RFC7273
          // a=mediaclk:direct=963214424
          name: "mediaClk",
          reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
          names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
          format: function(o) {
            var str = "mediaclk:";
            str += o.id != null ? "id=%s %s" : "%v%s";
            str += o.mediaClockValue != null ? "=%s" : "";
            str += o.rateNumerator != null ? " rate=%s" : "";
            str += o.rateDenominator != null ? "/%s" : "";
            return str;
          }
        },
        {
          // a=keywds:keywords
          name: "keywords",
          reg: /^keywds:(.+)$/,
          format: "keywds:%s"
        },
        {
          // a=content:main
          name: "content",
          reg: /^content:(.+)/,
          format: "content:%s"
        },
        // BFCP https://tools.ietf.org/html/rfc4583
        {
          // a=floorctrl:c-s
          name: "bfcpFloorCtrl",
          reg: /^floorctrl:(c-only|s-only|c-s)/,
          format: "floorctrl:%s"
        },
        {
          // a=confid:1
          name: "bfcpConfId",
          reg: /^confid:(\d+)/,
          format: "confid:%s"
        },
        {
          // a=userid:1
          name: "bfcpUserId",
          reg: /^userid:(\d+)/,
          format: "userid:%s"
        },
        {
          // a=floorid:1
          name: "bfcpFloorId",
          reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
          names: ["id", "mStream"],
          format: "floorid:%s mstrm:%s"
        },
        {
          // any a= that we don't understand is kept verbatim on media.invalid
          push: "invalid",
          names: ["value"]
        }
      ]
    };
    Object.keys(grammar$1).forEach(function(key) {
      var objs = grammar$1[key];
      objs.forEach(function(obj) {
        if (!obj.reg) {
          obj.reg = /(.*)/;
        }
        if (!obj.format) {
          obj.format = "%s";
        }
      });
    });
    return grammar.exports;
  }
  var hasRequiredParser;
  function requireParser() {
    if (hasRequiredParser) return parser;
    hasRequiredParser = 1;
    (function(exports) {
      var toIntIfInt = function(v) {
        return String(Number(v)) === v ? Number(v) : v;
      };
      var attachProperties = function(match, location, names, rawName) {
        if (rawName && !names) {
          location[rawName] = toIntIfInt(match[1]);
        } else {
          for (var i = 0; i < names.length; i += 1) {
            if (match[i + 1] != null) {
              location[names[i]] = toIntIfInt(match[i + 1]);
            }
          }
        }
      };
      var parseReg = function(obj, location, content) {
        var needsBlank = obj.name && obj.names;
        if (obj.push && !location[obj.push]) {
          location[obj.push] = [];
        } else if (needsBlank && !location[obj.name]) {
          location[obj.name] = {};
        }
        var keyLocation = obj.push ? {} : (
          // blank object that will be pushed
          needsBlank ? location[obj.name] : location
        );
        attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
        if (obj.push) {
          location[obj.push].push(keyLocation);
        }
      };
      var grammar2 = requireGrammar();
      var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
      exports.parse = function(sdp2) {
        var session = {}, media = [], location = session;
        sdp2.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function(l2) {
          var type = l2[0];
          var content = l2.slice(2);
          if (type === "m") {
            media.push({
              rtp: [],
              fmtp: []
            });
            location = media[media.length - 1];
          }
          for (var j = 0; j < (grammar2[type] || []).length; j += 1) {
            var obj = grammar2[type][j];
            if (obj.reg.test(content)) {
              return parseReg(obj, location, content);
            }
          }
        });
        session.media = media;
        return session;
      };
      var paramReducer = function(acc, expr) {
        var s = expr.split(/=(.+)/, 2);
        if (s.length === 2) {
          acc[s[0]] = toIntIfInt(s[1]);
        } else if (s.length === 1 && expr.length > 1) {
          acc[s[0]] = void 0;
        }
        return acc;
      };
      exports.parseParams = function(str) {
        return str.split(/;\s?/).reduce(paramReducer, {});
      };
      exports.parseFmtpConfig = exports.parseParams;
      exports.parsePayloads = function(str) {
        return str.toString().split(" ").map(Number);
      };
      exports.parseRemoteCandidates = function(str) {
        var candidates = [];
        var parts = str.split(" ").map(toIntIfInt);
        for (var i = 0; i < parts.length; i += 3) {
          candidates.push({
            component: parts[i],
            ip: parts[i + 1],
            port: parts[i + 2]
          });
        }
        return candidates;
      };
      exports.parseImageAttributes = function(str) {
        return str.split(" ").map(function(item) {
          return item.substring(1, item.length - 1).split(",").reduce(paramReducer, {});
        });
      };
      exports.parseSimulcastStreamList = function(str) {
        return str.split(";").map(function(stream4) {
          return stream4.split(",").map(function(format) {
            var scid, paused = false;
            if (format[0] !== "~") {
              scid = toIntIfInt(format);
            } else {
              scid = toIntIfInt(format.substring(1, format.length));
              paused = true;
            }
            return {
              scid,
              paused
            };
          });
        });
      };
    })(parser);
    return parser;
  }
  var writer;
  var hasRequiredWriter;
  function requireWriter() {
    if (hasRequiredWriter) return writer;
    hasRequiredWriter = 1;
    var grammar2 = requireGrammar();
    var formatRegExp = /%[sdv%]/g;
    var format = function(formatStr) {
      var i = 1;
      var args = arguments;
      var len = args.length;
      return formatStr.replace(formatRegExp, function(x) {
        if (i >= len) {
          return x;
        }
        var arg = args[i];
        i += 1;
        switch (x) {
          case "%%":
            return "%";
          case "%s":
            return String(arg);
          case "%d":
            return Number(arg);
          case "%v":
            return "";
        }
      });
    };
    var makeLine = function(type, obj, location) {
      var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;
      var args = [type + "=" + str];
      if (obj.names) {
        for (var i = 0; i < obj.names.length; i += 1) {
          var n2 = obj.names[i];
          if (obj.name) {
            args.push(location[obj.name][n2]);
          } else {
            args.push(location[obj.names[i]]);
          }
        }
      } else {
        args.push(location[obj.name]);
      }
      return format.apply(null, args);
    };
    var defaultOuterOrder = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"];
    var defaultInnerOrder = ["i", "c", "b", "a"];
    writer = function(session, opts) {
      opts = opts || {};
      if (session.version == null) {
        session.version = 0;
      }
      if (session.name == null) {
        session.name = " ";
      }
      session.media.forEach(function(mLine) {
        if (mLine.payloads == null) {
          mLine.payloads = "";
        }
      });
      var outerOrder = opts.outerOrder || defaultOuterOrder;
      var innerOrder = opts.innerOrder || defaultInnerOrder;
      var sdp2 = [];
      outerOrder.forEach(function(type) {
        grammar2[type].forEach(function(obj) {
          if (obj.name in session && session[obj.name] != null) {
            sdp2.push(makeLine(type, obj, session));
          } else if (obj.push in session && session[obj.push] != null) {
            session[obj.push].forEach(function(el) {
              sdp2.push(makeLine(type, obj, el));
            });
          }
        });
      });
      session.media.forEach(function(mLine) {
        sdp2.push(makeLine("m", grammar2.m[0], mLine));
        innerOrder.forEach(function(type) {
          grammar2[type].forEach(function(obj) {
            if (obj.name in mLine && mLine[obj.name] != null) {
              sdp2.push(makeLine(type, obj, mLine));
            } else if (obj.push in mLine && mLine[obj.push] != null) {
              mLine[obj.push].forEach(function(el) {
                sdp2.push(makeLine(type, obj, el));
              });
            }
          });
        });
      });
      return sdp2.join("\r\n") + "\r\n";
    };
    return writer;
  }
  var hasRequiredLib;
  function requireLib() {
    if (hasRequiredLib) return lib;
    hasRequiredLib = 1;
    var parser2 = requireParser();
    var writer2 = requireWriter();
    lib.write = writer2;
    lib.parse = parser2.parse;
    lib.parseParams = parser2.parseParams;
    lib.parseFmtpConfig = parser2.parseFmtpConfig;
    lib.parsePayloads = parser2.parsePayloads;
    lib.parseRemoteCandidates = parser2.parseRemoteCandidates;
    lib.parseImageAttributes = parser2.parseImageAttributes;
    lib.parseSimulcastStreamList = parser2.parseSimulcastStreamList;
    return lib;
  }
  var libExports = requireLib();
  var startBitrateForSVC = 0.7;
  var debounceInterval = 20;
  var PCEvents = {
    NegotiationStarted: "negotiationStarted",
    NegotiationComplete: "negotiationComplete",
    RTPVideoPayloadTypes: "rtpVideoPayloadTypes"
  };
  var PCTransport = class extends eventsExports.EventEmitter {
    get pc() {
      if (!this._pc) {
        this._pc = this.createPC();
      }
      return this._pc;
    }
    constructor(config) {
      let loggerOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var _a;
      super();
      this.log = livekitLogger;
      this.ddExtID = 0;
      this.pendingCandidates = [];
      this.restartingIce = false;
      this.renegotiate = false;
      this.trackBitrates = [];
      this.remoteStereoMids = [];
      this.remoteNackMids = [];
      this.negotiate = r((onError) => __awaiter(this, void 0, void 0, function* () {
        this.emit(PCEvents.NegotiationStarted);
        try {
          yield this.createAndSendOffer();
        } catch (e) {
          if (onError) {
            onError(e);
          } else {
            throw e;
          }
        }
      }), debounceInterval);
      this.close = () => {
        if (!this._pc) {
          return;
        }
        this._pc.close();
        this._pc.onconnectionstatechange = null;
        this._pc.oniceconnectionstatechange = null;
        this._pc.onicegatheringstatechange = null;
        this._pc.ondatachannel = null;
        this._pc.onnegotiationneeded = null;
        this._pc.onsignalingstatechange = null;
        this._pc.onicecandidate = null;
        this._pc.ondatachannel = null;
        this._pc.ontrack = null;
        this._pc.onconnectionstatechange = null;
        this._pc.oniceconnectionstatechange = null;
        this._pc = null;
      };
      this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCTransport);
      this.loggerOptions = loggerOptions;
      this.config = config;
      this._pc = this.createPC();
    }
    createPC() {
      const pc = new RTCPeerConnection(this.config);
      pc.onicecandidate = (ev) => {
        var _a;
        if (!ev.candidate) return;
        (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, ev.candidate);
      };
      pc.onicecandidateerror = (ev) => {
        var _a;
        (_a = this.onIceCandidateError) === null || _a === void 0 ? void 0 : _a.call(this, ev);
      };
      pc.oniceconnectionstatechange = () => {
        var _a;
        (_a = this.onIceConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.iceConnectionState);
      };
      pc.onsignalingstatechange = () => {
        var _a;
        (_a = this.onSignalingStatechange) === null || _a === void 0 ? void 0 : _a.call(this, pc.signalingState);
      };
      pc.onconnectionstatechange = () => {
        var _a;
        (_a = this.onConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.connectionState);
      };
      pc.ondatachannel = (ev) => {
        var _a;
        (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);
      };
      pc.ontrack = (ev) => {
        var _a;
        (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);
      };
      return pc;
    }
    get logContext() {
      var _a, _b;
      return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));
    }
    get isICEConnected() {
      return this._pc !== null && (this.pc.iceConnectionState === "connected" || this.pc.iceConnectionState === "completed");
    }
    addIceCandidate(candidate) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.pc.remoteDescription && !this.restartingIce) {
          return this.pc.addIceCandidate(candidate);
        }
        this.pendingCandidates.push(candidate);
      });
    }
    setRemoteDescription(sd) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        let mungedSDP = void 0;
        if (sd.type === "offer") {
          let {
            stereoMids,
            nackMids
          } = extractStereoAndNackAudioFromOffer(sd);
          this.remoteStereoMids = stereoMids;
          this.remoteNackMids = nackMids;
        } else if (sd.type === "answer") {
          const sdpParsed = libExports.parse((_a = sd.sdp) !== null && _a !== void 0 ? _a : "");
          sdpParsed.media.forEach((media) => {
            if (media.type === "audio") {
              this.trackBitrates.some((trackbr) => {
                if (!trackbr.transceiver || media.mid != trackbr.transceiver.mid) {
                  return false;
                }
                let codecPayload = 0;
                media.rtp.some((rtp) => {
                  if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {
                    codecPayload = rtp.payload;
                    return true;
                  }
                  return false;
                });
                if (codecPayload === 0) {
                  return true;
                }
                let fmtpFound = false;
                for (const fmtp of media.fmtp) {
                  if (fmtp.payload === codecPayload) {
                    fmtp.config = fmtp.config.split(";").filter((attr) => !attr.includes("maxaveragebitrate")).join(";");
                    if (trackbr.maxbr > 0) {
                      fmtp.config += ";maxaveragebitrate=".concat(trackbr.maxbr * 1e3);
                    }
                    fmtpFound = true;
                    break;
                  }
                }
                if (!fmtpFound) {
                  if (trackbr.maxbr > 0) {
                    media.fmtp.push({
                      payload: codecPayload,
                      config: "maxaveragebitrate=".concat(trackbr.maxbr * 1e3)
                    });
                  }
                }
                return true;
              });
            }
          });
          mungedSDP = libExports.write(sdpParsed);
        }
        yield this.setMungedSDP(sd, mungedSDP, true);
        this.pendingCandidates.forEach((candidate) => {
          this.pc.addIceCandidate(candidate);
        });
        this.pendingCandidates = [];
        this.restartingIce = false;
        if (this.renegotiate) {
          this.renegotiate = false;
          yield this.createAndSendOffer();
        } else if (sd.type === "answer") {
          this.emit(PCEvents.NegotiationComplete);
          if (sd.sdp) {
            const sdpParsed = libExports.parse(sd.sdp);
            sdpParsed.media.forEach((media) => {
              if (media.type === "video") {
                this.emit(PCEvents.RTPVideoPayloadTypes, media.rtp);
              }
            });
          }
        }
      });
    }
    createAndSendOffer(options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (this.onOffer === void 0) {
          return;
        }
        if (options === null || options === void 0 ? void 0 : options.iceRestart) {
          this.log.debug("restarting ICE", this.logContext);
          this.restartingIce = true;
        }
        if (this._pc && this._pc.signalingState === "have-local-offer") {
          const currentSD = this._pc.remoteDescription;
          if ((options === null || options === void 0 ? void 0 : options.iceRestart) && currentSD) {
            yield this._pc.setRemoteDescription(currentSD);
          } else {
            this.renegotiate = true;
            return;
          }
        } else if (!this._pc || this._pc.signalingState === "closed") {
          this.log.warn("could not createOffer with closed peer connection", this.logContext);
          return;
        }
        this.log.debug("starting to negotiate", this.logContext);
        const offer = yield this.pc.createOffer(options);
        this.log.debug("original offer", Object.assign({
          sdp: offer.sdp
        }, this.logContext));
        const sdpParsed = libExports.parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : "");
        sdpParsed.media.forEach((media) => {
          ensureIPAddrMatchVersion(media);
          if (media.type === "audio") {
            ensureAudioNackAndStereo(media, [], []);
          } else if (media.type === "video") {
            this.trackBitrates.some((trackbr) => {
              if (!media.msid || !trackbr.cid || !media.msid.includes(trackbr.cid)) {
                return false;
              }
              let codecPayload = 0;
              media.rtp.some((rtp) => {
                if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {
                  codecPayload = rtp.payload;
                  return true;
                }
                return false;
              });
              if (codecPayload === 0) {
                return true;
              }
              if (isSVCCodec(trackbr.codec)) {
                this.ensureVideoDDExtensionForSVC(media, sdpParsed);
              }
              if (trackbr.codec !== "av1") {
                return true;
              }
              const startBitrate = Math.round(trackbr.maxbr * startBitrateForSVC);
              for (const fmtp of media.fmtp) {
                if (fmtp.payload === codecPayload) {
                  if (!fmtp.config.includes("x-google-start-bitrate")) {
                    fmtp.config += ";x-google-start-bitrate=".concat(startBitrate);
                  }
                  break;
                }
              }
              return true;
            });
          }
        });
        yield this.setMungedSDP(offer, libExports.write(sdpParsed));
        this.onOffer(offer);
      });
    }
    createAndSetAnswer() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const answer = yield this.pc.createAnswer();
        const sdpParsed = libExports.parse((_a = answer.sdp) !== null && _a !== void 0 ? _a : "");
        sdpParsed.media.forEach((media) => {
          ensureIPAddrMatchVersion(media);
          if (media.type === "audio") {
            ensureAudioNackAndStereo(media, this.remoteStereoMids, this.remoteNackMids);
          }
        });
        yield this.setMungedSDP(answer, libExports.write(sdpParsed));
        return answer;
      });
    }
    createDataChannel(label, dataChannelDict) {
      return this.pc.createDataChannel(label, dataChannelDict);
    }
    addTransceiver(mediaStreamTrack, transceiverInit) {
      return this.pc.addTransceiver(mediaStreamTrack, transceiverInit);
    }
    addTrack(track) {
      if (!this._pc) {
        throw new UnexpectedConnectionState("PC closed, cannot add track");
      }
      return this._pc.addTrack(track);
    }
    setTrackCodecBitrate(info) {
      this.trackBitrates.push(info);
    }
    setConfiguration(rtcConfig) {
      var _a;
      if (!this._pc) {
        throw new UnexpectedConnectionState("PC closed, cannot configure");
      }
      return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.setConfiguration(rtcConfig);
    }
    canRemoveTrack() {
      var _a;
      return !!((_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack);
    }
    removeTrack(sender) {
      var _a;
      return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack(sender);
    }
    getConnectionState() {
      var _a, _b;
      return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.connectionState) !== null && _b !== void 0 ? _b : "closed";
    }
    getICEConnectionState() {
      var _a, _b;
      return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.iceConnectionState) !== null && _b !== void 0 ? _b : "closed";
    }
    getSignallingState() {
      var _a, _b;
      return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.signalingState) !== null && _b !== void 0 ? _b : "closed";
    }
    getTransceivers() {
      var _a, _b;
      return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : [];
    }
    getSenders() {
      var _a, _b;
      return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getSenders()) !== null && _b !== void 0 ? _b : [];
    }
    getLocalDescription() {
      var _a;
      return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.localDescription;
    }
    getRemoteDescription() {
      var _a;
      return (_a = this.pc) === null || _a === void 0 ? void 0 : _a.remoteDescription;
    }
    getStats() {
      return this.pc.getStats();
    }
    getConnectedAddress() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!this._pc) {
          return;
        }
        let selectedCandidatePairId = "";
        const candidatePairs = /* @__PURE__ */ new Map();
        const candidates = /* @__PURE__ */ new Map();
        const stats = yield this._pc.getStats();
        stats.forEach((v) => {
          switch (v.type) {
            case "transport":
              selectedCandidatePairId = v.selectedCandidatePairId;
              break;
            case "candidate-pair":
              if (selectedCandidatePairId === "" && v.selected) {
                selectedCandidatePairId = v.id;
              }
              candidatePairs.set(v.id, v);
              break;
            case "remote-candidate":
              candidates.set(v.id, "".concat(v.address, ":").concat(v.port));
              break;
          }
        });
        if (selectedCandidatePairId === "") {
          return void 0;
        }
        const selectedID = (_a = candidatePairs.get(selectedCandidatePairId)) === null || _a === void 0 ? void 0 : _a.remoteCandidateId;
        if (selectedID === void 0) {
          return void 0;
        }
        return candidates.get(selectedID);
      });
    }
    setMungedSDP(sd, munged, remote) {
      return __awaiter(this, void 0, void 0, function* () {
        if (munged) {
          const originalSdp = sd.sdp;
          sd.sdp = munged;
          try {
            this.log.debug("setting munged ".concat(remote ? "remote" : "local", " description"), this.logContext);
            if (remote) {
              yield this.pc.setRemoteDescription(sd);
            } else {
              yield this.pc.setLocalDescription(sd);
            }
            return;
          } catch (e) {
            this.log.warn("not able to set ".concat(sd.type, ", falling back to unmodified sdp"), Object.assign(Object.assign({}, this.logContext), {
              error: e,
              sdp: munged
            }));
            sd.sdp = originalSdp;
          }
        }
        try {
          if (remote) {
            yield this.pc.setRemoteDescription(sd);
          } else {
            yield this.pc.setLocalDescription(sd);
          }
        } catch (e) {
          let msg = "unknown error";
          if (e instanceof Error) {
            msg = e.message;
          } else if (typeof e === "string") {
            msg = e;
          }
          const fields = {
            error: msg,
            sdp: sd.sdp
          };
          if (!remote && this.pc.remoteDescription) {
            fields.remoteSdp = this.pc.remoteDescription;
          }
          this.log.error("unable to set ".concat(sd.type), Object.assign(Object.assign({}, this.logContext), {
            fields
          }));
          throw new NegotiationError(msg);
        }
      });
    }
    ensureVideoDDExtensionForSVC(media, sdp2) {
      var _a, _b;
      const ddFound = (_a = media.ext) === null || _a === void 0 ? void 0 : _a.some((ext) => {
        if (ext.uri === ddExtensionURI) {
          return true;
        }
        return false;
      });
      if (!ddFound) {
        if (this.ddExtID === 0) {
          let maxID = 0;
          sdp2.media.forEach((m) => {
            var _a2;
            if (m.type !== "video") {
              return;
            }
            (_a2 = m.ext) === null || _a2 === void 0 ? void 0 : _a2.forEach((ext) => {
              if (ext.value > maxID) {
                maxID = ext.value;
              }
            });
          });
          this.ddExtID = maxID + 1;
        }
        (_b = media.ext) === null || _b === void 0 ? void 0 : _b.push({
          value: this.ddExtID,
          uri: ddExtensionURI
        });
      }
    }
  };
  function ensureAudioNackAndStereo(media, stereoMids, nackMids) {
    let opusPayload = 0;
    media.rtp.some((rtp) => {
      if (rtp.codec === "opus") {
        opusPayload = rtp.payload;
        return true;
      }
      return false;
    });
    if (opusPayload > 0) {
      if (!media.rtcpFb) {
        media.rtcpFb = [];
      }
      if (nackMids.includes(media.mid) && !media.rtcpFb.some((fb) => fb.payload === opusPayload && fb.type === "nack")) {
        media.rtcpFb.push({
          payload: opusPayload,
          type: "nack"
        });
      }
      if (stereoMids.includes(media.mid)) {
        media.fmtp.some((fmtp) => {
          if (fmtp.payload === opusPayload) {
            if (!fmtp.config.includes("stereo=1")) {
              fmtp.config += ";stereo=1";
            }
            return true;
          }
          return false;
        });
      }
    }
  }
  function extractStereoAndNackAudioFromOffer(offer) {
    var _a;
    const stereoMids = [];
    const nackMids = [];
    const sdpParsed = libExports.parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : "");
    let opusPayload = 0;
    sdpParsed.media.forEach((media) => {
      var _a2;
      if (media.type === "audio") {
        media.rtp.some((rtp) => {
          if (rtp.codec === "opus") {
            opusPayload = rtp.payload;
            return true;
          }
          return false;
        });
        if ((_a2 = media.rtcpFb) === null || _a2 === void 0 ? void 0 : _a2.some((fb) => fb.payload === opusPayload && fb.type === "nack")) {
          nackMids.push(media.mid);
        }
        media.fmtp.some((fmtp) => {
          if (fmtp.payload === opusPayload) {
            if (fmtp.config.includes("sprop-stereo=1")) {
              stereoMids.push(media.mid);
            }
            return true;
          }
          return false;
        });
      }
    });
    return {
      stereoMids,
      nackMids
    };
  }
  function ensureIPAddrMatchVersion(media) {
    if (media.connection) {
      const isV6 = media.connection.ip.indexOf(":") >= 0;
      if (media.connection.version === 4 && isV6 || media.connection.version === 6 && !isV6) {
        media.connection.ip = "0.0.0.0";
        media.connection.version = 4;
      }
    }
  }
  var defaultVideoCodec = "vp8";
  var publishDefaults = {
    audioPreset: AudioPresets.music,
    dtx: true,
    red: true,
    forceStereo: false,
    simulcast: true,
    screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,
    stopMicTrackOnMute: false,
    videoCodec: defaultVideoCodec,
    backupCodec: true
  };
  var audioDefaults = {
    autoGainControl: true,
    echoCancellation: true,
    noiseSuppression: true,
    voiceIsolation: true
  };
  var videoDefaults = {
    resolution: VideoPresets.h720.resolution
  };
  var roomOptionDefaults = {
    adaptiveStream: false,
    dynacast: false,
    stopLocalTrackOnUnpublish: true,
    reconnectPolicy: new DefaultReconnectPolicy(),
    disconnectOnPageLeave: true,
    webAudioMix: false
  };
  var roomConnectOptionDefaults = {
    autoSubscribe: true,
    maxRetries: 1,
    peerConnectionTimeout: 15e3,
    websocketTimeout: 15e3
  };
  var PCTransportState;
  (function(PCTransportState2) {
    PCTransportState2[PCTransportState2["NEW"] = 0] = "NEW";
    PCTransportState2[PCTransportState2["CONNECTING"] = 1] = "CONNECTING";
    PCTransportState2[PCTransportState2["CONNECTED"] = 2] = "CONNECTED";
    PCTransportState2[PCTransportState2["FAILED"] = 3] = "FAILED";
    PCTransportState2[PCTransportState2["CLOSING"] = 4] = "CLOSING";
    PCTransportState2[PCTransportState2["CLOSED"] = 5] = "CLOSED";
  })(PCTransportState || (PCTransportState = {}));
  var PCTransportManager = class {
    get needsPublisher() {
      return this.isPublisherConnectionRequired;
    }
    get needsSubscriber() {
      return this.isSubscriberConnectionRequired;
    }
    get currentState() {
      return this.state;
    }
    constructor(rtcConfig, subscriberPrimary, loggerOptions) {
      var _a;
      this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;
      this.log = livekitLogger;
      this.updateState = () => {
        var _a2;
        const previousState = this.state;
        const connectionStates = this.requiredTransports.map((tr) => tr.getConnectionState());
        if (connectionStates.every((st) => st === "connected")) {
          this.state = PCTransportState.CONNECTED;
        } else if (connectionStates.some((st) => st === "failed")) {
          this.state = PCTransportState.FAILED;
        } else if (connectionStates.some((st) => st === "connecting")) {
          this.state = PCTransportState.CONNECTING;
        } else if (connectionStates.every((st) => st === "closed")) {
          this.state = PCTransportState.CLOSED;
        } else if (connectionStates.some((st) => st === "closed")) {
          this.state = PCTransportState.CLOSING;
        } else if (connectionStates.every((st) => st === "new")) {
          this.state = PCTransportState.NEW;
        }
        if (previousState !== this.state) {
          this.log.debug("pc state change: from ".concat(PCTransportState[previousState], " to ").concat(PCTransportState[this.state]), this.logContext);
          (_a2 = this.onStateChange) === null || _a2 === void 0 ? void 0 : _a2.call(this, this.state, this.publisher.getConnectionState(), this.subscriber.getConnectionState());
        }
      };
      this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCManager);
      this.loggerOptions = loggerOptions;
      this.isPublisherConnectionRequired = !subscriberPrimary;
      this.isSubscriberConnectionRequired = subscriberPrimary;
      this.publisher = new PCTransport(rtcConfig, loggerOptions);
      this.subscriber = new PCTransport(rtcConfig, loggerOptions);
      this.publisher.onConnectionStateChange = this.updateState;
      this.subscriber.onConnectionStateChange = this.updateState;
      this.publisher.onIceConnectionStateChange = this.updateState;
      this.subscriber.onIceConnectionStateChange = this.updateState;
      this.publisher.onSignalingStatechange = this.updateState;
      this.subscriber.onSignalingStatechange = this.updateState;
      this.publisher.onIceCandidate = (candidate) => {
        var _a2;
        (_a2 = this.onIceCandidate) === null || _a2 === void 0 ? void 0 : _a2.call(this, candidate, SignalTarget.PUBLISHER);
      };
      this.subscriber.onIceCandidate = (candidate) => {
        var _a2;
        (_a2 = this.onIceCandidate) === null || _a2 === void 0 ? void 0 : _a2.call(this, candidate, SignalTarget.SUBSCRIBER);
      };
      this.subscriber.onDataChannel = (ev) => {
        var _a2;
        (_a2 = this.onDataChannel) === null || _a2 === void 0 ? void 0 : _a2.call(this, ev);
      };
      this.subscriber.onTrack = (ev) => {
        var _a2;
        (_a2 = this.onTrack) === null || _a2 === void 0 ? void 0 : _a2.call(this, ev);
      };
      this.publisher.onOffer = (offer) => {
        var _a2;
        (_a2 = this.onPublisherOffer) === null || _a2 === void 0 ? void 0 : _a2.call(this, offer);
      };
      this.state = PCTransportState.NEW;
      this.connectionLock = new h();
      this.remoteOfferLock = new h();
    }
    get logContext() {
      var _a, _b;
      return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));
    }
    requirePublisher() {
      let require2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this.isPublisherConnectionRequired = require2;
      this.updateState();
    }
    requireSubscriber() {
      let require2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this.isSubscriberConnectionRequired = require2;
      this.updateState();
    }
    createAndSendPublisherOffer(options) {
      return this.publisher.createAndSendOffer(options);
    }
    setPublisherAnswer(sd) {
      return this.publisher.setRemoteDescription(sd);
    }
    removeTrack(sender) {
      return this.publisher.removeTrack(sender);
    }
    close() {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.publisher && this.publisher.getSignallingState() !== "closed") {
          const publisher = this.publisher;
          for (const sender of publisher.getSenders()) {
            try {
              if (publisher.canRemoveTrack()) {
                publisher.removeTrack(sender);
              }
            } catch (e) {
              this.log.warn("could not removeTrack", Object.assign(Object.assign({}, this.logContext), {
                error: e
              }));
            }
          }
        }
        yield Promise.all([this.publisher.close(), this.subscriber.close()]);
        this.updateState();
      });
    }
    triggerIceRestart() {
      return __awaiter(this, void 0, void 0, function* () {
        this.subscriber.restartingIce = true;
        if (this.needsPublisher) {
          yield this.createAndSendPublisherOffer({
            iceRestart: true
          });
        }
      });
    }
    addIceCandidate(candidate, target) {
      return __awaiter(this, void 0, void 0, function* () {
        if (target === SignalTarget.PUBLISHER) {
          yield this.publisher.addIceCandidate(candidate);
        } else {
          yield this.subscriber.addIceCandidate(candidate);
        }
      });
    }
    createSubscriberAnswerFromOffer(sd) {
      return __awaiter(this, void 0, void 0, function* () {
        this.log.debug("received server offer", Object.assign(Object.assign({}, this.logContext), {
          RTCSdpType: sd.type,
          sdp: sd.sdp,
          signalingState: this.subscriber.getSignallingState().toString()
        }));
        const unlock = yield this.remoteOfferLock.lock();
        try {
          yield this.subscriber.setRemoteDescription(sd);
          const answer = yield this.subscriber.createAndSetAnswer();
          return answer;
        } finally {
          unlock();
        }
      });
    }
    updateConfiguration(config, iceRestart) {
      this.publisher.setConfiguration(config);
      this.subscriber.setConfiguration(config);
      if (iceRestart) {
        this.triggerIceRestart();
      }
    }
    ensurePCTransportConnection(abortController, timeout) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const unlock = yield this.connectionLock.lock();
        try {
          if (this.isPublisherConnectionRequired && this.publisher.getConnectionState() !== "connected" && this.publisher.getConnectionState() !== "connecting") {
            this.log.debug("negotiation required, start negotiating", this.logContext);
            this.publisher.negotiate();
          }
          yield Promise.all((_a = this.requiredTransports) === null || _a === void 0 ? void 0 : _a.map((transport) => this.ensureTransportConnected(transport, abortController, timeout)));
        } finally {
          unlock();
        }
      });
    }
    negotiate(abortController) {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
          const negotiationTimeout = setTimeout(() => {
            reject("negotiation timed out");
          }, this.peerConnectionTimeout);
          const abortHandler = () => {
            clearTimeout(negotiationTimeout);
            reject("negotiation aborted");
          };
          abortController.signal.addEventListener("abort", abortHandler);
          this.publisher.once(PCEvents.NegotiationStarted, () => {
            if (abortController.signal.aborted) {
              return;
            }
            this.publisher.once(PCEvents.NegotiationComplete, () => {
              clearTimeout(negotiationTimeout);
              resolve();
            });
          });
          yield this.publisher.negotiate((e) => {
            clearTimeout(negotiationTimeout);
            reject(e);
          });
        }));
      });
    }
    addPublisherTransceiver(track, transceiverInit) {
      return this.publisher.addTransceiver(track, transceiverInit);
    }
    addPublisherTrack(track) {
      return this.publisher.addTrack(track);
    }
    createPublisherDataChannel(label, dataChannelDict) {
      return this.publisher.createDataChannel(label, dataChannelDict);
    }
    /**
     * Returns the first required transport's address if no explicit target is specified
     */
    getConnectedAddress(target) {
      if (target === SignalTarget.PUBLISHER) {
        return this.publisher.getConnectedAddress();
      } else if (target === SignalTarget.SUBSCRIBER) {
        return this.publisher.getConnectedAddress();
      }
      return this.requiredTransports[0].getConnectedAddress();
    }
    get requiredTransports() {
      const transports = [];
      if (this.isPublisherConnectionRequired) {
        transports.push(this.publisher);
      }
      if (this.isSubscriberConnectionRequired) {
        transports.push(this.subscriber);
      }
      return transports;
    }
    ensureTransportConnected(pcTransport_1, abortController_1) {
      return __awaiter(this, arguments, void 0, function(pcTransport, abortController) {
        var _this = this;
        let timeout = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.peerConnectionTimeout;
        return function* () {
          const connectionState = pcTransport.getConnectionState();
          if (connectionState === "connected") {
            return;
          }
          return new Promise((resolve, reject) => __awaiter(_this, void 0, void 0, function* () {
            const abortHandler = () => {
              this.log.warn("abort transport connection", this.logContext);
              CriticalTimers.clearTimeout(connectTimeout);
              reject(new ConnectionError("room connection has been cancelled", ConnectionErrorReason.Cancelled));
            };
            if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {
              abortHandler();
            }
            abortController === null || abortController === void 0 ? void 0 : abortController.signal.addEventListener("abort", abortHandler);
            const connectTimeout = CriticalTimers.setTimeout(() => {
              abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener("abort", abortHandler);
              reject(new ConnectionError("could not establish pc connection", ConnectionErrorReason.InternalError));
            }, timeout);
            while (this.state !== PCTransportState.CONNECTED) {
              yield sleep(50);
              if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {
                reject(new ConnectionError("room connection has been cancelled", ConnectionErrorReason.Cancelled));
                return;
              }
            }
            CriticalTimers.clearTimeout(connectTimeout);
            abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener("abort", abortHandler);
            resolve();
          }));
        }();
      });
    }
  };
  var monitorFrequency = 2e3;
  function computeBitrate(currentStats, prevStats) {
    if (!prevStats) {
      return 0;
    }
    let bytesNow;
    let bytesPrev;
    if ("bytesReceived" in currentStats) {
      bytesNow = currentStats.bytesReceived;
      bytesPrev = prevStats.bytesReceived;
    } else if ("bytesSent" in currentStats) {
      bytesNow = currentStats.bytesSent;
      bytesPrev = prevStats.bytesSent;
    }
    if (bytesNow === void 0 || bytesPrev === void 0 || currentStats.timestamp === void 0 || prevStats.timestamp === void 0) {
      return 0;
    }
    return (bytesNow - bytesPrev) * 8 * 1e3 / (currentStats.timestamp - prevStats.timestamp);
  }
  var LocalAudioTrack = class extends LocalTrack {
    /**
     * boolean indicating whether enhanced noise cancellation is currently being used on this track
     */
    get enhancedNoiseCancellation() {
      return this.isKrispNoiseFilterEnabled;
    }
    /**
     *
     * @param mediaTrack
     * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
     * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
     */
    constructor(mediaTrack, constraints) {
      let userProvidedTrack = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      let audioContext = arguments.length > 3 ? arguments[3] : void 0;
      let loggerOptions = arguments.length > 4 ? arguments[4] : void 0;
      super(mediaTrack, Track.Kind.Audio, constraints, userProvidedTrack, loggerOptions);
      this.stopOnMute = false;
      this.isKrispNoiseFilterEnabled = false;
      this.monitorSender = () => __awaiter(this, void 0, void 0, function* () {
        if (!this.sender) {
          this._currentBitrate = 0;
          return;
        }
        let stats;
        try {
          stats = yield this.getSenderStats();
        } catch (e) {
          this.log.error("could not get audio sender stats", Object.assign(Object.assign({}, this.logContext), {
            error: e
          }));
          return;
        }
        if (stats && this.prevStats) {
          this._currentBitrate = computeBitrate(stats, this.prevStats);
        }
        this.prevStats = stats;
      });
      this.handleKrispNoiseFilterEnable = () => {
        this.isKrispNoiseFilterEnabled = true;
        this.log.debug("Krisp noise filter enabled", this.logContext);
        this.emit(TrackEvent.AudioTrackFeatureUpdate, this, AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION, true);
      };
      this.handleKrispNoiseFilterDisable = () => {
        this.isKrispNoiseFilterEnabled = false;
        this.log.debug("Krisp noise filter disabled", this.logContext);
        this.emit(TrackEvent.AudioTrackFeatureUpdate, this, AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION, false);
      };
      this.audioContext = audioContext;
      this.checkForSilence();
    }
    setDeviceId(deviceId) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this._constraints.deviceId === deviceId && this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(deviceId)) {
          return true;
        }
        this._constraints.deviceId = deviceId;
        if (!this.isMuted) {
          yield this.restartTrack();
        }
        return this.isMuted || unwrapConstraint(deviceId) === this._mediaStreamTrack.getSettings().deviceId;
      });
    }
    mute() {
      const _super = Object.create(null, {
        mute: {
          get: () => super.mute
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        const unlock = yield this.muteLock.lock();
        try {
          if (this.isMuted) {
            this.log.debug("Track already muted", this.logContext);
            return this;
          }
          if (this.source === Track.Source.Microphone && this.stopOnMute && !this.isUserProvided) {
            this.log.debug("stopping mic track", this.logContext);
            this._mediaStreamTrack.stop();
          }
          yield _super.mute.call(this);
          return this;
        } finally {
          unlock();
        }
      });
    }
    unmute() {
      const _super = Object.create(null, {
        unmute: {
          get: () => super.unmute
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        const unlock = yield this.muteLock.lock();
        try {
          if (!this.isMuted) {
            this.log.debug("Track already unmuted", this.logContext);
            return this;
          }
          const deviceHasChanged = this._constraints.deviceId && this._mediaStreamTrack.getSettings().deviceId !== unwrapConstraint(this._constraints.deviceId);
          if (this.source === Track.Source.Microphone && (this.stopOnMute || this._mediaStreamTrack.readyState === "ended" || deviceHasChanged) && !this.isUserProvided) {
            this.log.debug("reacquiring mic track", this.logContext);
            yield this.restartTrack();
          }
          yield _super.unmute.call(this);
          return this;
        } finally {
          unlock();
        }
      });
    }
    restartTrack(options) {
      return __awaiter(this, void 0, void 0, function* () {
        let constraints;
        if (options) {
          const streamConstraints = constraintsForOptions({
            audio: options
          });
          if (typeof streamConstraints.audio !== "boolean") {
            constraints = streamConstraints.audio;
          }
        }
        yield this.restart(constraints);
      });
    }
    restart(constraints) {
      const _super = Object.create(null, {
        restart: {
          get: () => super.restart
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        const track = yield _super.restart.call(this, constraints);
        this.checkForSilence();
        return track;
      });
    }
    /* @internal */
    startMonitor() {
      if (!isWeb()) {
        return;
      }
      if (this.monitorInterval) {
        return;
      }
      this.monitorInterval = setInterval(() => {
        this.monitorSender();
      }, monitorFrequency);
    }
    setProcessor(processor) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const unlock = yield this.processorLock.lock();
        try {
          if (!this.audioContext) {
            throw Error("Audio context needs to be set on LocalAudioTrack in order to enable processors");
          }
          if (this.processor) {
            yield this.stopProcessor();
          }
          const processorOptions = {
            kind: this.kind,
            track: this._mediaStreamTrack,
            audioContext: this.audioContext
          };
          this.log.debug("setting up audio processor ".concat(processor.name), this.logContext);
          yield processor.init(processorOptions);
          this.processor = processor;
          if (this.processor.processedTrack) {
            yield (_a = this.sender) === null || _a === void 0 ? void 0 : _a.replaceTrack(this.processor.processedTrack);
            this.processor.processedTrack.addEventListener("enable-lk-krisp-noise-filter", this.handleKrispNoiseFilterEnable);
            this.processor.processedTrack.addEventListener("disable-lk-krisp-noise-filter", this.handleKrispNoiseFilterDisable);
          }
          this.emit(TrackEvent.TrackProcessorUpdate, this.processor);
        } finally {
          unlock();
        }
      });
    }
    /**
     * @internal
     * @experimental
     */
    setAudioContext(audioContext) {
      this.audioContext = audioContext;
    }
    getSenderStats() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {
          return void 0;
        }
        const stats = yield this.sender.getStats();
        let audioStats;
        stats.forEach((v) => {
          if (v.type === "outbound-rtp") {
            audioStats = {
              type: "audio",
              streamId: v.id,
              packetsSent: v.packetsSent,
              packetsLost: v.packetsLost,
              bytesSent: v.bytesSent,
              timestamp: v.timestamp,
              roundTripTime: v.roundTripTime,
              jitter: v.jitter
            };
          }
        });
        return audioStats;
      });
    }
    checkForSilence() {
      return __awaiter(this, void 0, void 0, function* () {
        const trackIsSilent = yield detectSilence(this);
        if (trackIsSilent) {
          if (!this.isMuted) {
            this.log.warn("silence detected on local audio track", this.logContext);
          }
          this.emit(TrackEvent.AudioSilenceDetected);
        }
        return trackIsSilent;
      });
    }
  };
  function mediaTrackToLocalTrack(mediaStreamTrack, constraints, loggerOptions) {
    switch (mediaStreamTrack.kind) {
      case "audio":
        return new LocalAudioTrack(mediaStreamTrack, constraints, false, void 0, loggerOptions);
      case "video":
        return new LocalVideoTrack(mediaStreamTrack, constraints, false, loggerOptions);
      default:
        throw new TrackInvalidError("unsupported track type: ".concat(mediaStreamTrack.kind));
    }
  }
  var presets169 = Object.values(VideoPresets);
  var presets43 = Object.values(VideoPresets43);
  var presetsScreenShare = Object.values(ScreenSharePresets);
  var defaultSimulcastPresets169 = [VideoPresets.h180, VideoPresets.h360];
  var defaultSimulcastPresets43 = [VideoPresets43.h180, VideoPresets43.h360];
  var computeDefaultScreenShareSimulcastPresets = (fromPreset) => {
    const layers = [{
      scaleResolutionDownBy: 2,
      fps: fromPreset.encoding.maxFramerate
    }];
    return layers.map((t) => {
      var _a, _b;
      return new VideoPreset(Math.floor(fromPreset.width / t.scaleResolutionDownBy), Math.floor(fromPreset.height / t.scaleResolutionDownBy), Math.max(15e4, Math.floor(fromPreset.encoding.maxBitrate / (Math.pow(t.scaleResolutionDownBy, 2) * (((_a = fromPreset.encoding.maxFramerate) !== null && _a !== void 0 ? _a : 30) / ((_b = t.fps) !== null && _b !== void 0 ? _b : 30))))), t.fps, fromPreset.encoding.priority);
    });
  };
  var videoRids = ["q", "h", "f"];
  function computeVideoEncodings(isScreenShare, width, height, options) {
    var _a, _b;
    let videoEncoding = options === null || options === void 0 ? void 0 : options.videoEncoding;
    if (isScreenShare) {
      videoEncoding = options === null || options === void 0 ? void 0 : options.screenShareEncoding;
    }
    const useSimulcast = options === null || options === void 0 ? void 0 : options.simulcast;
    const scalabilityMode = options === null || options === void 0 ? void 0 : options.scalabilityMode;
    const videoCodec = options === null || options === void 0 ? void 0 : options.videoCodec;
    if (!videoEncoding && !useSimulcast && !scalabilityMode || !width || !height) {
      return [{}];
    }
    if (!videoEncoding) {
      videoEncoding = determineAppropriateEncoding(isScreenShare, width, height, videoCodec);
      livekitLogger.debug("using video encoding", videoEncoding);
    }
    const original = new VideoPreset(width, height, videoEncoding.maxBitrate, videoEncoding.maxFramerate, videoEncoding.priority);
    if (scalabilityMode && isSVCCodec(videoCodec)) {
      const sm = new ScalabilityMode(scalabilityMode);
      const encodings = [];
      if (sm.spatial > 3) {
        throw new Error("unsupported scalabilityMode: ".concat(scalabilityMode));
      }
      const browser = getBrowser();
      if (isSafari() || // Even tho RN runs M114, it does not produce SVC layers when a single encoding
      // is provided. So we'll use the legacy SVC specification for now.
      // TODO: when we upstream libwebrtc, this will need additional verification
      isReactNative() || (browser === null || browser === void 0 ? void 0 : browser.name) === "Chrome" && compareVersions(browser === null || browser === void 0 ? void 0 : browser.version, "113") < 0) {
        const bitratesRatio = sm.suffix == "h" ? 2 : 3;
        for (let i = 0; i < sm.spatial; i += 1) {
          encodings.push({
            rid: videoRids[2 - i],
            maxBitrate: videoEncoding.maxBitrate / Math.pow(bitratesRatio, i),
            maxFramerate: original.encoding.maxFramerate
          });
        }
        encodings[0].scalabilityMode = scalabilityMode;
      } else {
        encodings.push({
          maxBitrate: videoEncoding.maxBitrate,
          maxFramerate: original.encoding.maxFramerate,
          /* @ts-ignore */
          scalabilityMode
        });
      }
      if (original.encoding.priority) {
        encodings[0].priority = original.encoding.priority;
        encodings[0].networkPriority = original.encoding.priority;
      }
      livekitLogger.debug("using svc encoding", {
        encodings
      });
      return encodings;
    }
    if (!useSimulcast) {
      return [videoEncoding];
    }
    let presets = [];
    if (isScreenShare) {
      presets = (_a = sortPresets(options === null || options === void 0 ? void 0 : options.screenShareSimulcastLayers)) !== null && _a !== void 0 ? _a : defaultSimulcastLayers(isScreenShare, original);
    } else {
      presets = (_b = sortPresets(options === null || options === void 0 ? void 0 : options.videoSimulcastLayers)) !== null && _b !== void 0 ? _b : defaultSimulcastLayers(isScreenShare, original);
    }
    let midPreset;
    if (presets.length > 0) {
      const lowPreset = presets[0];
      if (presets.length > 1) {
        [, midPreset] = presets;
      }
      const size = Math.max(width, height);
      if (size >= 960 && midPreset) {
        return encodingsFromPresets(width, height, [lowPreset, midPreset, original]);
      }
      if (size >= 480) {
        return encodingsFromPresets(width, height, [lowPreset, original]);
      }
    }
    return encodingsFromPresets(width, height, [original]);
  }
  function computeTrackBackupEncodings(track, videoCodec, opts) {
    var _a, _b, _c, _d;
    if (!opts.backupCodec || opts.backupCodec === true || opts.backupCodec.codec === opts.videoCodec) {
      return;
    }
    if (videoCodec !== opts.backupCodec.codec) {
      livekitLogger.warn("requested a different codec than specified as backup", {
        serverRequested: videoCodec,
        backup: opts.backupCodec.codec
      });
    }
    opts.videoCodec = videoCodec;
    opts.videoEncoding = opts.backupCodec.encoding;
    const settings = track.mediaStreamTrack.getSettings();
    const width = (_a = settings.width) !== null && _a !== void 0 ? _a : (_b = track.dimensions) === null || _b === void 0 ? void 0 : _b.width;
    const height = (_c = settings.height) !== null && _c !== void 0 ? _c : (_d = track.dimensions) === null || _d === void 0 ? void 0 : _d.height;
    const encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, width, height, opts);
    return encodings;
  }
  function determineAppropriateEncoding(isScreenShare, width, height, codec) {
    const presets = presetsForResolution(isScreenShare, width, height);
    let {
      encoding
    } = presets[0];
    const size = Math.max(width, height);
    for (let i = 0; i < presets.length; i += 1) {
      const preset = presets[i];
      encoding = preset.encoding;
      if (preset.width >= size) {
        break;
      }
    }
    if (codec) {
      switch (codec) {
        case "av1":
          encoding = Object.assign({}, encoding);
          encoding.maxBitrate = encoding.maxBitrate * 0.7;
          break;
        case "vp9":
          encoding = Object.assign({}, encoding);
          encoding.maxBitrate = encoding.maxBitrate * 0.85;
          break;
      }
    }
    return encoding;
  }
  function presetsForResolution(isScreenShare, width, height) {
    if (isScreenShare) {
      return presetsScreenShare;
    }
    const aspect = width > height ? width / height : height / width;
    if (Math.abs(aspect - 16 / 9) < Math.abs(aspect - 4 / 3)) {
      return presets169;
    }
    return presets43;
  }
  function defaultSimulcastLayers(isScreenShare, original) {
    if (isScreenShare) {
      return computeDefaultScreenShareSimulcastPresets(original);
    }
    const {
      width,
      height
    } = original;
    const aspect = width > height ? width / height : height / width;
    if (Math.abs(aspect - 16 / 9) < Math.abs(aspect - 4 / 3)) {
      return defaultSimulcastPresets169;
    }
    return defaultSimulcastPresets43;
  }
  function encodingsFromPresets(width, height, presets) {
    const encodings = [];
    presets.forEach((preset, idx) => {
      if (idx >= videoRids.length) {
        return;
      }
      const size = Math.min(width, height);
      const rid = videoRids[idx];
      const encoding = {
        rid,
        scaleResolutionDownBy: Math.max(1, size / Math.min(preset.width, preset.height)),
        maxBitrate: preset.encoding.maxBitrate
      };
      if (preset.encoding.maxFramerate) {
        encoding.maxFramerate = preset.encoding.maxFramerate;
      }
      const canSetPriority = isFireFox() || idx === 0;
      if (preset.encoding.priority && canSetPriority) {
        encoding.priority = preset.encoding.priority;
        encoding.networkPriority = preset.encoding.priority;
      }
      encodings.push(encoding);
    });
    if (isReactNative() && getReactNativeOs() === "ios") {
      let topFramerate = void 0;
      encodings.forEach((encoding) => {
        if (!topFramerate) {
          topFramerate = encoding.maxFramerate;
        } else if (encoding.maxFramerate && encoding.maxFramerate > topFramerate) {
          topFramerate = encoding.maxFramerate;
        }
      });
      let notifyOnce = true;
      encodings.forEach((encoding) => {
        var _a;
        if (encoding.maxFramerate != topFramerate) {
          if (notifyOnce) {
            notifyOnce = false;
            livekitLogger.info("Simulcast on iOS React-Native requires all encodings to share the same framerate.");
          }
          livekitLogger.info('Setting framerate of encoding "'.concat((_a = encoding.rid) !== null && _a !== void 0 ? _a : "", '" to ').concat(topFramerate));
          encoding.maxFramerate = topFramerate;
        }
      });
    }
    return encodings;
  }
  function sortPresets(presets) {
    if (!presets) return;
    return presets.sort((a, b) => {
      const {
        encoding: aEnc
      } = a;
      const {
        encoding: bEnc
      } = b;
      if (aEnc.maxBitrate > bEnc.maxBitrate) {
        return 1;
      }
      if (aEnc.maxBitrate < bEnc.maxBitrate) return -1;
      if (aEnc.maxBitrate === bEnc.maxBitrate && aEnc.maxFramerate && bEnc.maxFramerate) {
        return aEnc.maxFramerate > bEnc.maxFramerate ? 1 : -1;
      }
      return 0;
    });
  }
  var ScalabilityMode = class {
    constructor(scalabilityMode) {
      const results = scalabilityMode.match(/^L(\d)T(\d)(h|_KEY|_KEY_SHIFT){0,1}$/);
      if (!results) {
        throw new Error("invalid scalability mode");
      }
      this.spatial = parseInt(results[1]);
      this.temporal = parseInt(results[2]);
      if (results.length > 3) {
        switch (results[3]) {
          case "h":
          case "_KEY":
          case "_KEY_SHIFT":
            this.suffix = results[3];
        }
      }
    }
    toString() {
      var _a;
      return "L".concat(this.spatial, "T").concat(this.temporal).concat((_a = this.suffix) !== null && _a !== void 0 ? _a : "");
    }
  };
  function getDefaultDegradationPreference(track) {
    if (track.source === Track.Source.ScreenShare || track.constraints.height && unwrapConstraint(track.constraints.height) >= 1080) {
      return "maintain-resolution";
    } else {
      return "balanced";
    }
  }
  var refreshSubscribedCodecAfterNewCodec = 5e3;
  var LocalVideoTrack = class extends LocalTrack {
    get sender() {
      return this._sender;
    }
    set sender(sender) {
      this._sender = sender;
      if (this.degradationPreference) {
        this.setDegradationPreference(this.degradationPreference);
      }
    }
    /**
     *
     * @param mediaTrack
     * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
     * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
     */
    constructor(mediaTrack, constraints) {
      let userProvidedTrack = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      let loggerOptions = arguments.length > 3 ? arguments[3] : void 0;
      super(mediaTrack, Track.Kind.Video, constraints, userProvidedTrack, loggerOptions);
      this.simulcastCodecs = /* @__PURE__ */ new Map();
      this.degradationPreference = "balanced";
      this.monitorSender = () => __awaiter(this, void 0, void 0, function* () {
        if (!this.sender) {
          this._currentBitrate = 0;
          return;
        }
        let stats;
        try {
          stats = yield this.getSenderStats();
        } catch (e) {
          this.log.error("could not get audio sender stats", Object.assign(Object.assign({}, this.logContext), {
            error: e
          }));
          return;
        }
        const statsMap = new Map(stats.map((s) => [s.rid, s]));
        if (this.prevStats) {
          let totalBitrate = 0;
          statsMap.forEach((s, key) => {
            var _a;
            const prev = (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.get(key);
            totalBitrate += computeBitrate(s, prev);
          });
          this._currentBitrate = totalBitrate;
        }
        this.prevStats = statsMap;
      });
      this.senderLock = new h();
    }
    get isSimulcast() {
      if (this.sender && this.sender.getParameters().encodings.length > 1) {
        return true;
      }
      return false;
    }
    /* @internal */
    startMonitor(signalClient) {
      var _a;
      this.signalClient = signalClient;
      if (!isWeb()) {
        return;
      }
      const params = (_a = this.sender) === null || _a === void 0 ? void 0 : _a.getParameters();
      if (params) {
        this.encodings = params.encodings;
      }
      if (this.monitorInterval) {
        return;
      }
      this.monitorInterval = setInterval(() => {
        this.monitorSender();
      }, monitorFrequency);
    }
    stop() {
      this._mediaStreamTrack.getConstraints();
      this.simulcastCodecs.forEach((trackInfo) => {
        trackInfo.mediaStreamTrack.stop();
      });
      super.stop();
    }
    pauseUpstream() {
      const _super = Object.create(null, {
        pauseUpstream: {
          get: () => super.pauseUpstream
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        var _a, e_1, _b, _c;
        var _d;
        yield _super.pauseUpstream.call(this);
        try {
          for (var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true) {
            _c = _g.value;
            _e = false;
            const sc = _c;
            yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(null);
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      });
    }
    resumeUpstream() {
      const _super = Object.create(null, {
        resumeUpstream: {
          get: () => super.resumeUpstream
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        var _a, e_2, _b, _c;
        var _d;
        yield _super.resumeUpstream.call(this);
        try {
          for (var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true) {
            _c = _g.value;
            _e = false;
            const sc = _c;
            yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(sc.mediaStreamTrack);
          }
        } catch (e_2_1) {
          e_2 = {
            error: e_2_1
          };
        } finally {
          try {
            if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      });
    }
    mute() {
      const _super = Object.create(null, {
        mute: {
          get: () => super.mute
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        const unlock = yield this.muteLock.lock();
        try {
          if (this.isMuted) {
            this.log.debug("Track already muted", this.logContext);
            return this;
          }
          if (this.source === Track.Source.Camera && !this.isUserProvided) {
            this.log.debug("stopping camera track", this.logContext);
            this._mediaStreamTrack.stop();
          }
          yield _super.mute.call(this);
          return this;
        } finally {
          unlock();
        }
      });
    }
    unmute() {
      const _super = Object.create(null, {
        unmute: {
          get: () => super.unmute
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        const unlock = yield this.muteLock.lock();
        try {
          if (!this.isMuted) {
            this.log.debug("Track already unmuted", this.logContext);
            return this;
          }
          if (this.source === Track.Source.Camera && !this.isUserProvided) {
            this.log.debug("reacquiring camera track", this.logContext);
            yield this.restartTrack();
          }
          yield _super.unmute.call(this);
          return this;
        } finally {
          unlock();
        }
      });
    }
    setTrackMuted(muted) {
      super.setTrackMuted(muted);
      for (const sc of this.simulcastCodecs.values()) {
        sc.mediaStreamTrack.enabled = !muted;
      }
    }
    getSenderStats() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {
          return [];
        }
        const items = [];
        const stats = yield this.sender.getStats();
        stats.forEach((v) => {
          var _a2;
          if (v.type === "outbound-rtp") {
            const vs = {
              type: "video",
              streamId: v.id,
              frameHeight: v.frameHeight,
              frameWidth: v.frameWidth,
              framesPerSecond: v.framesPerSecond,
              framesSent: v.framesSent,
              firCount: v.firCount,
              pliCount: v.pliCount,
              nackCount: v.nackCount,
              packetsSent: v.packetsSent,
              bytesSent: v.bytesSent,
              qualityLimitationReason: v.qualityLimitationReason,
              qualityLimitationDurations: v.qualityLimitationDurations,
              qualityLimitationResolutionChanges: v.qualityLimitationResolutionChanges,
              rid: (_a2 = v.rid) !== null && _a2 !== void 0 ? _a2 : v.id,
              retransmittedPacketsSent: v.retransmittedPacketsSent,
              targetBitrate: v.targetBitrate,
              timestamp: v.timestamp
            };
            const r2 = stats.get(v.remoteId);
            if (r2) {
              vs.jitter = r2.jitter;
              vs.packetsLost = r2.packetsLost;
              vs.roundTripTime = r2.roundTripTime;
            }
            items.push(vs);
          }
        });
        items.sort((a, b) => {
          var _a2, _b;
          return ((_a2 = b.frameWidth) !== null && _a2 !== void 0 ? _a2 : 0) - ((_b = a.frameWidth) !== null && _b !== void 0 ? _b : 0);
        });
        return items;
      });
    }
    setPublishingQuality(maxQuality) {
      const qualities = [];
      for (let q = VideoQuality.LOW; q <= VideoQuality.HIGH; q += 1) {
        qualities.push(new SubscribedQuality({
          quality: q,
          enabled: q <= maxQuality
        }));
      }
      this.log.debug("setting publishing quality. max quality ".concat(maxQuality), this.logContext);
      this.setPublishingLayers(qualities);
    }
    setDeviceId(deviceId) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this._constraints.deviceId === deviceId && this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(deviceId)) {
          return true;
        }
        this._constraints.deviceId = deviceId;
        if (!this.isMuted) {
          yield this.restartTrack();
        }
        return this.isMuted || unwrapConstraint(deviceId) === this._mediaStreamTrack.getSettings().deviceId;
      });
    }
    restartTrack(options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, e_3, _b, _c;
        let constraints;
        if (options) {
          const streamConstraints = constraintsForOptions({
            video: options
          });
          if (typeof streamConstraints.video !== "boolean") {
            constraints = streamConstraints.video;
          }
        }
        yield this.restart(constraints);
        try {
          for (var _d = true, _e = __asyncValues(this.simulcastCodecs.values()), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
            _c = _f.value;
            _d = false;
            const sc = _c;
            if (sc.sender) {
              sc.mediaStreamTrack = this.mediaStreamTrack.clone();
              yield sc.sender.replaceTrack(sc.mediaStreamTrack);
            }
          }
        } catch (e_3_1) {
          e_3 = {
            error: e_3_1
          };
        } finally {
          try {
            if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
          } finally {
            if (e_3) throw e_3.error;
          }
        }
      });
    }
    setProcessor(processor_1) {
      const _super = Object.create(null, {
        setProcessor: {
          get: () => super.setProcessor
        }
      });
      return __awaiter(this, arguments, void 0, function(processor) {
        var _this = this;
        let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        return function* () {
          var _a, e_4, _b, _c;
          var _d, _e;
          yield _super.setProcessor.call(_this, processor, showProcessedStreamLocally);
          if ((_d = _this.processor) === null || _d === void 0 ? void 0 : _d.processedTrack) {
            try {
              for (var _f = true, _g = __asyncValues(_this.simulcastCodecs.values()), _h; _h = yield _g.next(), _a = _h.done, !_a; _f = true) {
                _c = _h.value;
                _f = false;
                const sc = _c;
                yield (_e = sc.sender) === null || _e === void 0 ? void 0 : _e.replaceTrack(_this.processor.processedTrack);
              }
            } catch (e_4_1) {
              e_4 = {
                error: e_4_1
              };
            } finally {
              try {
                if (!_f && !_a && (_b = _g.return)) yield _b.call(_g);
              } finally {
                if (e_4) throw e_4.error;
              }
            }
          }
        }();
      });
    }
    setDegradationPreference(preference) {
      return __awaiter(this, void 0, void 0, function* () {
        this.degradationPreference = preference;
        if (this.sender) {
          try {
            this.log.debug("setting degradationPreference to ".concat(preference), this.logContext);
            const params = this.sender.getParameters();
            params.degradationPreference = preference;
            this.sender.setParameters(params);
          } catch (e) {
            this.log.warn("failed to set degradationPreference", Object.assign({
              error: e
            }, this.logContext));
          }
        }
      });
    }
    addSimulcastTrack(codec, encodings) {
      if (this.simulcastCodecs.has(codec)) {
        this.log.error("".concat(codec, " already added, skipping adding simulcast codec"), this.logContext);
        return;
      }
      const simulcastCodecInfo = {
        codec,
        mediaStreamTrack: this.mediaStreamTrack.clone(),
        sender: void 0,
        encodings
      };
      this.simulcastCodecs.set(codec, simulcastCodecInfo);
      return simulcastCodecInfo;
    }
    setSimulcastTrackSender(codec, sender) {
      const simulcastCodecInfo = this.simulcastCodecs.get(codec);
      if (!simulcastCodecInfo) {
        return;
      }
      simulcastCodecInfo.sender = sender;
      setTimeout(() => {
        if (this.subscribedCodecs) {
          this.setPublishingCodecs(this.subscribedCodecs);
        }
      }, refreshSubscribedCodecAfterNewCodec);
    }
    /**
     * @internal
     * Sets codecs that should be publishing, returns new codecs that have not yet
     * been published
     */
    setPublishingCodecs(codecs) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, codecs_1, codecs_1_1;
        var _b, e_5, _c, _d;
        this.log.debug("setting publishing codecs", Object.assign(Object.assign({}, this.logContext), {
          codecs,
          currentCodec: this.codec
        }));
        if (!this.codec && codecs.length > 0) {
          yield this.setPublishingLayers(codecs[0].qualities);
          return [];
        }
        this.subscribedCodecs = codecs;
        const newCodecs = [];
        try {
          for (_a = true, codecs_1 = __asyncValues(codecs); codecs_1_1 = yield codecs_1.next(), _b = codecs_1_1.done, !_b; _a = true) {
            _d = codecs_1_1.value;
            _a = false;
            const codec = _d;
            if (!this.codec || this.codec === codec.codec) {
              yield this.setPublishingLayers(codec.qualities);
            } else {
              const simulcastCodecInfo = this.simulcastCodecs.get(codec.codec);
              this.log.debug("try setPublishingCodec for ".concat(codec.codec), Object.assign(Object.assign({}, this.logContext), {
                simulcastCodecInfo
              }));
              if (!simulcastCodecInfo || !simulcastCodecInfo.sender) {
                for (const q of codec.qualities) {
                  if (q.enabled) {
                    newCodecs.push(codec.codec);
                    break;
                  }
                }
              } else if (simulcastCodecInfo.encodings) {
                this.log.debug("try setPublishingLayersForSender ".concat(codec.codec), this.logContext);
                yield setPublishingLayersForSender(simulcastCodecInfo.sender, simulcastCodecInfo.encodings, codec.qualities, this.senderLock, this.log, this.logContext);
              }
            }
          }
        } catch (e_5_1) {
          e_5 = {
            error: e_5_1
          };
        } finally {
          try {
            if (!_a && !_b && (_c = codecs_1.return)) yield _c.call(codecs_1);
          } finally {
            if (e_5) throw e_5.error;
          }
        }
        return newCodecs;
      });
    }
    /**
     * @internal
     * Sets layers that should be publishing
     */
    setPublishingLayers(qualities) {
      return __awaiter(this, void 0, void 0, function* () {
        this.log.debug("setting publishing layers", Object.assign(Object.assign({}, this.logContext), {
          qualities
        }));
        if (!this.sender || !this.encodings) {
          return;
        }
        yield setPublishingLayersForSender(this.sender, this.encodings, qualities, this.senderLock, this.log, this.logContext);
      });
    }
    handleAppVisibilityChanged() {
      const _super = Object.create(null, {
        handleAppVisibilityChanged: {
          get: () => super.handleAppVisibilityChanged
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        yield _super.handleAppVisibilityChanged.call(this);
        if (!isMobile()) return;
        if (this.isInBackground && this.source === Track.Source.Camera) {
          this._mediaStreamTrack.enabled = false;
        }
      });
    }
  };
  function setPublishingLayersForSender(sender, senderEncodings, qualities, senderLock, log2, logContext) {
    return __awaiter(this, void 0, void 0, function* () {
      const unlock = yield senderLock.lock();
      log2.debug("setPublishingLayersForSender", Object.assign(Object.assign({}, logContext), {
        sender,
        qualities,
        senderEncodings
      }));
      try {
        const params = sender.getParameters();
        const {
          encodings
        } = params;
        if (!encodings) {
          return;
        }
        if (encodings.length !== senderEncodings.length) {
          log2.warn("cannot set publishing layers, encodings mismatch", Object.assign(Object.assign({}, logContext), {
            encodings,
            senderEncodings
          }));
          return;
        }
        let hasChanged = false;
        const closableSpatial = false;
        if (closableSpatial && encodings[0].scalabilityMode) ;
        else {
          encodings.forEach((encoding, idx) => {
            var _a;
            let rid = (_a = encoding.rid) !== null && _a !== void 0 ? _a : "";
            if (rid === "") {
              rid = "q";
            }
            const quality = videoQualityForRid(rid);
            const subscribedQuality = qualities.find((q) => q.quality === quality);
            if (!subscribedQuality) {
              return;
            }
            if (encoding.active !== subscribedQuality.enabled) {
              hasChanged = true;
              encoding.active = subscribedQuality.enabled;
              log2.debug("setting layer ".concat(subscribedQuality.quality, " to ").concat(encoding.active ? "enabled" : "disabled"), logContext);
              if (isFireFox()) {
                if (subscribedQuality.enabled) {
                  encoding.scaleResolutionDownBy = senderEncodings[idx].scaleResolutionDownBy;
                  encoding.maxBitrate = senderEncodings[idx].maxBitrate;
                  encoding.maxFrameRate = senderEncodings[idx].maxFrameRate;
                } else {
                  encoding.scaleResolutionDownBy = 4;
                  encoding.maxBitrate = 10;
                  encoding.maxFrameRate = 2;
                }
              }
            }
          });
        }
        if (hasChanged) {
          params.encodings = encodings;
          log2.debug("setting encodings", Object.assign(Object.assign({}, logContext), {
            encodings: params.encodings
          }));
          yield sender.setParameters(params);
        }
      } finally {
        unlock();
      }
    });
  }
  function videoQualityForRid(rid) {
    switch (rid) {
      case "f":
        return VideoQuality.HIGH;
      case "h":
        return VideoQuality.MEDIUM;
      case "q":
        return VideoQuality.LOW;
      default:
        return VideoQuality.HIGH;
    }
  }
  function videoLayersFromEncodings(width, height, encodings, svc) {
    if (!encodings) {
      return [new VideoLayer({
        quality: VideoQuality.HIGH,
        width,
        height,
        bitrate: 0,
        ssrc: 0
      })];
    }
    if (svc) {
      const encodingSM = encodings[0].scalabilityMode;
      const sm = new ScalabilityMode(encodingSM);
      const layers = [];
      const resRatio = sm.suffix == "h" ? 1.5 : 2;
      const bitratesRatio = sm.suffix == "h" ? 2 : 3;
      for (let i = 0; i < sm.spatial; i += 1) {
        layers.push(new VideoLayer({
          quality: Math.min(VideoQuality.HIGH, sm.spatial - 1) - i,
          width: Math.ceil(width / Math.pow(resRatio, i)),
          height: Math.ceil(height / Math.pow(resRatio, i)),
          bitrate: encodings[0].maxBitrate ? Math.ceil(encodings[0].maxBitrate / Math.pow(bitratesRatio, i)) : 0,
          ssrc: 0
        }));
      }
      return layers;
    }
    return encodings.map((encoding) => {
      var _a, _b, _c;
      const scale = (_a = encoding.scaleResolutionDownBy) !== null && _a !== void 0 ? _a : 1;
      let quality = videoQualityForRid((_b = encoding.rid) !== null && _b !== void 0 ? _b : "");
      return new VideoLayer({
        quality,
        width: Math.ceil(width / scale),
        height: Math.ceil(height / scale),
        bitrate: (_c = encoding.maxBitrate) !== null && _c !== void 0 ? _c : 0,
        ssrc: 0
      });
    });
  }
  var lossyDataChannel = "_lossy";
  var reliableDataChannel = "_reliable";
  var minReconnectWait = 2 * 1e3;
  var leaveReconnect = "leave-reconnect";
  var PCState;
  (function(PCState2) {
    PCState2[PCState2["New"] = 0] = "New";
    PCState2[PCState2["Connected"] = 1] = "Connected";
    PCState2[PCState2["Disconnected"] = 2] = "Disconnected";
    PCState2[PCState2["Reconnecting"] = 3] = "Reconnecting";
    PCState2[PCState2["Closed"] = 4] = "Closed";
  })(PCState || (PCState = {}));
  var RTCEngine = class extends eventsExports.EventEmitter {
    get isClosed() {
      return this._isClosed;
    }
    get pendingReconnect() {
      return !!this.reconnectTimeout;
    }
    constructor(options) {
      var _a;
      super();
      this.options = options;
      this.rtcConfig = {};
      this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;
      this.fullReconnectOnNext = false;
      this.subscriberPrimary = false;
      this.pcState = PCState.New;
      this._isClosed = true;
      this.pendingTrackResolvers = {};
      this.reconnectAttempts = 0;
      this.reconnectStart = 0;
      this.attemptingReconnect = false;
      this.joinAttempts = 0;
      this.maxJoinAttempts = 1;
      this.shouldFailNext = false;
      this.log = livekitLogger;
      this.handleDataChannel = (_a2) => __awaiter(this, [_a2], void 0, function(_ref) {
        var _this = this;
        let {
          channel
        } = _ref;
        return function* () {
          if (!channel) {
            return;
          }
          if (channel.label === reliableDataChannel) {
            _this.reliableDCSub = channel;
          } else if (channel.label === lossyDataChannel) {
            _this.lossyDCSub = channel;
          } else {
            return;
          }
          _this.log.debug("on data channel ".concat(channel.id, ", ").concat(channel.label), _this.logContext);
          channel.onmessage = _this.handleDataMessage;
        }();
      });
      this.handleDataMessage = (message) => __awaiter(this, void 0, void 0, function* () {
        var _a2, _b;
        const unlock = yield this.dataProcessLock.lock();
        try {
          let buffer;
          if (message.data instanceof ArrayBuffer) {
            buffer = message.data;
          } else if (message.data instanceof Blob) {
            buffer = yield message.data.arrayBuffer();
          } else {
            this.log.error("unsupported data type", Object.assign(Object.assign({}, this.logContext), {
              data: message.data
            }));
            return;
          }
          const dp = DataPacket.fromBinary(new Uint8Array(buffer));
          if (((_a2 = dp.value) === null || _a2 === void 0 ? void 0 : _a2.case) === "speaker") {
            this.emit(EngineEvent.ActiveSpeakersUpdate, dp.value.value.speakers);
          } else {
            if (((_b = dp.value) === null || _b === void 0 ? void 0 : _b.case) === "user") {
              applyUserDataCompat(dp, dp.value.value);
            }
            this.emit(EngineEvent.DataPacketReceived, dp);
          }
        } finally {
          unlock();
        }
      });
      this.handleDataError = (event) => {
        const channel = event.currentTarget;
        const channelKind = channel.maxRetransmits === 0 ? "lossy" : "reliable";
        if (event instanceof ErrorEvent && event.error) {
          const {
            error
          } = event.error;
          this.log.error("DataChannel error on ".concat(channelKind, ": ").concat(event.message), Object.assign(Object.assign({}, this.logContext), {
            error
          }));
        } else {
          this.log.error("Unknown DataChannel error on ".concat(channelKind), Object.assign(Object.assign({}, this.logContext), {
            event
          }));
        }
      };
      this.handleBufferedAmountLow = (event) => {
        const channel = event.currentTarget;
        const channelKind = channel.maxRetransmits === 0 ? DataPacket_Kind.LOSSY : DataPacket_Kind.RELIABLE;
        this.updateAndEmitDCBufferStatus(channelKind);
      };
      this.handleDisconnect = (connection, disconnectReason) => {
        if (this._isClosed) {
          return;
        }
        this.log.warn("".concat(connection, " disconnected"), this.logContext);
        if (this.reconnectAttempts === 0) {
          this.reconnectStart = Date.now();
        }
        const disconnect = (duration2) => {
          this.log.warn("could not recover connection after ".concat(this.reconnectAttempts, " attempts, ").concat(duration2, "ms. giving up"), this.logContext);
          this.emit(EngineEvent.Disconnected);
          this.close();
        };
        const duration = Date.now() - this.reconnectStart;
        let delay = this.getNextRetryDelay({
          elapsedMs: duration,
          retryCount: this.reconnectAttempts
        });
        if (delay === null) {
          disconnect(duration);
          return;
        }
        if (connection === leaveReconnect) {
          delay = 0;
        }
        this.log.debug("reconnecting in ".concat(delay, "ms"), this.logContext);
        this.clearReconnectTimeout();
        if (this.token && this.regionUrlProvider) {
          this.regionUrlProvider.updateToken(this.token);
        }
        this.reconnectTimeout = CriticalTimers.setTimeout(() => this.attemptReconnect(disconnectReason).finally(() => this.reconnectTimeout = void 0), delay);
      };
      this.waitForRestarted = () => {
        return new Promise((resolve, reject) => {
          if (this.pcState === PCState.Connected) {
            resolve();
          }
          const onRestarted = () => {
            this.off(EngineEvent.Disconnected, onDisconnected);
            resolve();
          };
          const onDisconnected = () => {
            this.off(EngineEvent.Restarted, onRestarted);
            reject();
          };
          this.once(EngineEvent.Restarted, onRestarted);
          this.once(EngineEvent.Disconnected, onDisconnected);
        });
      };
      this.updateAndEmitDCBufferStatus = (kind) => {
        const status = this.isBufferStatusLow(kind);
        if (typeof status !== "undefined" && status !== this.dcBufferStatus.get(kind)) {
          this.dcBufferStatus.set(kind, status);
          this.emit(EngineEvent.DCBufferStatusChanged, status, kind);
        }
      };
      this.isBufferStatusLow = (kind) => {
        const dc = this.dataChannelForKind(kind);
        if (dc) {
          return dc.bufferedAmount <= dc.bufferedAmountLowThreshold;
        }
      };
      this.handleBrowserOnLine = () => {
        if (this.client.currentState === SignalConnectionState.RECONNECTING) {
          this.clearReconnectTimeout();
          this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED);
        }
      };
      this.log = getLogger((_a = options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Engine);
      this.loggerOptions = {
        loggerName: options.loggerName,
        loggerContextCb: () => this.logContext
      };
      this.client = new SignalClient(void 0, this.loggerOptions);
      this.client.signalLatency = this.options.expSignalLatency;
      this.reconnectPolicy = this.options.reconnectPolicy;
      this.registerOnLineListener();
      this.closingLock = new h();
      this.dataProcessLock = new h();
      this.dcBufferStatus = /* @__PURE__ */ new Map([[DataPacket_Kind.LOSSY, true], [DataPacket_Kind.RELIABLE, true]]);
      this.client.onParticipantUpdate = (updates) => this.emit(EngineEvent.ParticipantUpdate, updates);
      this.client.onConnectionQuality = (update) => this.emit(EngineEvent.ConnectionQualityUpdate, update);
      this.client.onRoomUpdate = (update) => this.emit(EngineEvent.RoomUpdate, update);
      this.client.onSubscriptionError = (resp) => this.emit(EngineEvent.SubscriptionError, resp);
      this.client.onSubscriptionPermissionUpdate = (update) => this.emit(EngineEvent.SubscriptionPermissionUpdate, update);
      this.client.onSpeakersChanged = (update) => this.emit(EngineEvent.SpeakersChanged, update);
      this.client.onStreamStateUpdate = (update) => this.emit(EngineEvent.StreamStateChanged, update);
      this.client.onRequestResponse = (response) => this.emit(EngineEvent.SignalRequestResponse, response);
    }
    /** @internal */
    get logContext() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      return {
        room: (_b = (_a = this.latestJoinResponse) === null || _a === void 0 ? void 0 : _a.room) === null || _b === void 0 ? void 0 : _b.name,
        roomID: (_d = (_c = this.latestJoinResponse) === null || _c === void 0 ? void 0 : _c.room) === null || _d === void 0 ? void 0 : _d.sid,
        participant: (_f = (_e = this.latestJoinResponse) === null || _e === void 0 ? void 0 : _e.participant) === null || _f === void 0 ? void 0 : _f.identity,
        pID: (_h = (_g = this.latestJoinResponse) === null || _g === void 0 ? void 0 : _g.participant) === null || _h === void 0 ? void 0 : _h.sid
      };
    }
    join(url2, token, opts, abortSignal) {
      return __awaiter(this, void 0, void 0, function* () {
        this.url = url2;
        this.token = token;
        this.signalOpts = opts;
        this.maxJoinAttempts = opts.maxRetries;
        try {
          this.joinAttempts += 1;
          this.setupSignalClientCallbacks();
          const joinResponse = yield this.client.join(url2, token, opts, abortSignal);
          this._isClosed = false;
          this.latestJoinResponse = joinResponse;
          this.subscriberPrimary = joinResponse.subscriberPrimary;
          if (!this.pcManager) {
            yield this.configure(joinResponse);
          }
          if (!this.subscriberPrimary || joinResponse.fastPublish) {
            this.negotiate();
          }
          this.clientConfiguration = joinResponse.clientConfiguration;
          return joinResponse;
        } catch (e) {
          if (e instanceof ConnectionError) {
            if (e.reason === ConnectionErrorReason.ServerUnreachable) {
              this.log.warn("Couldn't connect to server, attempt ".concat(this.joinAttempts, " of ").concat(this.maxJoinAttempts), this.logContext);
              if (this.joinAttempts < this.maxJoinAttempts) {
                return this.join(url2, token, opts, abortSignal);
              }
            }
          }
          throw e;
        }
      });
    }
    close() {
      return __awaiter(this, void 0, void 0, function* () {
        const unlock = yield this.closingLock.lock();
        if (this.isClosed) {
          unlock();
          return;
        }
        try {
          this._isClosed = true;
          this.joinAttempts = 0;
          this.emit(EngineEvent.Closing);
          this.removeAllListeners();
          this.deregisterOnLineListener();
          this.clearPendingReconnect();
          yield this.cleanupPeerConnections();
          yield this.cleanupClient();
        } finally {
          unlock();
        }
      });
    }
    cleanupPeerConnections() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        yield (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.close();
        this.pcManager = void 0;
        const dcCleanup = (dc) => {
          if (!dc) return;
          dc.close();
          dc.onbufferedamountlow = null;
          dc.onclose = null;
          dc.onclosing = null;
          dc.onerror = null;
          dc.onmessage = null;
          dc.onopen = null;
        };
        dcCleanup(this.lossyDC);
        dcCleanup(this.lossyDCSub);
        dcCleanup(this.reliableDC);
        dcCleanup(this.reliableDCSub);
        this.lossyDC = void 0;
        this.lossyDCSub = void 0;
        this.reliableDC = void 0;
        this.reliableDCSub = void 0;
      });
    }
    cleanupClient() {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.client.close();
        this.client.resetCallbacks();
      });
    }
    addTrack(req) {
      if (this.pendingTrackResolvers[req.cid]) {
        throw new TrackInvalidError("a track with the same ID has already been published");
      }
      return new Promise((resolve, reject) => {
        const publicationTimeout = setTimeout(() => {
          delete this.pendingTrackResolvers[req.cid];
          reject(new ConnectionError("publication of local track timed out, no response from server", ConnectionErrorReason.InternalError));
        }, 1e4);
        this.pendingTrackResolvers[req.cid] = {
          resolve: (info) => {
            clearTimeout(publicationTimeout);
            resolve(info);
          },
          reject: () => {
            clearTimeout(publicationTimeout);
            reject(new Error("Cancelled publication by calling unpublish"));
          }
        };
        this.client.sendAddTrack(req);
      });
    }
    /**
     * Removes sender from PeerConnection, returning true if it was removed successfully
     * and a negotiation is necessary
     * @param sender
     * @returns
     */
    removeTrack(sender) {
      if (sender.track && this.pendingTrackResolvers[sender.track.id]) {
        const {
          reject
        } = this.pendingTrackResolvers[sender.track.id];
        if (reject) {
          reject();
        }
        delete this.pendingTrackResolvers[sender.track.id];
      }
      try {
        this.pcManager.removeTrack(sender);
        return true;
      } catch (e) {
        this.log.warn("failed to remove track", Object.assign(Object.assign({}, this.logContext), {
          error: e
        }));
      }
      return false;
    }
    updateMuteStatus(trackSid, muted) {
      this.client.sendMuteTrack(trackSid, muted);
    }
    get dataSubscriberReadyState() {
      var _a;
      return (_a = this.reliableDCSub) === null || _a === void 0 ? void 0 : _a.readyState;
    }
    getConnectedServerAddress() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        return (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.getConnectedAddress();
      });
    }
    /* @internal */
    setRegionUrlProvider(provider) {
      this.regionUrlProvider = provider;
    }
    configure(joinResponse) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        if (this.pcManager && this.pcManager.currentState !== PCTransportState.NEW) {
          return;
        }
        this.participantSid = (_a = joinResponse.participant) === null || _a === void 0 ? void 0 : _a.sid;
        const rtcConfig = this.makeRTCConfiguration(joinResponse);
        this.pcManager = new PCTransportManager(rtcConfig, joinResponse.subscriberPrimary, this.loggerOptions);
        this.emit(EngineEvent.TransportsCreated, this.pcManager.publisher, this.pcManager.subscriber);
        this.pcManager.onIceCandidate = (candidate, target) => {
          this.client.sendIceCandidate(candidate, target);
        };
        this.pcManager.onPublisherOffer = (offer) => {
          this.client.sendOffer(offer);
        };
        this.pcManager.onDataChannel = this.handleDataChannel;
        this.pcManager.onStateChange = (connectionState, publisherState, subscriberState) => __awaiter(this, void 0, void 0, function* () {
          this.log.debug("primary PC state changed ".concat(connectionState), this.logContext);
          if (["closed", "disconnected", "failed"].includes(publisherState)) {
            this.publisherConnectionPromise = void 0;
          }
          if (connectionState === PCTransportState.CONNECTED) {
            const shouldEmit = this.pcState === PCState.New;
            this.pcState = PCState.Connected;
            if (shouldEmit) {
              this.emit(EngineEvent.Connected, joinResponse);
            }
          } else if (connectionState === PCTransportState.FAILED) {
            if (this.pcState === PCState.Connected) {
              this.pcState = PCState.Disconnected;
              this.handleDisconnect("peerconnection failed", subscriberState === "failed" ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED);
            }
          }
          const isSignalSevered = this.client.isDisconnected || this.client.currentState === SignalConnectionState.RECONNECTING;
          const isPCSevered = [PCTransportState.FAILED, PCTransportState.CLOSING, PCTransportState.CLOSED].includes(connectionState);
          if (isSignalSevered && isPCSevered && !this._isClosed) {
            this.emit(EngineEvent.Offline);
          }
        });
        this.pcManager.onTrack = (ev) => {
          this.emit(EngineEvent.MediaTrackAdded, ev.track, ev.streams[0], ev.receiver);
        };
        if (!supportOptionalDatachannel((_b = joinResponse.serverInfo) === null || _b === void 0 ? void 0 : _b.protocol)) {
          this.createDataChannels();
        }
      });
    }
    setupSignalClientCallbacks() {
      this.client.onAnswer = (sd) => __awaiter(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          return;
        }
        this.log.debug("received server answer", Object.assign(Object.assign({}, this.logContext), {
          RTCSdpType: sd.type
        }));
        yield this.pcManager.setPublisherAnswer(sd);
      });
      this.client.onTrickle = (candidate, target) => {
        if (!this.pcManager) {
          return;
        }
        this.log.trace("got ICE candidate from peer", Object.assign(Object.assign({}, this.logContext), {
          candidate,
          target
        }));
        this.pcManager.addIceCandidate(candidate, target);
      };
      this.client.onOffer = (sd) => __awaiter(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          return;
        }
        const answer = yield this.pcManager.createSubscriberAnswerFromOffer(sd);
        this.client.sendAnswer(answer);
      });
      this.client.onLocalTrackPublished = (res) => {
        var _a;
        this.log.debug("received trackPublishedResponse", Object.assign(Object.assign({}, this.logContext), {
          cid: res.cid,
          track: (_a = res.track) === null || _a === void 0 ? void 0 : _a.sid
        }));
        if (!this.pendingTrackResolvers[res.cid]) {
          this.log.error("missing track resolver for ".concat(res.cid), Object.assign(Object.assign({}, this.logContext), {
            cid: res.cid
          }));
          return;
        }
        const {
          resolve
        } = this.pendingTrackResolvers[res.cid];
        delete this.pendingTrackResolvers[res.cid];
        resolve(res.track);
      };
      this.client.onLocalTrackUnpublished = (response) => {
        this.emit(EngineEvent.LocalTrackUnpublished, response);
      };
      this.client.onLocalTrackSubscribed = (trackSid) => {
        this.emit(EngineEvent.LocalTrackSubscribed, trackSid);
      };
      this.client.onTokenRefresh = (token) => {
        this.token = token;
      };
      this.client.onRemoteMuteChanged = (trackSid, muted) => {
        this.emit(EngineEvent.RemoteMute, trackSid, muted);
      };
      this.client.onSubscribedQualityUpdate = (update) => {
        this.emit(EngineEvent.SubscribedQualityUpdate, update);
      };
      this.client.onClose = () => {
        this.handleDisconnect("signal", ReconnectReason.RR_SIGNAL_DISCONNECTED);
      };
      this.client.onLeave = (leave) => {
        this.log.debug("client leave request", Object.assign(Object.assign({}, this.logContext), {
          reason: leave === null || leave === void 0 ? void 0 : leave.reason
        }));
        if (leave.regions && this.regionUrlProvider) {
          this.log.debug("updating regions", this.logContext);
          this.regionUrlProvider.setServerReportedRegions(leave.regions);
        }
        switch (leave.action) {
          case LeaveRequest_Action.DISCONNECT:
            this.emit(EngineEvent.Disconnected, leave === null || leave === void 0 ? void 0 : leave.reason);
            this.close();
            break;
          case LeaveRequest_Action.RECONNECT:
            this.fullReconnectOnNext = true;
            this.handleDisconnect(leaveReconnect);
            break;
          case LeaveRequest_Action.RESUME:
            this.handleDisconnect(leaveReconnect);
        }
      };
    }
    makeRTCConfiguration(serverResponse) {
      var _a;
      const rtcConfig = Object.assign({}, this.rtcConfig);
      if ((_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.e2eeEnabled) {
        this.log.debug("E2EE - setting up transports with insertable streams", this.logContext);
        rtcConfig.encodedInsertableStreams = true;
      }
      if (serverResponse.iceServers && !rtcConfig.iceServers) {
        const rtcIceServers = [];
        serverResponse.iceServers.forEach((iceServer) => {
          const rtcIceServer = {
            urls: iceServer.urls
          };
          if (iceServer.username) rtcIceServer.username = iceServer.username;
          if (iceServer.credential) {
            rtcIceServer.credential = iceServer.credential;
          }
          rtcIceServers.push(rtcIceServer);
        });
        rtcConfig.iceServers = rtcIceServers;
      }
      if (serverResponse.clientConfiguration && serverResponse.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED) {
        rtcConfig.iceTransportPolicy = "relay";
      }
      rtcConfig.sdpSemantics = "unified-plan";
      rtcConfig.continualGatheringPolicy = "gather_continually";
      return rtcConfig;
    }
    createDataChannels() {
      if (!this.pcManager) {
        return;
      }
      if (this.lossyDC) {
        this.lossyDC.onmessage = null;
        this.lossyDC.onerror = null;
      }
      if (this.reliableDC) {
        this.reliableDC.onmessage = null;
        this.reliableDC.onerror = null;
      }
      this.lossyDC = this.pcManager.createPublisherDataChannel(lossyDataChannel, {
        // will drop older packets that arrive
        ordered: true,
        maxRetransmits: 0
      });
      this.reliableDC = this.pcManager.createPublisherDataChannel(reliableDataChannel, {
        ordered: true
      });
      this.lossyDC.onmessage = this.handleDataMessage;
      this.reliableDC.onmessage = this.handleDataMessage;
      this.lossyDC.onerror = this.handleDataError;
      this.reliableDC.onerror = this.handleDataError;
      this.lossyDC.bufferedAmountLowThreshold = 65535;
      this.reliableDC.bufferedAmountLowThreshold = 65535;
      this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow;
      this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow;
    }
    createSender(track, opts, encodings) {
      return __awaiter(this, void 0, void 0, function* () {
        if (supportsTransceiver()) {
          const sender = yield this.createTransceiverRTCRtpSender(track, opts, encodings);
          return sender;
        }
        if (supportsAddTrack()) {
          this.log.warn("using add-track fallback", this.logContext);
          const sender = yield this.createRTCRtpSender(track.mediaStreamTrack);
          return sender;
        }
        throw new UnexpectedConnectionState("Required webRTC APIs not supported on this device");
      });
    }
    createSimulcastSender(track, simulcastTrack, opts, encodings) {
      return __awaiter(this, void 0, void 0, function* () {
        if (supportsTransceiver()) {
          return this.createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings);
        }
        if (supportsAddTrack()) {
          this.log.debug("using add-track fallback", this.logContext);
          return this.createRTCRtpSender(track.mediaStreamTrack);
        }
        throw new UnexpectedConnectionState("Cannot stream on this device");
      });
    }
    createTransceiverRTCRtpSender(track, opts, encodings) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          throw new UnexpectedConnectionState("publisher is closed");
        }
        const streams = [];
        if (track.mediaStream) {
          streams.push(track.mediaStream);
        }
        if (track instanceof LocalVideoTrack) {
          track.codec = opts.videoCodec;
        }
        const transceiverInit = {
          direction: "sendonly",
          streams
        };
        if (encodings) {
          transceiverInit.sendEncodings = encodings;
        }
        const transceiver = yield this.pcManager.addPublisherTransceiver(track.mediaStreamTrack, transceiverInit);
        return transceiver.sender;
      });
    }
    createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          throw new UnexpectedConnectionState("publisher is closed");
        }
        const transceiverInit = {
          direction: "sendonly"
        };
        if (encodings) {
          transceiverInit.sendEncodings = encodings;
        }
        const transceiver = yield this.pcManager.addPublisherTransceiver(simulcastTrack.mediaStreamTrack, transceiverInit);
        if (!opts.videoCodec) {
          return;
        }
        track.setSimulcastTrackSender(opts.videoCodec, transceiver.sender);
        return transceiver.sender;
      });
    }
    createRTCRtpSender(track) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          throw new UnexpectedConnectionState("publisher is closed");
        }
        return this.pcManager.addPublisherTrack(track);
      });
    }
    attemptReconnect(reason) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c;
        if (this._isClosed) {
          return;
        }
        if (this.attemptingReconnect) {
          livekitLogger.warn("already attempting reconnect, returning early", this.logContext);
          return;
        }
        if (((_a = this.clientConfiguration) === null || _a === void 0 ? void 0 : _a.resumeConnection) === ClientConfigSetting.DISABLED || // signaling state could change to closed due to hardware sleep
        // those connections cannot be resumed
        ((_c = (_b = this.pcManager) === null || _b === void 0 ? void 0 : _b.currentState) !== null && _c !== void 0 ? _c : PCTransportState.NEW) === PCTransportState.NEW) {
          this.fullReconnectOnNext = true;
        }
        try {
          this.attemptingReconnect = true;
          if (this.fullReconnectOnNext) {
            yield this.restartConnection();
          } else {
            yield this.resumeConnection(reason);
          }
          this.clearPendingReconnect();
          this.fullReconnectOnNext = false;
        } catch (e) {
          this.reconnectAttempts += 1;
          let recoverable = true;
          if (e instanceof UnexpectedConnectionState) {
            this.log.debug("received unrecoverable error", Object.assign(Object.assign({}, this.logContext), {
              error: e
            }));
            recoverable = false;
          } else if (!(e instanceof SignalReconnectError)) {
            this.fullReconnectOnNext = true;
          }
          if (recoverable) {
            this.handleDisconnect("reconnect", ReconnectReason.RR_UNKNOWN);
          } else {
            this.log.info("could not recover connection after ".concat(this.reconnectAttempts, " attempts, ").concat(Date.now() - this.reconnectStart, "ms. giving up"), this.logContext);
            this.emit(EngineEvent.Disconnected);
            yield this.close();
          }
        } finally {
          this.attemptingReconnect = false;
        }
      });
    }
    getNextRetryDelay(context) {
      try {
        return this.reconnectPolicy.nextRetryDelayInMs(context);
      } catch (e) {
        this.log.warn("encountered error in reconnect policy", Object.assign(Object.assign({}, this.logContext), {
          error: e
        }));
      }
      return null;
    }
    restartConnection(regionUrl) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c;
        try {
          if (!this.url || !this.token) {
            throw new UnexpectedConnectionState("could not reconnect, url or token not saved");
          }
          this.log.info("reconnecting, attempt: ".concat(this.reconnectAttempts), this.logContext);
          this.emit(EngineEvent.Restarting);
          if (!this.client.isDisconnected) {
            yield this.client.sendLeave();
          }
          yield this.cleanupPeerConnections();
          yield this.cleanupClient();
          let joinResponse;
          try {
            if (!this.signalOpts) {
              this.log.warn("attempted connection restart, without signal options present", this.logContext);
              throw new SignalReconnectError();
            }
            joinResponse = yield this.join(regionUrl !== null && regionUrl !== void 0 ? regionUrl : this.url, this.token, this.signalOpts);
          } catch (e) {
            if (e instanceof ConnectionError && e.reason === ConnectionErrorReason.NotAllowed) {
              throw new UnexpectedConnectionState("could not reconnect, token might be expired");
            }
            throw new SignalReconnectError();
          }
          if (this.shouldFailNext) {
            this.shouldFailNext = false;
            throw new Error("simulated failure");
          }
          this.client.setReconnected();
          this.emit(EngineEvent.SignalRestarted, joinResponse);
          yield this.waitForPCReconnected();
          if (this.client.currentState !== SignalConnectionState.CONNECTED) {
            throw new SignalReconnectError("Signal connection got severed during reconnect");
          }
          (_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.resetAttempts();
          this.emit(EngineEvent.Restarted);
        } catch (error) {
          const nextRegionUrl = yield (_b = this.regionUrlProvider) === null || _b === void 0 ? void 0 : _b.getNextBestRegionUrl();
          if (nextRegionUrl) {
            yield this.restartConnection(nextRegionUrl);
            return;
          } else {
            (_c = this.regionUrlProvider) === null || _c === void 0 ? void 0 : _c.resetAttempts();
            throw error;
          }
        }
      });
    }
    resumeConnection(reason) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!this.url || !this.token) {
          throw new UnexpectedConnectionState("could not reconnect, url or token not saved");
        }
        if (!this.pcManager) {
          throw new UnexpectedConnectionState("publisher and subscriber connections unset");
        }
        this.log.info("resuming signal connection, attempt ".concat(this.reconnectAttempts), this.logContext);
        this.emit(EngineEvent.Resuming);
        let res;
        try {
          this.setupSignalClientCallbacks();
          res = yield this.client.reconnect(this.url, this.token, this.participantSid, reason);
        } catch (error) {
          let message = "";
          if (error instanceof Error) {
            message = error.message;
            this.log.error(error.message, Object.assign(Object.assign({}, this.logContext), {
              error
            }));
          }
          if (error instanceof ConnectionError && error.reason === ConnectionErrorReason.NotAllowed) {
            throw new UnexpectedConnectionState("could not reconnect, token might be expired");
          }
          if (error instanceof ConnectionError && error.reason === ConnectionErrorReason.LeaveRequest) {
            throw error;
          }
          throw new SignalReconnectError(message);
        }
        this.emit(EngineEvent.SignalResumed);
        if (res) {
          const rtcConfig = this.makeRTCConfiguration(res);
          this.pcManager.updateConfiguration(rtcConfig);
        } else {
          this.log.warn("Did not receive reconnect response", this.logContext);
        }
        if (this.shouldFailNext) {
          this.shouldFailNext = false;
          throw new Error("simulated failure");
        }
        yield this.pcManager.triggerIceRestart();
        yield this.waitForPCReconnected();
        if (this.client.currentState !== SignalConnectionState.CONNECTED) {
          throw new SignalReconnectError("Signal connection got severed during reconnect");
        }
        this.client.setReconnected();
        if (((_a = this.reliableDC) === null || _a === void 0 ? void 0 : _a.readyState) === "open" && this.reliableDC.id === null) {
          this.createDataChannels();
        }
        this.emit(EngineEvent.Resumed);
      });
    }
    waitForPCInitialConnection(timeout, abortController) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          throw new UnexpectedConnectionState("PC manager is closed");
        }
        yield this.pcManager.ensurePCTransportConnection(abortController, timeout);
      });
    }
    waitForPCReconnected() {
      return __awaiter(this, void 0, void 0, function* () {
        this.pcState = PCState.Reconnecting;
        this.log.debug("waiting for peer connection to reconnect", this.logContext);
        try {
          yield sleep(minReconnectWait);
          if (!this.pcManager) {
            throw new UnexpectedConnectionState("PC manager is closed");
          }
          yield this.pcManager.ensurePCTransportConnection(void 0, this.peerConnectionTimeout);
          this.pcState = PCState.Connected;
        } catch (e) {
          this.pcState = PCState.Disconnected;
          throw new ConnectionError("could not establish PC connection, ".concat(e.message), ConnectionErrorReason.InternalError);
        }
      });
    }
    /* @internal */
    sendDataPacket(packet, kind) {
      return __awaiter(this, void 0, void 0, function* () {
        const msg = packet.toBinary();
        yield this.ensurePublisherConnected(kind);
        const dc = this.dataChannelForKind(kind);
        if (dc) {
          dc.send(msg);
        }
        this.updateAndEmitDCBufferStatus(kind);
      });
    }
    /**
     * @internal
     */
    ensureDataTransportConnected(kind_1) {
      return __awaiter(this, arguments, void 0, function(kind) {
        var _this2 = this;
        let subscriber = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.subscriberPrimary;
        return function* () {
          var _a;
          if (!_this2.pcManager) {
            throw new UnexpectedConnectionState("PC manager is closed");
          }
          const transport = subscriber ? _this2.pcManager.subscriber : _this2.pcManager.publisher;
          const transportName = subscriber ? "Subscriber" : "Publisher";
          if (!transport) {
            throw new ConnectionError("".concat(transportName, " connection not set"), ConnectionErrorReason.InternalError);
          }
          let needNegotiation = false;
          if (!subscriber && !_this2.dataChannelForKind(kind, subscriber)) {
            _this2.createDataChannels();
            needNegotiation = true;
          }
          if (!needNegotiation && !subscriber && !_this2.pcManager.publisher.isICEConnected && _this2.pcManager.publisher.getICEConnectionState() !== "checking") {
            needNegotiation = true;
          }
          if (needNegotiation) {
            _this2.negotiate();
          }
          const targetChannel = _this2.dataChannelForKind(kind, subscriber);
          if ((targetChannel === null || targetChannel === void 0 ? void 0 : targetChannel.readyState) === "open") {
            return;
          }
          const endTime = (/* @__PURE__ */ new Date()).getTime() + _this2.peerConnectionTimeout;
          while ((/* @__PURE__ */ new Date()).getTime() < endTime) {
            if (transport.isICEConnected && ((_a = _this2.dataChannelForKind(kind, subscriber)) === null || _a === void 0 ? void 0 : _a.readyState) === "open") {
              return;
            }
            yield sleep(50);
          }
          throw new ConnectionError("could not establish ".concat(transportName, " connection, state: ").concat(transport.getICEConnectionState()), ConnectionErrorReason.InternalError);
        }();
      });
    }
    ensurePublisherConnected(kind) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.publisherConnectionPromise) {
          this.publisherConnectionPromise = this.ensureDataTransportConnected(kind, false);
        }
        yield this.publisherConnectionPromise;
      });
    }
    /* @internal */
    verifyTransport() {
      if (!this.pcManager) {
        return false;
      }
      if (this.pcManager.currentState !== PCTransportState.CONNECTED) {
        return false;
      }
      if (!this.client.ws || this.client.ws.readyState === WebSocket.CLOSED) {
        return false;
      }
      return true;
    }
    /** @internal */
    negotiate() {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
          if (!this.pcManager) {
            reject(new NegotiationError("PC manager is closed"));
            return;
          }
          this.pcManager.requirePublisher();
          if (this.pcManager.publisher.getTransceivers().length == 0 && !this.lossyDC && !this.reliableDC) {
            this.createDataChannels();
          }
          const abortController = new AbortController();
          const handleClosed = () => {
            abortController.abort();
            this.log.debug("engine disconnected while negotiation was ongoing", this.logContext);
            resolve();
            return;
          };
          if (this.isClosed) {
            reject("cannot negotiate on closed engine");
          }
          this.on(EngineEvent.Closing, handleClosed);
          this.pcManager.publisher.once(PCEvents.RTPVideoPayloadTypes, (rtpTypes) => {
            const rtpMap = /* @__PURE__ */ new Map();
            rtpTypes.forEach((rtp) => {
              const codec = rtp.codec.toLowerCase();
              if (isVideoCodec(codec)) {
                rtpMap.set(rtp.payload, codec);
              }
            });
            this.emit(EngineEvent.RTPVideoMapUpdate, rtpMap);
          });
          try {
            yield this.pcManager.negotiate(abortController);
            resolve();
          } catch (e) {
            if (e instanceof NegotiationError) {
              this.fullReconnectOnNext = true;
            }
            this.handleDisconnect("negotiation", ReconnectReason.RR_UNKNOWN);
            reject(e);
          } finally {
            this.off(EngineEvent.Closing, handleClosed);
          }
        }));
      });
    }
    dataChannelForKind(kind, sub) {
      if (!sub) {
        if (kind === DataPacket_Kind.LOSSY) {
          return this.lossyDC;
        }
        if (kind === DataPacket_Kind.RELIABLE) {
          return this.reliableDC;
        }
      } else {
        if (kind === DataPacket_Kind.LOSSY) {
          return this.lossyDCSub;
        }
        if (kind === DataPacket_Kind.RELIABLE) {
          return this.reliableDCSub;
        }
      }
    }
    /** @internal */
    sendSyncState(remoteTracks, localTracks) {
      var _a, _b;
      if (!this.pcManager) {
        this.log.warn("sync state cannot be sent without peer connection setup", this.logContext);
        return;
      }
      const previousAnswer = this.pcManager.subscriber.getLocalDescription();
      const previousOffer = this.pcManager.subscriber.getRemoteDescription();
      const autoSubscribe = (_b = (_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.autoSubscribe) !== null && _b !== void 0 ? _b : true;
      const trackSids = new Array();
      const trackSidsDisabled = new Array();
      remoteTracks.forEach((track) => {
        if (track.isDesired !== autoSubscribe) {
          trackSids.push(track.trackSid);
        }
        if (!track.isEnabled) {
          trackSidsDisabled.push(track.trackSid);
        }
      });
      this.client.sendSyncState(new SyncState({
        answer: previousAnswer ? toProtoSessionDescription({
          sdp: previousAnswer.sdp,
          type: previousAnswer.type
        }) : void 0,
        offer: previousOffer ? toProtoSessionDescription({
          sdp: previousOffer.sdp,
          type: previousOffer.type
        }) : void 0,
        subscription: new UpdateSubscription({
          trackSids,
          subscribe: !autoSubscribe,
          participantTracks: []
        }),
        publishTracks: getTrackPublicationInfo(localTracks),
        dataChannels: this.dataChannelsInfo(),
        trackSidsDisabled
      }));
    }
    /* @internal */
    failNext() {
      this.shouldFailNext = true;
    }
    dataChannelsInfo() {
      const infos = [];
      const getInfo = (dc, target) => {
        if ((dc === null || dc === void 0 ? void 0 : dc.id) !== void 0 && dc.id !== null) {
          infos.push(new DataChannelInfo({
            label: dc.label,
            id: dc.id,
            target
          }));
        }
      };
      getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER);
      getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE), SignalTarget.PUBLISHER);
      getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY, true), SignalTarget.SUBSCRIBER);
      getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE, true), SignalTarget.SUBSCRIBER);
      return infos;
    }
    clearReconnectTimeout() {
      if (this.reconnectTimeout) {
        CriticalTimers.clearTimeout(this.reconnectTimeout);
      }
    }
    clearPendingReconnect() {
      this.clearReconnectTimeout();
      this.reconnectAttempts = 0;
    }
    registerOnLineListener() {
      if (isWeb()) {
        window.addEventListener("online", this.handleBrowserOnLine);
      }
    }
    deregisterOnLineListener() {
      if (isWeb()) {
        window.removeEventListener("online", this.handleBrowserOnLine);
      }
    }
  };
  var SignalReconnectError = class extends Error {
  };
  function supportOptionalDatachannel(protocol) {
    return protocol !== void 0 && protocol > 13;
  }
  function applyUserDataCompat(newObj, oldObj) {
    const participantIdentity = newObj.participantIdentity ? newObj.participantIdentity : oldObj.participantIdentity;
    newObj.participantIdentity = participantIdentity;
    oldObj.participantIdentity = participantIdentity;
    const destinationIdentities = newObj.destinationIdentities.length !== 0 ? newObj.destinationIdentities : oldObj.destinationIdentities;
    newObj.destinationIdentities = destinationIdentities;
    oldObj.destinationIdentities = destinationIdentities;
  }
  var RegionUrlProvider = class {
    constructor(url2, token) {
      this.lastUpdateAt = 0;
      this.settingsCacheTime = 3e3;
      this.attemptedRegions = [];
      this.serverUrl = new URL(url2);
      this.token = token;
    }
    updateToken(token) {
      this.token = token;
    }
    isCloud() {
      return isCloud(this.serverUrl);
    }
    getServerUrl() {
      return this.serverUrl;
    }
    getNextBestRegionUrl(abortSignal) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.isCloud()) {
          throw Error("region availability is only supported for LiveKit Cloud domains");
        }
        if (!this.regionSettings || Date.now() - this.lastUpdateAt > this.settingsCacheTime) {
          this.regionSettings = yield this.fetchRegionSettings(abortSignal);
        }
        const regionsLeft = this.regionSettings.regions.filter((region) => !this.attemptedRegions.find((attempted) => attempted.url === region.url));
        if (regionsLeft.length > 0) {
          const nextRegion = regionsLeft[0];
          this.attemptedRegions.push(nextRegion);
          livekitLogger.debug("next region: ".concat(nextRegion.region));
          return nextRegion.url;
        } else {
          return null;
        }
      });
    }
    resetAttempts() {
      this.attemptedRegions = [];
    }
    /* @internal */
    fetchRegionSettings(signal) {
      return __awaiter(this, void 0, void 0, function* () {
        const regionSettingsResponse = yield fetch("".concat(getCloudConfigUrl(this.serverUrl), "/regions"), {
          headers: {
            authorization: "Bearer ".concat(this.token)
          },
          signal
        });
        if (regionSettingsResponse.ok) {
          const regionSettings = yield regionSettingsResponse.json();
          this.lastUpdateAt = Date.now();
          return regionSettings;
        } else {
          throw new ConnectionError("Could not fetch region settings: ".concat(regionSettingsResponse.statusText), regionSettingsResponse.status === 401 ? ConnectionErrorReason.NotAllowed : ConnectionErrorReason.InternalError, regionSettingsResponse.status);
        }
      });
    }
    setServerReportedRegions(regions) {
      this.regionSettings = regions;
      this.lastUpdateAt = Date.now();
    }
  };
  function getCloudConfigUrl(serverUrl) {
    return "".concat(serverUrl.protocol.replace("ws", "http"), "//").concat(serverUrl.host, "/settings");
  }
  var RpcError = class _RpcError extends Error {
    /**
     * Creates an error object with the given code and message, plus an optional data payload.
     *
     * If thrown in an RPC method handler, the error will be sent back to the caller.
     *
     * Error codes 1001-1999 are reserved for built-in errors (see RpcError.ErrorCode for their meanings).
     */
    constructor(code, message, data) {
      super(message);
      this.code = code;
      this.message = truncateBytes(message, _RpcError.MAX_MESSAGE_BYTES);
      this.data = data ? truncateBytes(data, _RpcError.MAX_DATA_BYTES) : void 0;
    }
    /**
     * @internal
     */
    static fromProto(proto) {
      return new _RpcError(proto.code, proto.message, proto.data);
    }
    /**
     * @internal
     */
    toProto() {
      return new RpcError$1({
        code: this.code,
        message: this.message,
        data: this.data
      });
    }
    /**
     * Creates an error object from the code, with an auto-populated message.
     *
     * @internal
     */
    static builtIn(key, data) {
      return new _RpcError(_RpcError.ErrorCode[key], _RpcError.ErrorMessage[key], data);
    }
  };
  RpcError.MAX_MESSAGE_BYTES = 256;
  RpcError.MAX_DATA_BYTES = 15360;
  RpcError.ErrorCode = {
    APPLICATION_ERROR: 1500,
    CONNECTION_TIMEOUT: 1501,
    RESPONSE_TIMEOUT: 1502,
    RECIPIENT_DISCONNECTED: 1503,
    RESPONSE_PAYLOAD_TOO_LARGE: 1504,
    SEND_FAILED: 1505,
    UNSUPPORTED_METHOD: 1400,
    RECIPIENT_NOT_FOUND: 1401,
    REQUEST_PAYLOAD_TOO_LARGE: 1402,
    UNSUPPORTED_SERVER: 1403,
    UNSUPPORTED_VERSION: 1404
  };
  RpcError.ErrorMessage = {
    APPLICATION_ERROR: "Application error in method handler",
    CONNECTION_TIMEOUT: "Connection timeout",
    RESPONSE_TIMEOUT: "Response timeout",
    RECIPIENT_DISCONNECTED: "Recipient disconnected",
    RESPONSE_PAYLOAD_TOO_LARGE: "Response payload too large",
    SEND_FAILED: "Failed to send",
    UNSUPPORTED_METHOD: "Method not supported at destination",
    RECIPIENT_NOT_FOUND: "Recipient not found",
    REQUEST_PAYLOAD_TOO_LARGE: "Request payload too large",
    UNSUPPORTED_SERVER: "RPC not supported by server",
    UNSUPPORTED_VERSION: "Unsupported RPC version"
  };
  var MAX_PAYLOAD_BYTES = 15360;
  function byteLength(str) {
    const encoder = new TextEncoder();
    return encoder.encode(str).length;
  }
  function truncateBytes(str, maxBytes) {
    if (byteLength(str) <= maxBytes) {
      return str;
    }
    let low = 0;
    let high = str.length;
    const encoder = new TextEncoder();
    while (low < high) {
      const mid = Math.floor((low + high + 1) / 2);
      if (encoder.encode(str.slice(0, mid)).length <= maxBytes) {
        low = mid;
      } else {
        high = mid - 1;
      }
    }
    return str.slice(0, low);
  }
  var RemoteTrack = class extends Track {
    constructor(mediaTrack, sid, kind, receiver, loggerOptions) {
      super(mediaTrack, kind, loggerOptions);
      this.sid = sid;
      this.receiver = receiver;
    }
    /** @internal */
    setMuted(muted) {
      if (this.isMuted !== muted) {
        this.isMuted = muted;
        this._mediaStreamTrack.enabled = !muted;
        this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);
      }
    }
    /** @internal */
    setMediaStream(stream4) {
      this.mediaStream = stream4;
      const onRemoveTrack = (event) => {
        if (event.track === this._mediaStreamTrack) {
          stream4.removeEventListener("removetrack", onRemoveTrack);
          if (this.receiver && "playoutDelayHint" in this.receiver) {
            this.receiver.playoutDelayHint = void 0;
          }
          this.receiver = void 0;
          this._currentBitrate = 0;
          this.emit(TrackEvent.Ended, this);
        }
      };
      stream4.addEventListener("removetrack", onRemoveTrack);
    }
    start() {
      this.startMonitor();
      super.enable();
    }
    stop() {
      this.stopMonitor();
      super.disable();
    }
    /**
     * Gets the RTCStatsReport for the RemoteTrack's underlying RTCRtpReceiver
     * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport
     *
     * @returns Promise<RTCStatsReport> | undefined
     */
    getRTCStatsReport() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!((_a = this.receiver) === null || _a === void 0 ? void 0 : _a.getStats)) {
          return;
        }
        const statsReport = yield this.receiver.getStats();
        return statsReport;
      });
    }
    /**
     * Allows to set a playout delay (in seconds) for this track.
     * A higher value allows for more buffering of the track in the browser
     * and will result in a delay of media being played back of `delayInSeconds`
     */
    setPlayoutDelay(delayInSeconds) {
      if (this.receiver) {
        if ("playoutDelayHint" in this.receiver) {
          this.receiver.playoutDelayHint = delayInSeconds;
        } else {
          this.log.warn("Playout delay not supported in this browser");
        }
      } else {
        this.log.warn("Cannot set playout delay, track already ended");
      }
    }
    /**
     * Returns the current playout delay (in seconds) of this track.
     */
    getPlayoutDelay() {
      if (this.receiver) {
        if ("playoutDelayHint" in this.receiver) {
          return this.receiver.playoutDelayHint;
        } else {
          this.log.warn("Playout delay not supported in this browser");
        }
      } else {
        this.log.warn("Cannot get playout delay, track already ended");
      }
      return 0;
    }
    /* @internal */
    startMonitor() {
      if (!this.monitorInterval) {
        this.monitorInterval = setInterval(() => this.monitorReceiver(), monitorFrequency);
      }
      if (supportsSynchronizationSources()) {
        this.registerTimeSyncUpdate();
      }
    }
    registerTimeSyncUpdate() {
      const loop = () => {
        var _a;
        this.timeSyncHandle = requestAnimationFrame(() => loop());
        const sources = (_a = this.receiver) === null || _a === void 0 ? void 0 : _a.getSynchronizationSources()[0];
        if (sources) {
          const {
            timestamp,
            rtpTimestamp
          } = sources;
          if (rtpTimestamp && this.rtpTimestamp !== rtpTimestamp) {
            this.emit(TrackEvent.TimeSyncUpdate, {
              timestamp,
              rtpTimestamp
            });
            this.rtpTimestamp = rtpTimestamp;
          }
        }
      };
      loop();
    }
  };
  var RemoteAudioTrack = class extends RemoteTrack {
    constructor(mediaTrack, sid, receiver, audioContext, audioOutput, loggerOptions) {
      super(mediaTrack, sid, Track.Kind.Audio, receiver, loggerOptions);
      this.monitorReceiver = () => __awaiter(this, void 0, void 0, function* () {
        if (!this.receiver) {
          this._currentBitrate = 0;
          return;
        }
        const stats = yield this.getReceiverStats();
        if (stats && this.prevStats && this.receiver) {
          this._currentBitrate = computeBitrate(stats, this.prevStats);
        }
        this.prevStats = stats;
      });
      this.audioContext = audioContext;
      this.webAudioPluginNodes = [];
      if (audioOutput) {
        this.sinkId = audioOutput.deviceId;
      }
    }
    /**
     * sets the volume for all attached audio elements
     */
    setVolume(volume) {
      var _a;
      for (const el of this.attachedElements) {
        if (this.audioContext) {
          (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.gain.setTargetAtTime(volume, 0, 0.1);
        } else {
          el.volume = volume;
        }
      }
      if (isReactNative()) {
        this._mediaStreamTrack._setVolume(volume);
      }
      this.elementVolume = volume;
    }
    /**
     * gets the volume of attached audio elements (loudest)
     */
    getVolume() {
      if (this.elementVolume) {
        return this.elementVolume;
      }
      if (isReactNative()) {
        return 1;
      }
      let highestVolume = 0;
      this.attachedElements.forEach((element) => {
        if (element.volume > highestVolume) {
          highestVolume = element.volume;
        }
      });
      return highestVolume;
    }
    /**
     * calls setSinkId on all attached elements, if supported
     * @param deviceId audio output device
     */
    setSinkId(deviceId) {
      return __awaiter(this, void 0, void 0, function* () {
        this.sinkId = deviceId;
        yield Promise.all(this.attachedElements.map((elm) => {
          if (!supportsSetSinkId(elm)) {
            return;
          }
          return elm.setSinkId(deviceId);
        }));
      });
    }
    attach(element) {
      const needsNewWebAudioConnection = this.attachedElements.length === 0;
      if (!element) {
        element = super.attach();
      } else {
        super.attach(element);
      }
      if (this.sinkId && supportsSetSinkId(element)) {
        element.setSinkId(this.sinkId);
      }
      if (this.audioContext && needsNewWebAudioConnection) {
        this.log.debug("using audio context mapping", this.logContext);
        this.connectWebAudio(this.audioContext, element);
        element.volume = 0;
        element.muted = true;
      }
      if (this.elementVolume) {
        this.setVolume(this.elementVolume);
      }
      return element;
    }
    detach(element) {
      let detached;
      if (!element) {
        detached = super.detach();
        this.disconnectWebAudio();
      } else {
        detached = super.detach(element);
        if (this.audioContext) {
          if (this.attachedElements.length > 0) {
            this.connectWebAudio(this.audioContext, this.attachedElements[0]);
          } else {
            this.disconnectWebAudio();
          }
        }
      }
      return detached;
    }
    /**
     * @internal
     * @experimental
     */
    setAudioContext(audioContext) {
      this.audioContext = audioContext;
      if (audioContext && this.attachedElements.length > 0) {
        this.connectWebAudio(audioContext, this.attachedElements[0]);
      } else if (!audioContext) {
        this.disconnectWebAudio();
      }
    }
    /**
     * @internal
     * @experimental
     * @param {AudioNode[]} nodes - An array of WebAudio nodes. These nodes should not be connected to each other when passed, as the sdk will take care of connecting them in the order of the array.
     */
    setWebAudioPlugins(nodes) {
      this.webAudioPluginNodes = nodes;
      if (this.attachedElements.length > 0 && this.audioContext) {
        this.connectWebAudio(this.audioContext, this.attachedElements[0]);
      }
    }
    connectWebAudio(context, element) {
      this.disconnectWebAudio();
      this.sourceNode = context.createMediaStreamSource(element.srcObject);
      let lastNode = this.sourceNode;
      this.webAudioPluginNodes.forEach((node) => {
        lastNode.connect(node);
        lastNode = node;
      });
      this.gainNode = context.createGain();
      lastNode.connect(this.gainNode);
      this.gainNode.connect(context.destination);
      if (this.elementVolume) {
        this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1);
      }
      if (context.state !== "running") {
        context.resume().then(() => {
          if (context.state !== "running") {
            this.emit(TrackEvent.AudioPlaybackFailed, new Error("Audio Context couldn't be started automatically"));
          }
        }).catch((e) => {
          this.emit(TrackEvent.AudioPlaybackFailed, e);
        });
      }
    }
    disconnectWebAudio() {
      var _a, _b;
      (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.disconnect();
      (_b = this.sourceNode) === null || _b === void 0 ? void 0 : _b.disconnect();
      this.gainNode = void 0;
      this.sourceNode = void 0;
    }
    getReceiverStats() {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.receiver || !this.receiver.getStats) {
          return;
        }
        const stats = yield this.receiver.getStats();
        let receiverStats;
        stats.forEach((v) => {
          if (v.type === "inbound-rtp") {
            receiverStats = {
              type: "audio",
              timestamp: v.timestamp,
              jitter: v.jitter,
              bytesReceived: v.bytesReceived,
              concealedSamples: v.concealedSamples,
              concealmentEvents: v.concealmentEvents,
              silentConcealedSamples: v.silentConcealedSamples,
              silentConcealmentEvents: v.silentConcealmentEvents,
              totalAudioEnergy: v.totalAudioEnergy,
              totalSamplesDuration: v.totalSamplesDuration
            };
          }
        });
        return receiverStats;
      });
    }
  };
  var REACTION_DELAY = 100;
  var RemoteVideoTrack = class extends RemoteTrack {
    constructor(mediaTrack, sid, receiver, adaptiveStreamSettings, loggerOptions) {
      super(mediaTrack, sid, Track.Kind.Video, receiver, loggerOptions);
      this.elementInfos = [];
      this.monitorReceiver = () => __awaiter(this, void 0, void 0, function* () {
        if (!this.receiver) {
          this._currentBitrate = 0;
          return;
        }
        const stats = yield this.getReceiverStats();
        if (stats && this.prevStats && this.receiver) {
          this._currentBitrate = computeBitrate(stats, this.prevStats);
        }
        this.prevStats = stats;
      });
      this.debouncedHandleResize = r(() => {
        this.updateDimensions();
      }, REACTION_DELAY);
      this.adaptiveStreamSettings = adaptiveStreamSettings;
    }
    get isAdaptiveStream() {
      return this.adaptiveStreamSettings !== void 0;
    }
    /**
     * Note: When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start
     */
    get mediaStreamTrack() {
      return this._mediaStreamTrack;
    }
    /** @internal */
    setMuted(muted) {
      super.setMuted(muted);
      this.attachedElements.forEach((element) => {
        if (muted) {
          detachTrack(this._mediaStreamTrack, element);
        } else {
          attachToElement(this._mediaStreamTrack, element);
        }
      });
    }
    attach(element) {
      if (!element) {
        element = super.attach();
      } else {
        super.attach(element);
      }
      if (this.adaptiveStreamSettings && this.elementInfos.find((info) => info.element === element) === void 0) {
        const elementInfo = new HTMLElementInfo(element);
        this.observeElementInfo(elementInfo);
      }
      return element;
    }
    /**
     * Observe an ElementInfo for changes when adaptive streaming.
     * @param elementInfo
     * @internal
     */
    observeElementInfo(elementInfo) {
      if (this.adaptiveStreamSettings && this.elementInfos.find((info) => info === elementInfo) === void 0) {
        elementInfo.handleResize = () => {
          this.debouncedHandleResize();
        };
        elementInfo.handleVisibilityChanged = () => {
          this.updateVisibility();
        };
        this.elementInfos.push(elementInfo);
        elementInfo.observe();
        this.debouncedHandleResize();
        this.updateVisibility();
      } else {
        this.log.warn("visibility resize observer not triggered", this.logContext);
      }
    }
    /**
     * Stop observing an ElementInfo for changes.
     * @param elementInfo
     * @internal
     */
    stopObservingElementInfo(elementInfo) {
      if (!this.isAdaptiveStream) {
        this.log.warn("stopObservingElementInfo ignored", this.logContext);
        return;
      }
      const stopElementInfos = this.elementInfos.filter((info) => info === elementInfo);
      for (const info of stopElementInfos) {
        info.stopObserving();
      }
      this.elementInfos = this.elementInfos.filter((info) => info !== elementInfo);
      this.updateVisibility();
      this.debouncedHandleResize();
    }
    detach(element) {
      let detachedElements = [];
      if (element) {
        this.stopObservingElement(element);
        return super.detach(element);
      }
      detachedElements = super.detach();
      for (const e of detachedElements) {
        this.stopObservingElement(e);
      }
      return detachedElements;
    }
    /** @internal */
    getDecoderImplementation() {
      var _a;
      return (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.decoderImplementation;
    }
    getReceiverStats() {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.receiver || !this.receiver.getStats) {
          return;
        }
        const stats = yield this.receiver.getStats();
        let receiverStats;
        let codecID = "";
        let codecs = /* @__PURE__ */ new Map();
        stats.forEach((v) => {
          if (v.type === "inbound-rtp") {
            codecID = v.codecId;
            receiverStats = {
              type: "video",
              framesDecoded: v.framesDecoded,
              framesDropped: v.framesDropped,
              framesReceived: v.framesReceived,
              packetsReceived: v.packetsReceived,
              packetsLost: v.packetsLost,
              frameWidth: v.frameWidth,
              frameHeight: v.frameHeight,
              pliCount: v.pliCount,
              firCount: v.firCount,
              nackCount: v.nackCount,
              jitter: v.jitter,
              timestamp: v.timestamp,
              bytesReceived: v.bytesReceived,
              decoderImplementation: v.decoderImplementation
            };
          } else if (v.type === "codec") {
            codecs.set(v.id, v);
          }
        });
        if (receiverStats && codecID !== "" && codecs.get(codecID)) {
          receiverStats.mimeType = codecs.get(codecID).mimeType;
        }
        return receiverStats;
      });
    }
    stopObservingElement(element) {
      const stopElementInfos = this.elementInfos.filter((info) => info.element === element);
      for (const info of stopElementInfos) {
        this.stopObservingElementInfo(info);
      }
    }
    handleAppVisibilityChanged() {
      const _super = Object.create(null, {
        handleAppVisibilityChanged: {
          get: () => super.handleAppVisibilityChanged
        }
      });
      return __awaiter(this, void 0, void 0, function* () {
        yield _super.handleAppVisibilityChanged.call(this);
        if (!this.isAdaptiveStream) return;
        this.updateVisibility();
      });
    }
    updateVisibility() {
      var _a, _b;
      const lastVisibilityChange = this.elementInfos.reduce((prev, info) => Math.max(prev, info.visibilityChangedAt || 0), 0);
      const backgroundPause = ((_b = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pauseVideoInBackground) !== null && _b !== void 0 ? _b : true) ? this.isInBackground : false;
      const isPiPMode = this.elementInfos.some((info) => info.pictureInPicture);
      const isVisible = this.elementInfos.some((info) => info.visible) && !backgroundPause || isPiPMode;
      if (this.lastVisible === isVisible) {
        return;
      }
      if (!isVisible && Date.now() - lastVisibilityChange < REACTION_DELAY) {
        CriticalTimers.setTimeout(() => {
          this.updateVisibility();
        }, REACTION_DELAY);
        return;
      }
      this.lastVisible = isVisible;
      this.emit(TrackEvent.VisibilityChanged, isVisible, this);
    }
    updateDimensions() {
      var _a, _b;
      let maxWidth = 0;
      let maxHeight = 0;
      const pixelDensity = this.getPixelDensity();
      for (const info of this.elementInfos) {
        const currentElementWidth = info.width() * pixelDensity;
        const currentElementHeight = info.height() * pixelDensity;
        if (currentElementWidth + currentElementHeight > maxWidth + maxHeight) {
          maxWidth = currentElementWidth;
          maxHeight = currentElementHeight;
        }
      }
      if (((_a = this.lastDimensions) === null || _a === void 0 ? void 0 : _a.width) === maxWidth && ((_b = this.lastDimensions) === null || _b === void 0 ? void 0 : _b.height) === maxHeight) {
        return;
      }
      this.lastDimensions = {
        width: maxWidth,
        height: maxHeight
      };
      this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this);
    }
    getPixelDensity() {
      var _a;
      const pixelDensity = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pixelDensity;
      if (pixelDensity === "screen") {
        return getDevicePixelRatio();
      } else if (!pixelDensity) {
        const devicePixelRatio = getDevicePixelRatio();
        if (devicePixelRatio > 2) {
          return 2;
        } else {
          return 1;
        }
      }
      return pixelDensity;
    }
  };
  var HTMLElementInfo = class {
    get visible() {
      return this.isPiP || this.isIntersecting;
    }
    get pictureInPicture() {
      return this.isPiP;
    }
    constructor(element, visible) {
      this.onVisibilityChanged = (entry) => {
        var _a;
        const {
          target,
          isIntersecting
        } = entry;
        if (target === this.element) {
          this.isIntersecting = isIntersecting;
          this.isPiP = isElementInPiP(this.element);
          this.visibilityChangedAt = Date.now();
          (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);
        }
      };
      this.onEnterPiP = () => {
        var _a, _b, _c;
        (_b = (_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.window) === null || _b === void 0 ? void 0 : _b.addEventListener("pagehide", this.onLeavePiP);
        this.isPiP = isElementInPiP(this.element);
        (_c = this.handleVisibilityChanged) === null || _c === void 0 ? void 0 : _c.call(this);
      };
      this.onLeavePiP = () => {
        var _a;
        this.isPiP = isElementInPiP(this.element);
        (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);
      };
      this.element = element;
      this.isIntersecting = visible !== null && visible !== void 0 ? visible : isElementInViewport(element);
      this.isPiP = isWeb() && isElementInPiP(element);
      this.visibilityChangedAt = 0;
    }
    width() {
      return this.element.clientWidth;
    }
    height() {
      return this.element.clientHeight;
    }
    observe() {
      var _a, _b, _c;
      this.isIntersecting = isElementInViewport(this.element);
      this.isPiP = isElementInPiP(this.element);
      this.element.handleResize = () => {
        var _a2;
        (_a2 = this.handleResize) === null || _a2 === void 0 ? void 0 : _a2.call(this);
      };
      this.element.handleVisibilityChanged = this.onVisibilityChanged;
      getIntersectionObserver().observe(this.element);
      getResizeObserver().observe(this.element);
      this.element.addEventListener("enterpictureinpicture", this.onEnterPiP);
      this.element.addEventListener("leavepictureinpicture", this.onLeavePiP);
      (_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.addEventListener("enter", this.onEnterPiP);
      (_c = (_b = window.documentPictureInPicture) === null || _b === void 0 ? void 0 : _b.window) === null || _c === void 0 ? void 0 : _c.addEventListener("pagehide", this.onLeavePiP);
    }
    stopObserving() {
      var _a, _b, _c, _d, _e;
      (_a = getIntersectionObserver()) === null || _a === void 0 ? void 0 : _a.unobserve(this.element);
      (_b = getResizeObserver()) === null || _b === void 0 ? void 0 : _b.unobserve(this.element);
      this.element.removeEventListener("enterpictureinpicture", this.onEnterPiP);
      this.element.removeEventListener("leavepictureinpicture", this.onLeavePiP);
      (_c = window.documentPictureInPicture) === null || _c === void 0 ? void 0 : _c.removeEventListener("enter", this.onEnterPiP);
      (_e = (_d = window.documentPictureInPicture) === null || _d === void 0 ? void 0 : _d.window) === null || _e === void 0 ? void 0 : _e.removeEventListener("pagehide", this.onLeavePiP);
    }
  };
  function isElementInPiP(el) {
    var _a, _b;
    if (document.pictureInPictureElement === el) return true;
    if ((_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.window) return isElementInViewport(el, (_b = window.documentPictureInPicture) === null || _b === void 0 ? void 0 : _b.window);
    return false;
  }
  function isElementInViewport(el, win) {
    const viewportWindow = win || window;
    let top = el.offsetTop;
    let left = el.offsetLeft;
    const width = el.offsetWidth;
    const height = el.offsetHeight;
    const {
      hidden
    } = el;
    const {
      display
    } = getComputedStyle(el);
    while (el.offsetParent) {
      el = el.offsetParent;
      top += el.offsetTop;
      left += el.offsetLeft;
    }
    return top < viewportWindow.pageYOffset + viewportWindow.innerHeight && left < viewportWindow.pageXOffset + viewportWindow.innerWidth && top + height > viewportWindow.pageYOffset && left + width > viewportWindow.pageXOffset && !hidden && display !== "none";
  }
  var TrackPublication = class extends eventsExports.EventEmitter {
    constructor(kind, id, name, loggerOptions) {
      var _a;
      super();
      this.metadataMuted = false;
      this.encryption = Encryption_Type.NONE;
      this.log = livekitLogger;
      this.handleMuted = () => {
        this.emit(TrackEvent.Muted);
      };
      this.handleUnmuted = () => {
        this.emit(TrackEvent.Unmuted);
      };
      this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Publication);
      this.loggerContextCb = this.loggerContextCb;
      this.setMaxListeners(100);
      this.kind = kind;
      this.trackSid = id;
      this.trackName = name;
      this.source = Track.Source.Unknown;
    }
    /** @internal */
    setTrack(track) {
      if (this.track) {
        this.track.off(TrackEvent.Muted, this.handleMuted);
        this.track.off(TrackEvent.Unmuted, this.handleUnmuted);
      }
      this.track = track;
      if (track) {
        track.on(TrackEvent.Muted, this.handleMuted);
        track.on(TrackEvent.Unmuted, this.handleUnmuted);
      }
    }
    get logContext() {
      var _a;
      return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));
    }
    get isMuted() {
      return this.metadataMuted;
    }
    get isEnabled() {
      return true;
    }
    get isSubscribed() {
      return this.track !== void 0;
    }
    get isEncrypted() {
      return this.encryption !== Encryption_Type.NONE;
    }
    /**
     * an [AudioTrack] if this publication holds an audio track
     */
    get audioTrack() {
      if (this.track instanceof LocalAudioTrack || this.track instanceof RemoteAudioTrack) {
        return this.track;
      }
    }
    /**
     * an [VideoTrack] if this publication holds a video track
     */
    get videoTrack() {
      if (this.track instanceof LocalVideoTrack || this.track instanceof RemoteVideoTrack) {
        return this.track;
      }
    }
    /** @internal */
    updateInfo(info) {
      this.trackSid = info.sid;
      this.trackName = info.name;
      this.source = Track.sourceFromProto(info.source);
      this.mimeType = info.mimeType;
      if (this.kind === Track.Kind.Video && info.width > 0) {
        this.dimensions = {
          width: info.width,
          height: info.height
        };
        this.simulcasted = info.simulcast;
      }
      this.encryption = info.encryption;
      this.trackInfo = info;
      this.log.debug("update publication info", Object.assign(Object.assign({}, this.logContext), {
        info
      }));
    }
  };
  (function(TrackPublication3) {
    (function(SubscriptionStatus) {
      SubscriptionStatus["Desired"] = "desired";
      SubscriptionStatus["Subscribed"] = "subscribed";
      SubscriptionStatus["Unsubscribed"] = "unsubscribed";
    })(TrackPublication3.SubscriptionStatus || (TrackPublication3.SubscriptionStatus = {}));
    (function(PermissionStatus) {
      PermissionStatus["Allowed"] = "allowed";
      PermissionStatus["NotAllowed"] = "not_allowed";
    })(TrackPublication3.PermissionStatus || (TrackPublication3.PermissionStatus = {}));
  })(TrackPublication || (TrackPublication = {}));
  var LocalTrackPublication = class extends TrackPublication {
    get isUpstreamPaused() {
      var _a;
      return (_a = this.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused;
    }
    constructor(kind, ti, track, loggerOptions) {
      super(kind, ti.sid, ti.name, loggerOptions);
      this.track = void 0;
      this.handleTrackEnded = () => {
        this.emit(TrackEvent.Ended);
      };
      this.updateInfo(ti);
      this.setTrack(track);
    }
    setTrack(track) {
      if (this.track) {
        this.track.off(TrackEvent.Ended, this.handleTrackEnded);
      }
      super.setTrack(track);
      if (track) {
        track.on(TrackEvent.Ended, this.handleTrackEnded);
      }
    }
    get isMuted() {
      if (this.track) {
        return this.track.isMuted;
      }
      return super.isMuted;
    }
    get audioTrack() {
      return super.audioTrack;
    }
    get videoTrack() {
      return super.videoTrack;
    }
    /**
     * Mute the track associated with this publication
     */
    mute() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        return (_a = this.track) === null || _a === void 0 ? void 0 : _a.mute();
      });
    }
    /**
     * Unmute track associated with this publication
     */
    unmute() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        return (_a = this.track) === null || _a === void 0 ? void 0 : _a.unmute();
      });
    }
    /**
     * Pauses the media stream track associated with this publication from being sent to the server
     * and signals "muted" event to other participants
     * Useful if you want to pause the stream without pausing the local media stream track
     */
    pauseUpstream() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.pauseUpstream();
      });
    }
    /**
     * Resumes sending the media stream track associated with this publication to the server after a call to [[pauseUpstream()]]
     * and signals "unmuted" event to other participants (unless the track is explicitly muted)
     */
    resumeUpstream() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.resumeUpstream();
      });
    }
    getTrackFeatures() {
      var _a;
      if (this.track instanceof LocalAudioTrack) {
        const settings = this.track.getSourceTrackSettings();
        const features = /* @__PURE__ */ new Set();
        if (settings.autoGainControl) {
          features.add(AudioTrackFeature.TF_AUTO_GAIN_CONTROL);
        }
        if (settings.echoCancellation) {
          features.add(AudioTrackFeature.TF_ECHO_CANCELLATION);
        }
        if (settings.noiseSuppression) {
          features.add(AudioTrackFeature.TF_NOISE_SUPPRESSION);
        }
        if (settings.channelCount && settings.channelCount > 1) {
          features.add(AudioTrackFeature.TF_STEREO);
        }
        if (!((_a = this.options) === null || _a === void 0 ? void 0 : _a.dtx)) {
          features.add(AudioTrackFeature.TF_NO_DTX);
        }
        if (this.track.enhancedNoiseCancellation) {
          features.add(AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION);
        }
        return Array.from(features.values());
      } else return [];
    }
  };
  var ConnectionQuality;
  (function(ConnectionQuality2) {
    ConnectionQuality2["Excellent"] = "excellent";
    ConnectionQuality2["Good"] = "good";
    ConnectionQuality2["Poor"] = "poor";
    ConnectionQuality2["Lost"] = "lost";
    ConnectionQuality2["Unknown"] = "unknown";
  })(ConnectionQuality || (ConnectionQuality = {}));
  function qualityFromProto(q) {
    switch (q) {
      case ConnectionQuality$1.EXCELLENT:
        return ConnectionQuality.Excellent;
      case ConnectionQuality$1.GOOD:
        return ConnectionQuality.Good;
      case ConnectionQuality$1.POOR:
        return ConnectionQuality.Poor;
      case ConnectionQuality$1.LOST:
        return ConnectionQuality.Lost;
      default:
        return ConnectionQuality.Unknown;
    }
  }
  var Participant = class extends eventsExports.EventEmitter {
    get logContext() {
      var _a, _b;
      return Object.assign({}, (_b = (_a = this.loggerOptions) === null || _a === void 0 ? void 0 : _a.loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));
    }
    get isEncrypted() {
      return this.trackPublications.size > 0 && Array.from(this.trackPublications.values()).every((tr) => tr.isEncrypted);
    }
    get isAgent() {
      var _a;
      return ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.agent) || this.kind === ParticipantInfo_Kind.AGENT;
    }
    get kind() {
      return this._kind;
    }
    /** participant attributes, similar to metadata, but as a key/value map */
    get attributes() {
      return Object.freeze(Object.assign({}, this._attributes));
    }
    /** @internal */
    constructor(sid, identity, name, metadata, attributes, loggerOptions) {
      let kind = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : ParticipantInfo_Kind.STANDARD;
      var _a;
      super();
      this.audioLevel = 0;
      this.isSpeaking = false;
      this._connectionQuality = ConnectionQuality.Unknown;
      this.log = livekitLogger;
      this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Participant);
      this.loggerOptions = loggerOptions;
      this.setMaxListeners(100);
      this.sid = sid;
      this.identity = identity;
      this.name = name;
      this.metadata = metadata;
      this.audioTrackPublications = /* @__PURE__ */ new Map();
      this.videoTrackPublications = /* @__PURE__ */ new Map();
      this.trackPublications = /* @__PURE__ */ new Map();
      this._kind = kind;
      this._attributes = attributes !== null && attributes !== void 0 ? attributes : {};
    }
    getTrackPublications() {
      return Array.from(this.trackPublications.values());
    }
    /**
     * Finds the first track that matches the source filter, for example, getting
     * the user's camera track with getTrackBySource(Track.Source.Camera).
     */
    getTrackPublication(source) {
      for (const [, pub] of this.trackPublications) {
        if (pub.source === source) {
          return pub;
        }
      }
    }
    /**
     * Finds the first track that matches the track's name.
     */
    getTrackPublicationByName(name) {
      for (const [, pub] of this.trackPublications) {
        if (pub.trackName === name) {
          return pub;
        }
      }
    }
    get connectionQuality() {
      return this._connectionQuality;
    }
    get isCameraEnabled() {
      var _a;
      const track = this.getTrackPublication(Track.Source.Camera);
      return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);
    }
    get isMicrophoneEnabled() {
      var _a;
      const track = this.getTrackPublication(Track.Source.Microphone);
      return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);
    }
    get isScreenShareEnabled() {
      const track = this.getTrackPublication(Track.Source.ScreenShare);
      return !!track;
    }
    get isLocal() {
      return false;
    }
    /** when participant joined the room */
    get joinedAt() {
      if (this.participantInfo) {
        return new Date(Number.parseInt(this.participantInfo.joinedAt.toString()) * 1e3);
      }
      return /* @__PURE__ */ new Date();
    }
    /** @internal */
    updateInfo(info) {
      if (this.participantInfo && this.participantInfo.sid === info.sid && this.participantInfo.version > info.version) {
        return false;
      }
      this.identity = info.identity;
      this.sid = info.sid;
      this._setName(info.name);
      this._setMetadata(info.metadata);
      this._setAttributes(info.attributes);
      if (info.permission) {
        this.setPermissions(info.permission);
      }
      this.participantInfo = info;
      this.log.trace("update participant info", Object.assign(Object.assign({}, this.logContext), {
        info
      }));
      return true;
    }
    /**
     * Updates metadata from server
     **/
    _setMetadata(md) {
      const changed = this.metadata !== md;
      const prevMetadata = this.metadata;
      this.metadata = md;
      if (changed) {
        this.emit(ParticipantEvent.ParticipantMetadataChanged, prevMetadata);
      }
    }
    _setName(name) {
      const changed = this.name !== name;
      this.name = name;
      if (changed) {
        this.emit(ParticipantEvent.ParticipantNameChanged, name);
      }
    }
    /**
     * Updates metadata from server
     **/
    _setAttributes(attributes) {
      const diff = diffAttributes(this.attributes, attributes);
      this._attributes = attributes;
      if (Object.keys(diff).length > 0) {
        this.emit(ParticipantEvent.AttributesChanged, diff);
      }
    }
    /** @internal */
    setPermissions(permissions) {
      var _a, _b, _c, _d, _e, _f;
      const prevPermissions = this.permissions;
      const changed = permissions.canPublish !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublish) || permissions.canSubscribe !== ((_b = this.permissions) === null || _b === void 0 ? void 0 : _b.canSubscribe) || permissions.canPublishData !== ((_c = this.permissions) === null || _c === void 0 ? void 0 : _c.canPublishData) || permissions.hidden !== ((_d = this.permissions) === null || _d === void 0 ? void 0 : _d.hidden) || permissions.recorder !== ((_e = this.permissions) === null || _e === void 0 ? void 0 : _e.recorder) || permissions.canPublishSources.length !== this.permissions.canPublishSources.length || permissions.canPublishSources.some((value, index) => {
        var _a2;
        return value !== ((_a2 = this.permissions) === null || _a2 === void 0 ? void 0 : _a2.canPublishSources[index]);
      }) || permissions.canSubscribeMetrics !== ((_f = this.permissions) === null || _f === void 0 ? void 0 : _f.canSubscribeMetrics);
      this.permissions = permissions;
      if (changed) {
        this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);
      }
      return changed;
    }
    /** @internal */
    setIsSpeaking(speaking) {
      if (speaking === this.isSpeaking) {
        return;
      }
      this.isSpeaking = speaking;
      if (speaking) {
        this.lastSpokeAt = /* @__PURE__ */ new Date();
      }
      this.emit(ParticipantEvent.IsSpeakingChanged, speaking);
    }
    /** @internal */
    setConnectionQuality(q) {
      const prevQuality = this._connectionQuality;
      this._connectionQuality = qualityFromProto(q);
      if (prevQuality !== this._connectionQuality) {
        this.emit(ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);
      }
    }
    /**
     * @internal
     */
    setAudioContext(ctx) {
      this.audioContext = ctx;
      this.audioTrackPublications.forEach((track) => (track.track instanceof RemoteAudioTrack || track.track instanceof LocalAudioTrack) && track.track.setAudioContext(ctx));
    }
    addTrackPublication(publication) {
      publication.on(TrackEvent.Muted, () => {
        this.emit(ParticipantEvent.TrackMuted, publication);
      });
      publication.on(TrackEvent.Unmuted, () => {
        this.emit(ParticipantEvent.TrackUnmuted, publication);
      });
      const pub = publication;
      if (pub.track) {
        pub.track.sid = publication.trackSid;
      }
      this.trackPublications.set(publication.trackSid, publication);
      switch (publication.kind) {
        case Track.Kind.Audio:
          this.audioTrackPublications.set(publication.trackSid, publication);
          break;
        case Track.Kind.Video:
          this.videoTrackPublications.set(publication.trackSid, publication);
          break;
      }
    }
  };
  function trackPermissionToProto(perms) {
    var _a, _b, _c;
    if (!perms.participantSid && !perms.participantIdentity) {
      throw new Error("Invalid track permission, must provide at least one of participantIdentity and participantSid");
    }
    return new TrackPermission({
      participantIdentity: (_a = perms.participantIdentity) !== null && _a !== void 0 ? _a : "",
      participantSid: (_b = perms.participantSid) !== null && _b !== void 0 ? _b : "",
      allTracks: (_c = perms.allowAll) !== null && _c !== void 0 ? _c : false,
      trackSids: perms.allowedTrackSids || []
    });
  }
  var LocalParticipant = class extends Participant {
    /** @internal */
    constructor(sid, identity, engine, options) {
      super(sid, identity, void 0, void 0, void 0, {
        loggerName: options.loggerName,
        loggerContextCb: () => this.engine.logContext
      });
      this.pendingPublishing = /* @__PURE__ */ new Set();
      this.pendingPublishPromises = /* @__PURE__ */ new Map();
      this.participantTrackPermissions = [];
      this.allParticipantsAllowedToSubscribe = true;
      this.encryptionType = Encryption_Type.NONE;
      this.enabledPublishVideoCodecs = [];
      this.rpcHandlers = /* @__PURE__ */ new Map();
      this.pendingAcks = /* @__PURE__ */ new Map();
      this.pendingResponses = /* @__PURE__ */ new Map();
      this.handleReconnecting = () => {
        if (!this.reconnectFuture) {
          this.reconnectFuture = new Future();
        }
      };
      this.handleReconnected = () => {
        var _a, _b;
        (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.reconnectFuture = void 0;
        this.updateTrackSubscriptionPermissions();
      };
      this.handleDisconnected = () => {
        var _a, _b;
        if (this.reconnectFuture) {
          this.reconnectFuture.promise.catch((e) => this.log.warn(e.message, this.logContext));
          (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.reject) === null || _b === void 0 ? void 0 : _b.call(_a, "Got disconnected during reconnection attempt");
          this.reconnectFuture = void 0;
        }
      };
      this.handleSignalRequestResponse = (response) => {
        const {
          requestId,
          reason,
          message
        } = response;
        const targetRequest = this.pendingSignalRequests.get(requestId);
        if (targetRequest) {
          if (reason !== RequestResponse_Reason.OK) {
            targetRequest.reject(new SignalRequestError(message, reason));
          }
          this.pendingSignalRequests.delete(requestId);
        }
      };
      this.handleDataPacket = (packet) => {
        switch (packet.value.case) {
          case "rpcRequest":
            let rpcRequest = packet.value.value;
            this.handleIncomingRpcRequest(packet.participantIdentity, rpcRequest.id, rpcRequest.method, rpcRequest.payload, rpcRequest.responseTimeoutMs, rpcRequest.version);
            break;
          case "rpcResponse":
            let rpcResponse = packet.value.value;
            let payload = null;
            let error = null;
            if (rpcResponse.value.case === "payload") {
              payload = rpcResponse.value.value;
            } else if (rpcResponse.value.case === "error") {
              error = RpcError.fromProto(rpcResponse.value.value);
            }
            this.handleIncomingRpcResponse(rpcResponse.requestId, payload, error);
            break;
          case "rpcAck":
            let rpcAck = packet.value.value;
            this.handleIncomingRpcAck(rpcAck.requestId);
            break;
        }
      };
      this.updateTrackSubscriptionPermissions = () => {
        this.log.debug("updating track subscription permissions", Object.assign(Object.assign({}, this.logContext), {
          allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,
          participantTrackPermissions: this.participantTrackPermissions
        }));
        this.engine.client.sendUpdateSubscriptionPermissions(this.allParticipantsAllowedToSubscribe, this.participantTrackPermissions.map((p) => trackPermissionToProto(p)));
      };
      this.onTrackUnmuted = (track) => {
        this.onTrackMuted(track, track.isUpstreamPaused);
      };
      this.onTrackMuted = (track, muted) => {
        if (muted === void 0) {
          muted = true;
        }
        if (!track.sid) {
          this.log.error("could not update mute status for unpublished track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
          return;
        }
        this.engine.updateMuteStatus(track.sid, muted);
      };
      this.onTrackUpstreamPaused = (track) => {
        this.log.debug("upstream paused", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
        this.onTrackMuted(track, true);
      };
      this.onTrackUpstreamResumed = (track) => {
        this.log.debug("upstream resumed", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
        this.onTrackMuted(track, track.isMuted);
      };
      this.onTrackFeatureUpdate = (track) => {
        const pub = this.audioTrackPublications.get(track.sid);
        if (!pub) {
          this.log.warn("Could not update local audio track settings, missing publication for track ".concat(track.sid), this.logContext);
          return;
        }
        this.engine.client.sendUpdateLocalAudioTrack(pub.trackSid, pub.getTrackFeatures());
      };
      this.handleSubscribedQualityUpdate = (update) => __awaiter(this, void 0, void 0, function* () {
        var _a, e_1, _b, _c;
        var _d, _e;
        if (!((_d = this.roomOptions) === null || _d === void 0 ? void 0 : _d.dynacast)) {
          return;
        }
        const pub = this.videoTrackPublications.get(update.trackSid);
        if (!pub) {
          this.log.warn("received subscribed quality update for unknown track", Object.assign(Object.assign({}, this.logContext), {
            trackSid: update.trackSid
          }));
          return;
        }
        if (update.subscribedCodecs.length > 0) {
          if (!pub.videoTrack) {
            return;
          }
          const newCodecs = yield pub.videoTrack.setPublishingCodecs(update.subscribedCodecs);
          try {
            for (var _f = true, newCodecs_1 = __asyncValues(newCodecs), newCodecs_1_1; newCodecs_1_1 = yield newCodecs_1.next(), _a = newCodecs_1_1.done, !_a; _f = true) {
              _c = newCodecs_1_1.value;
              _f = false;
              const codec = _c;
              if (isBackupCodec(codec)) {
                this.log.debug("publish ".concat(codec, " for ").concat(pub.videoTrack.sid), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)));
                yield this.publishAdditionalCodecForTrack(pub.videoTrack, codec, pub.options);
              }
            }
          } catch (e_1_1) {
            e_1 = {
              error: e_1_1
            };
          } finally {
            try {
              if (!_f && !_a && (_b = newCodecs_1.return)) yield _b.call(newCodecs_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else if (update.subscribedQualities.length > 0) {
          yield (_e = pub.videoTrack) === null || _e === void 0 ? void 0 : _e.setPublishingLayers(update.subscribedQualities);
        }
      });
      this.handleLocalTrackUnpublished = (unpublished) => {
        const track = this.trackPublications.get(unpublished.trackSid);
        if (!track) {
          this.log.warn("received unpublished event for unknown track", Object.assign(Object.assign({}, this.logContext), {
            trackSid: unpublished.trackSid
          }));
          return;
        }
        this.unpublishTrack(track.track);
      };
      this.handleTrackEnded = (track) => __awaiter(this, void 0, void 0, function* () {
        if (track.source === Track.Source.ScreenShare || track.source === Track.Source.ScreenShareAudio) {
          this.log.debug("unpublishing local track due to TrackEnded", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
          this.unpublishTrack(track);
        } else if (track.isUserProvided) {
          yield track.mute();
        } else if (track instanceof LocalAudioTrack || track instanceof LocalVideoTrack) {
          try {
            if (isWeb()) {
              try {
                const currentPermissions = yield navigator === null || navigator === void 0 ? void 0 : navigator.permissions.query({
                  // the permission query for camera and microphone currently not supported in Safari and Firefox
                  // @ts-ignore
                  name: track.source === Track.Source.Camera ? "camera" : "microphone"
                });
                if (currentPermissions && currentPermissions.state === "denied") {
                  this.log.warn("user has revoked access to ".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
                  currentPermissions.onchange = () => {
                    if (currentPermissions.state !== "denied") {
                      if (!track.isMuted) {
                        track.restartTrack();
                      }
                      currentPermissions.onchange = null;
                    }
                  };
                  throw new Error("GetUserMedia Permission denied");
                }
              } catch (e) {
              }
            }
            if (!track.isMuted) {
              this.log.debug("track ended, attempting to use a different device", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
              if (track instanceof LocalAudioTrack) {
                yield track.restartTrack({
                  deviceId: "default"
                });
              } else {
                yield track.restartTrack();
              }
            }
          } catch (e) {
            this.log.warn("could not restart track, muting instead", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
            yield track.mute();
          }
        }
      });
      this.audioTrackPublications = /* @__PURE__ */ new Map();
      this.videoTrackPublications = /* @__PURE__ */ new Map();
      this.trackPublications = /* @__PURE__ */ new Map();
      this.engine = engine;
      this.roomOptions = options;
      this.setupEngine(engine);
      this.activeDeviceMap = /* @__PURE__ */ new Map();
      this.pendingSignalRequests = /* @__PURE__ */ new Map();
    }
    get lastCameraError() {
      return this.cameraError;
    }
    get lastMicrophoneError() {
      return this.microphoneError;
    }
    get isE2EEEnabled() {
      return this.encryptionType !== Encryption_Type.NONE;
    }
    getTrackPublication(source) {
      const track = super.getTrackPublication(source);
      if (track) {
        return track;
      }
    }
    getTrackPublicationByName(name) {
      const track = super.getTrackPublicationByName(name);
      if (track) {
        return track;
      }
    }
    /**
     * @internal
     */
    setupEngine(engine) {
      this.engine = engine;
      this.engine.on(EngineEvent.RemoteMute, (trackSid, muted) => {
        const pub = this.trackPublications.get(trackSid);
        if (!pub || !pub.track) {
          return;
        }
        if (muted) {
          pub.mute();
        } else {
          pub.unmute();
        }
      });
      this.engine.on(EngineEvent.Connected, this.handleReconnected).on(EngineEvent.SignalRestarted, this.handleReconnected).on(EngineEvent.SignalResumed, this.handleReconnected).on(EngineEvent.Restarting, this.handleReconnecting).on(EngineEvent.Resuming, this.handleReconnecting).on(EngineEvent.LocalTrackUnpublished, this.handleLocalTrackUnpublished).on(EngineEvent.SubscribedQualityUpdate, this.handleSubscribedQualityUpdate).on(EngineEvent.Disconnected, this.handleDisconnected).on(EngineEvent.SignalRequestResponse, this.handleSignalRequestResponse).on(EngineEvent.DataPacketReceived, this.handleDataPacket);
    }
    /**
     * Sets and updates the metadata of the local participant.
     * Note: this requires `canUpdateOwnMetadata` permission.
     * method will throw if the user doesn't have the required permissions
     * @param metadata
     */
    setMetadata(metadata) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.requestMetadataUpdate({
          metadata
        });
      });
    }
    /**
     * Sets and updates the name of the local participant.
     * Note: this requires `canUpdateOwnMetadata` permission.
     * method will throw if the user doesn't have the required permissions
     * @param metadata
     */
    setName(name) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.requestMetadataUpdate({
          name
        });
      });
    }
    /**
     * Set or update participant attributes. It will make updates only to keys that
     * are present in `attributes`, and will not override others.
     * Note: this requires `canUpdateOwnMetadata` permission.
     * @param attributes attributes to update
     */
    setAttributes(attributes) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.requestMetadataUpdate({
          attributes
        });
      });
    }
    requestMetadataUpdate(_a) {
      return __awaiter(this, arguments, void 0, function(_ref) {
        var _this = this;
        let {
          metadata,
          name,
          attributes
        } = _ref;
        return function* () {
          return new Promise((resolve, reject) => __awaiter(_this, void 0, void 0, function* () {
            var _a2, _b;
            try {
              let isRejected = false;
              const requestId = yield this.engine.client.sendUpdateLocalMetadata((_a2 = metadata !== null && metadata !== void 0 ? metadata : this.metadata) !== null && _a2 !== void 0 ? _a2 : "", (_b = name !== null && name !== void 0 ? name : this.name) !== null && _b !== void 0 ? _b : "", attributes);
              const startTime = performance.now();
              this.pendingSignalRequests.set(requestId, {
                resolve,
                reject: (error) => {
                  reject(error);
                  isRejected = true;
                },
                values: {
                  name,
                  metadata,
                  attributes
                }
              });
              while (performance.now() - startTime < 5e3 && !isRejected) {
                if ((!name || this.name === name) && (!metadata || this.metadata === metadata) && (!attributes || Object.entries(attributes).every((_ref2) => {
                  let [key, value] = _ref2;
                  return this.attributes[key] === value || value === "" && !this.attributes[key];
                }))) {
                  this.pendingSignalRequests.delete(requestId);
                  resolve();
                  return;
                }
                yield sleep(50);
              }
              reject(new SignalRequestError("Request to update local metadata timed out", "TimeoutError"));
            } catch (e) {
              if (e instanceof Error) reject(e);
            }
          }));
        }();
      });
    }
    /**
     * Enable or disable a participant's camera track.
     *
     * If a track has already published, it'll mute or unmute the track.
     * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
     */
    setCameraEnabled(enabled, options, publishOptions) {
      return this.setTrackEnabled(Track.Source.Camera, enabled, options, publishOptions);
    }
    /**
     * Enable or disable a participant's microphone track.
     *
     * If a track has already published, it'll mute or unmute the track.
     * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
     */
    setMicrophoneEnabled(enabled, options, publishOptions) {
      return this.setTrackEnabled(Track.Source.Microphone, enabled, options, publishOptions);
    }
    /**
     * Start or stop sharing a participant's screen
     * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
     */
    setScreenShareEnabled(enabled, options, publishOptions) {
      return this.setTrackEnabled(Track.Source.ScreenShare, enabled, options, publishOptions);
    }
    /** @internal */
    setPermissions(permissions) {
      const prevPermissions = this.permissions;
      const changed = super.setPermissions(permissions);
      if (changed && prevPermissions) {
        this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);
      }
      return changed;
    }
    /** @internal */
    setE2EEEnabled(enabled) {
      return __awaiter(this, void 0, void 0, function* () {
        this.encryptionType = enabled ? Encryption_Type.GCM : Encryption_Type.NONE;
        yield this.republishAllTracks(void 0, false);
      });
    }
    setTrackEnabled(source, enabled, options, publishOptions) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        this.log.debug("setTrackEnabled", Object.assign(Object.assign({}, this.logContext), {
          source,
          enabled
        }));
        if (this.republishPromise) {
          yield this.republishPromise;
        }
        let track = this.getTrackPublication(source);
        if (enabled) {
          if (track) {
            yield track.unmute();
          } else {
            let localTracks;
            if (this.pendingPublishing.has(source)) {
              const pendingTrack = yield this.waitForPendingPublicationOfSource(source);
              if (!pendingTrack) {
                this.log.info("waiting for pending publication promise timed out", Object.assign(Object.assign({}, this.logContext), {
                  source
                }));
              }
              yield pendingTrack === null || pendingTrack === void 0 ? void 0 : pendingTrack.unmute();
              return pendingTrack;
            }
            this.pendingPublishing.add(source);
            try {
              switch (source) {
                case Track.Source.Camera:
                  localTracks = yield this.createTracks({
                    video: (_a = options) !== null && _a !== void 0 ? _a : true
                  });
                  break;
                case Track.Source.Microphone:
                  localTracks = yield this.createTracks({
                    audio: (_b = options) !== null && _b !== void 0 ? _b : true
                  });
                  break;
                case Track.Source.ScreenShare:
                  localTracks = yield this.createScreenTracks(Object.assign({}, options));
                  break;
                default:
                  throw new TrackInvalidError(source);
              }
              const publishPromises = [];
              for (const localTrack of localTracks) {
                this.log.info("publishing track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(localTrack)));
                publishPromises.push(this.publishTrack(localTrack, publishOptions));
              }
              const publishedTracks = yield Promise.all(publishPromises);
              [track] = publishedTracks;
            } catch (e) {
              localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach((tr) => {
                tr.stop();
              });
              if (e instanceof Error && !(e instanceof TrackInvalidError)) {
                this.emit(ParticipantEvent.MediaDevicesError, e);
              }
              throw e;
            } finally {
              this.pendingPublishing.delete(source);
            }
          }
        } else {
          if (!(track === null || track === void 0 ? void 0 : track.track) && this.pendingPublishing.has(source)) {
            track = yield this.waitForPendingPublicationOfSource(source);
            if (!track) {
              this.log.info("waiting for pending publication promise timed out", Object.assign(Object.assign({}, this.logContext), {
                source
              }));
            }
          }
          if (track && track.track) {
            if (source === Track.Source.ScreenShare) {
              track = yield this.unpublishTrack(track.track);
              const screenAudioTrack = this.getTrackPublication(Track.Source.ScreenShareAudio);
              if (screenAudioTrack && screenAudioTrack.track) {
                this.unpublishTrack(screenAudioTrack.track);
              }
            } else {
              yield track.mute();
            }
          }
        }
        return track;
      });
    }
    /**
     * Publish both camera and microphone at the same time. This is useful for
     * displaying a single Permission Dialog box to the end user.
     */
    enableCameraAndMicrophone() {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.pendingPublishing.has(Track.Source.Camera) || this.pendingPublishing.has(Track.Source.Microphone)) {
          return;
        }
        this.pendingPublishing.add(Track.Source.Camera);
        this.pendingPublishing.add(Track.Source.Microphone);
        try {
          const tracks = yield this.createTracks({
            audio: true,
            video: true
          });
          yield Promise.all(tracks.map((track) => this.publishTrack(track)));
        } finally {
          this.pendingPublishing.delete(Track.Source.Camera);
          this.pendingPublishing.delete(Track.Source.Microphone);
        }
      });
    }
    /**
     * Create local camera and/or microphone tracks
     * @param options
     * @returns
     */
    createTracks(options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        options !== null && options !== void 0 ? options : options = {};
        const {
          audioProcessor,
          videoProcessor,
          optionsWithoutProcessor
        } = extractProcessorsFromOptions(options);
        const mergedOptions = mergeDefaultOptions(optionsWithoutProcessor, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.audioCaptureDefaults, (_b = this.roomOptions) === null || _b === void 0 ? void 0 : _b.videoCaptureDefaults);
        const constraints = constraintsForOptions(mergedOptions);
        let stream4;
        try {
          stream4 = yield navigator.mediaDevices.getUserMedia(constraints);
        } catch (err) {
          if (err instanceof Error) {
            if (constraints.audio) {
              this.microphoneError = err;
            }
            if (constraints.video) {
              this.cameraError = err;
            }
          }
          throw err;
        }
        if (constraints.audio) {
          this.microphoneError = void 0;
          this.emit(ParticipantEvent.AudioStreamAcquired);
        }
        if (constraints.video) {
          this.cameraError = void 0;
        }
        return Promise.all(stream4.getTracks().map((mediaStreamTrack) => __awaiter(this, void 0, void 0, function* () {
          const isAudio = mediaStreamTrack.kind === "audio";
          isAudio ? mergedOptions.audio : mergedOptions.video;
          let trackConstraints;
          const conOrBool = isAudio ? constraints.audio : constraints.video;
          if (typeof conOrBool !== "boolean") {
            trackConstraints = conOrBool;
          }
          const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints, {
            loggerName: this.roomOptions.loggerName,
            loggerContextCb: () => this.logContext
          });
          if (track.kind === Track.Kind.Video) {
            track.source = Track.Source.Camera;
          } else if (track.kind === Track.Kind.Audio) {
            track.source = Track.Source.Microphone;
            track.setAudioContext(this.audioContext);
          }
          track.mediaStream = stream4;
          if (track instanceof LocalAudioTrack && audioProcessor) {
            yield track.setProcessor(audioProcessor);
          } else if (track instanceof LocalVideoTrack && videoProcessor) {
            yield track.setProcessor(videoProcessor);
          }
          return track;
        })));
      });
    }
    /**
     * Creates a screen capture tracks with getDisplayMedia().
     * A LocalVideoTrack is always created and returned.
     * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.
     */
    createScreenTracks(options) {
      return __awaiter(this, void 0, void 0, function* () {
        if (options === void 0) {
          options = {};
        }
        if (navigator.mediaDevices.getDisplayMedia === void 0) {
          throw new DeviceUnsupportedError("getDisplayMedia not supported");
        }
        if (options.resolution === void 0 && !isSafari17()) {
          options.resolution = ScreenSharePresets.h1080fps30.resolution;
        }
        const constraints = screenCaptureToDisplayMediaStreamOptions(options);
        const stream4 = yield navigator.mediaDevices.getDisplayMedia(constraints);
        const tracks = stream4.getVideoTracks();
        if (tracks.length === 0) {
          throw new TrackInvalidError("no video track found");
        }
        const screenVideo = new LocalVideoTrack(tracks[0], void 0, false, {
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext
        });
        screenVideo.source = Track.Source.ScreenShare;
        if (options.contentHint) {
          screenVideo.mediaStreamTrack.contentHint = options.contentHint;
        }
        const localTracks = [screenVideo];
        if (stream4.getAudioTracks().length > 0) {
          this.emit(ParticipantEvent.AudioStreamAcquired);
          const screenAudio = new LocalAudioTrack(stream4.getAudioTracks()[0], void 0, false, this.audioContext, {
            loggerName: this.roomOptions.loggerName,
            loggerContextCb: () => this.logContext
          });
          screenAudio.source = Track.Source.ScreenShareAudio;
          localTracks.push(screenAudio);
        }
        return localTracks;
      });
    }
    /**
     * Publish a new track to the room
     * @param track
     * @param options
     */
    publishTrack(track, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.publishOrRepublishTrack(track, options);
      });
    }
    publishOrRepublishTrack(track_1, options_1) {
      return __awaiter(this, arguments, void 0, function(track, options) {
        var _this2 = this;
        let isRepublish = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        return function* () {
          var _a, _b, _c, _d;
          if (track instanceof LocalAudioTrack) {
            track.setAudioContext(_this2.audioContext);
          }
          yield (_a = _this2.reconnectFuture) === null || _a === void 0 ? void 0 : _a.promise;
          if (_this2.republishPromise && !isRepublish) {
            yield _this2.republishPromise;
          }
          if (track instanceof LocalTrack && _this2.pendingPublishPromises.has(track)) {
            yield _this2.pendingPublishPromises.get(track);
          }
          let defaultConstraints;
          if (track instanceof MediaStreamTrack) {
            defaultConstraints = track.getConstraints();
          } else {
            defaultConstraints = track.constraints;
            let deviceKind = void 0;
            switch (track.source) {
              case Track.Source.Microphone:
                deviceKind = "audioinput";
                break;
              case Track.Source.Camera:
                deviceKind = "videoinput";
            }
            if (deviceKind && _this2.activeDeviceMap.has(deviceKind)) {
              defaultConstraints = Object.assign(Object.assign({}, defaultConstraints), {
                deviceId: _this2.activeDeviceMap.get(deviceKind)
              });
            }
          }
          if (track instanceof MediaStreamTrack) {
            switch (track.kind) {
              case "audio":
                track = new LocalAudioTrack(track, defaultConstraints, true, _this2.audioContext, {
                  loggerName: _this2.roomOptions.loggerName,
                  loggerContextCb: () => _this2.logContext
                });
                break;
              case "video":
                track = new LocalVideoTrack(track, defaultConstraints, true, {
                  loggerName: _this2.roomOptions.loggerName,
                  loggerContextCb: () => _this2.logContext
                });
                break;
              default:
                throw new TrackInvalidError("unsupported MediaStreamTrack kind ".concat(track.kind));
            }
          } else {
            track.updateLoggerOptions({
              loggerName: _this2.roomOptions.loggerName,
              loggerContextCb: () => _this2.logContext
            });
          }
          let existingPublication;
          _this2.trackPublications.forEach((publication) => {
            if (!publication.track) {
              return;
            }
            if (publication.track === track) {
              existingPublication = publication;
            }
          });
          if (existingPublication) {
            _this2.log.warn("track has already been published, skipping", Object.assign(Object.assign({}, _this2.logContext), getLogContextFromTrack(existingPublication)));
            return existingPublication;
          }
          const isStereoInput = "channelCount" in track.mediaStreamTrack.getSettings() && // @ts-ignore `channelCount` on getSettings() is currently only available for Safari, but is generally the best way to determine a stereo track https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/channelCount
          track.mediaStreamTrack.getSettings().channelCount === 2 || track.mediaStreamTrack.getConstraints().channelCount === 2;
          const isStereo = (_b = options === null || options === void 0 ? void 0 : options.forceStereo) !== null && _b !== void 0 ? _b : isStereoInput;
          if (isStereo) {
            if (!options) {
              options = {};
            }
            if (options.dtx === void 0) {
              _this2.log.info("Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.", Object.assign(Object.assign({}, _this2.logContext), getLogContextFromTrack(track)));
            }
            if (options.red === void 0) {
              _this2.log.info("Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work.");
            }
            (_c = options.dtx) !== null && _c !== void 0 ? _c : options.dtx = false;
            (_d = options.red) !== null && _d !== void 0 ? _d : options.red = false;
          }
          const opts = Object.assign(Object.assign({}, _this2.roomOptions.publishDefaults), options);
          if (!isE2EESimulcastSupported() && _this2.roomOptions.e2ee) {
            _this2.log.info("End-to-end encryption is set up, simulcast publishing will be disabled on Safari versions and iOS browsers running iOS < v17.2", Object.assign({}, _this2.logContext));
            opts.simulcast = false;
          }
          if (opts.source) {
            track.source = opts.source;
          }
          const publishPromise = _this2.publish(track, opts, isStereo);
          _this2.pendingPublishPromises.set(track, publishPromise);
          try {
            const publication = yield publishPromise;
            return publication;
          } catch (e) {
            throw e;
          } finally {
            _this2.pendingPublishPromises.delete(track);
          }
        }();
      });
    }
    publish(track, opts, isStereo) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const existingTrackOfSource = Array.from(this.trackPublications.values()).find((publishedTrack) => track instanceof LocalTrack && publishedTrack.source === track.source);
        if (existingTrackOfSource && track.source !== Track.Source.Unknown) {
          this.log.info("publishing a second track with the same source: ".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
        }
        if (opts.stopMicTrackOnMute && track instanceof LocalAudioTrack) {
          track.stopOnMute = true;
        }
        if (track.source === Track.Source.ScreenShare && isFireFox()) {
          opts.simulcast = false;
        }
        if (opts.videoCodec === "av1" && !supportsAV1()) {
          opts.videoCodec = void 0;
        }
        if (opts.videoCodec === "vp9" && !supportsVP9()) {
          opts.videoCodec = void 0;
        }
        if (opts.videoCodec === void 0) {
          opts.videoCodec = defaultVideoCodec;
        }
        if (this.enabledPublishVideoCodecs.length > 0) {
          if (!this.enabledPublishVideoCodecs.some((c) => opts.videoCodec === mimeTypeToVideoCodecString(c.mime))) {
            opts.videoCodec = mimeTypeToVideoCodecString(this.enabledPublishVideoCodecs[0].mime);
          }
        }
        const videoCodec = opts.videoCodec;
        track.on(TrackEvent.Muted, this.onTrackMuted);
        track.on(TrackEvent.Unmuted, this.onTrackUnmuted);
        track.on(TrackEvent.Ended, this.handleTrackEnded);
        track.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);
        track.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);
        track.on(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);
        const req = new AddTrackRequest({
          // get local track id for use during publishing
          cid: track.mediaStreamTrack.id,
          name: opts.name,
          type: Track.kindToProto(track.kind),
          muted: track.isMuted,
          source: Track.sourceToProto(track.source),
          disableDtx: !((_a = opts.dtx) !== null && _a !== void 0 ? _a : true),
          encryption: this.encryptionType,
          stereo: isStereo,
          disableRed: this.isE2EEEnabled || !((_b = opts.red) !== null && _b !== void 0 ? _b : true),
          stream: opts === null || opts === void 0 ? void 0 : opts.stream
        });
        let encodings;
        if (track.kind === Track.Kind.Video) {
          let dims = {
            width: 0,
            height: 0
          };
          try {
            dims = yield track.waitForDimensions();
          } catch (e) {
            const defaultRes = (_d = (_c = this.roomOptions.videoCaptureDefaults) === null || _c === void 0 ? void 0 : _c.resolution) !== null && _d !== void 0 ? _d : VideoPresets.h720.resolution;
            dims = {
              width: defaultRes.width,
              height: defaultRes.height
            };
            this.log.error("could not determine track dimensions, using defaults", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {
              dims
            }));
          }
          req.width = dims.width;
          req.height = dims.height;
          if (track instanceof LocalVideoTrack) {
            if (isSVCCodec(videoCodec)) {
              if (track.source === Track.Source.ScreenShare) {
                opts.scalabilityMode = "L1T3";
                if ("contentHint" in track.mediaStreamTrack) {
                  track.mediaStreamTrack.contentHint = "motion";
                  this.log.info("forcing contentHint to motion for screenshare with SVC codecs", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
                }
              }
              opts.scalabilityMode = (_e = opts.scalabilityMode) !== null && _e !== void 0 ? _e : "L3T3_KEY";
            }
            req.simulcastCodecs = [new SimulcastCodec({
              codec: videoCodec,
              cid: track.mediaStreamTrack.id
            })];
            if (opts.backupCodec === true) {
              opts.backupCodec = {
                codec: defaultVideoCodec
              };
            }
            if (opts.backupCodec && videoCodec !== opts.backupCodec.codec && // TODO remove this once e2ee is supported for backup codecs
            req.encryption === Encryption_Type.NONE) {
              if (!this.roomOptions.dynacast) {
                this.roomOptions.dynacast = true;
              }
              req.simulcastCodecs.push(new SimulcastCodec({
                codec: opts.backupCodec.codec,
                cid: ""
              }));
            }
          }
          encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);
          req.layers = videoLayersFromEncodings(req.width, req.height, encodings, isSVCCodec(opts.videoCodec));
        } else if (track.kind === Track.Kind.Audio) {
          encodings = [{
            maxBitrate: (_f = opts.audioPreset) === null || _f === void 0 ? void 0 : _f.maxBitrate,
            priority: (_h = (_g = opts.audioPreset) === null || _g === void 0 ? void 0 : _g.priority) !== null && _h !== void 0 ? _h : "high",
            networkPriority: (_k = (_j = opts.audioPreset) === null || _j === void 0 ? void 0 : _j.priority) !== null && _k !== void 0 ? _k : "high"
          }];
        }
        if (!this.engine || this.engine.isClosed) {
          throw new UnexpectedConnectionState("cannot publish track when not connected");
        }
        const negotiate = () => __awaiter(this, void 0, void 0, function* () {
          var _a2, _b2, _c2;
          if (!this.engine.pcManager) {
            throw new UnexpectedConnectionState("pcManager is not ready");
          }
          track.sender = yield this.engine.createSender(track, opts, encodings);
          if (track instanceof LocalVideoTrack) {
            (_a2 = opts.degradationPreference) !== null && _a2 !== void 0 ? _a2 : opts.degradationPreference = getDefaultDegradationPreference(track);
            track.setDegradationPreference(opts.degradationPreference);
          }
          if (encodings) {
            if (isFireFox() && track.kind === Track.Kind.Audio) {
              let trackTransceiver = void 0;
              for (const transceiver of this.engine.pcManager.publisher.getTransceivers()) {
                if (transceiver.sender === track.sender) {
                  trackTransceiver = transceiver;
                  break;
                }
              }
              if (trackTransceiver) {
                this.engine.pcManager.publisher.setTrackCodecBitrate({
                  transceiver: trackTransceiver,
                  codec: "opus",
                  maxbr: ((_b2 = encodings[0]) === null || _b2 === void 0 ? void 0 : _b2.maxBitrate) ? encodings[0].maxBitrate / 1e3 : 0
                });
              }
            } else if (track.codec && isSVCCodec(track.codec) && ((_c2 = encodings[0]) === null || _c2 === void 0 ? void 0 : _c2.maxBitrate)) {
              this.engine.pcManager.publisher.setTrackCodecBitrate({
                cid: req.cid,
                codec: track.codec,
                maxbr: encodings[0].maxBitrate / 1e3
              });
            }
          }
          yield this.engine.negotiate();
        });
        let ti;
        if (this.enabledPublishVideoCodecs.length > 0) {
          const rets = yield Promise.all([this.engine.addTrack(req), negotiate()]);
          ti = rets[0];
        } else {
          ti = yield this.engine.addTrack(req);
          let primaryCodecMime;
          ti.codecs.forEach((codec) => {
            if (primaryCodecMime === void 0) {
              primaryCodecMime = codec.mimeType;
            }
          });
          if (primaryCodecMime && track.kind === Track.Kind.Video) {
            const updatedCodec = mimeTypeToVideoCodecString(primaryCodecMime);
            if (updatedCodec !== videoCodec) {
              this.log.debug("falling back to server selected codec", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {
                codec: updatedCodec
              }));
              opts.videoCodec = updatedCodec;
              encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);
            }
          }
          yield negotiate();
        }
        const publication = new LocalTrackPublication(track.kind, ti, track, {
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext
        });
        publication.options = opts;
        track.sid = ti.sid;
        this.log.debug("publishing ".concat(track.kind, " with encodings"), Object.assign(Object.assign({}, this.logContext), {
          encodings,
          trackInfo: ti
        }));
        if (track instanceof LocalVideoTrack) {
          track.startMonitor(this.engine.client);
        } else if (track instanceof LocalAudioTrack) {
          track.startMonitor();
        }
        this.addTrackPublication(publication);
        this.emit(ParticipantEvent.LocalTrackPublished, publication);
        return publication;
      });
    }
    get isLocal() {
      return true;
    }
    /** @internal
     * publish additional codec to existing track
     */
    publishAdditionalCodecForTrack(track, videoCodec, options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (this.encryptionType !== Encryption_Type.NONE) {
          return;
        }
        let existingPublication;
        this.trackPublications.forEach((publication) => {
          if (!publication.track) {
            return;
          }
          if (publication.track === track) {
            existingPublication = publication;
          }
        });
        if (!existingPublication) {
          throw new TrackInvalidError("track is not published");
        }
        if (!(track instanceof LocalVideoTrack)) {
          throw new TrackInvalidError("track is not a video track");
        }
        const opts = Object.assign(Object.assign({}, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.publishDefaults), options);
        const encodings = computeTrackBackupEncodings(track, videoCodec, opts);
        if (!encodings) {
          this.log.info("backup codec has been disabled, ignoring request to add additional codec for track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
          return;
        }
        const simulcastTrack = track.addSimulcastTrack(videoCodec, encodings);
        if (!simulcastTrack) {
          return;
        }
        const req = new AddTrackRequest({
          cid: simulcastTrack.mediaStreamTrack.id,
          type: Track.kindToProto(track.kind),
          muted: track.isMuted,
          source: Track.sourceToProto(track.source),
          sid: track.sid,
          simulcastCodecs: [{
            codec: opts.videoCodec,
            cid: simulcastTrack.mediaStreamTrack.id
          }]
        });
        req.layers = videoLayersFromEncodings(req.width, req.height, encodings);
        if (!this.engine || this.engine.isClosed) {
          throw new UnexpectedConnectionState("cannot publish track when not connected");
        }
        const negotiate = () => __awaiter(this, void 0, void 0, function* () {
          yield this.engine.createSimulcastSender(track, simulcastTrack, opts, encodings);
          yield this.engine.negotiate();
        });
        const rets = yield Promise.all([this.engine.addTrack(req), negotiate()]);
        const ti = rets[0];
        this.log.debug("published ".concat(videoCodec, " for track ").concat(track.sid), Object.assign(Object.assign({}, this.logContext), {
          encodings,
          trackInfo: ti
        }));
      });
    }
    unpublishTrack(track, stopOnUnpublish) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        if (track instanceof LocalTrack) {
          const publishPromise = this.pendingPublishPromises.get(track);
          if (publishPromise) {
            this.log.info("awaiting publish promise before attempting to unpublish", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
            yield publishPromise;
          }
        }
        const publication = this.getPublicationForTrack(track);
        const pubLogContext = publication ? getLogContextFromTrack(publication) : void 0;
        this.log.debug("unpublishing track", Object.assign(Object.assign({}, this.logContext), pubLogContext));
        if (!publication || !publication.track) {
          this.log.warn("track was not unpublished because no publication was found", Object.assign(Object.assign({}, this.logContext), pubLogContext));
          return void 0;
        }
        track = publication.track;
        track.off(TrackEvent.Muted, this.onTrackMuted);
        track.off(TrackEvent.Unmuted, this.onTrackUnmuted);
        track.off(TrackEvent.Ended, this.handleTrackEnded);
        track.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);
        track.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);
        track.off(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);
        if (stopOnUnpublish === void 0) {
          stopOnUnpublish = (_b = (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.stopLocalTrackOnUnpublish) !== null && _b !== void 0 ? _b : true;
        }
        if (stopOnUnpublish) {
          track.stop();
        } else {
          track.stopMonitor();
        }
        let negotiationNeeded = false;
        const trackSender = track.sender;
        track.sender = void 0;
        if (this.engine.pcManager && this.engine.pcManager.currentState < PCTransportState.FAILED && trackSender) {
          try {
            for (const transceiver of this.engine.pcManager.publisher.getTransceivers()) {
              if (transceiver.sender === trackSender) {
                transceiver.direction = "inactive";
                negotiationNeeded = true;
              }
            }
            if (this.engine.removeTrack(trackSender)) {
              negotiationNeeded = true;
            }
            if (track instanceof LocalVideoTrack) {
              for (const [, trackInfo] of track.simulcastCodecs) {
                if (trackInfo.sender) {
                  if (this.engine.removeTrack(trackInfo.sender)) {
                    negotiationNeeded = true;
                  }
                  trackInfo.sender = void 0;
                }
              }
              track.simulcastCodecs.clear();
            }
          } catch (e) {
            this.log.warn("failed to unpublish track", Object.assign(Object.assign(Object.assign({}, this.logContext), pubLogContext), {
              error: e
            }));
          }
        }
        this.trackPublications.delete(publication.trackSid);
        switch (publication.kind) {
          case Track.Kind.Audio:
            this.audioTrackPublications.delete(publication.trackSid);
            break;
          case Track.Kind.Video:
            this.videoTrackPublications.delete(publication.trackSid);
            break;
        }
        this.emit(ParticipantEvent.LocalTrackUnpublished, publication);
        publication.setTrack(void 0);
        if (negotiationNeeded) {
          yield this.engine.negotiate();
        }
        return publication;
      });
    }
    unpublishTracks(tracks) {
      return __awaiter(this, void 0, void 0, function* () {
        const results = yield Promise.all(tracks.map((track) => this.unpublishTrack(track)));
        return results.filter((track) => track instanceof LocalTrackPublication);
      });
    }
    republishAllTracks(options_1) {
      return __awaiter(this, arguments, void 0, function(options) {
        var _this3 = this;
        let restartTracks = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        return function* () {
          if (_this3.republishPromise) {
            yield _this3.republishPromise;
          }
          _this3.republishPromise = new Promise((resolve, reject) => __awaiter(_this3, void 0, void 0, function* () {
            try {
              const localPubs = [];
              this.trackPublications.forEach((pub) => {
                if (pub.track) {
                  if (options) {
                    pub.options = Object.assign(Object.assign({}, pub.options), options);
                  }
                  localPubs.push(pub);
                }
              });
              yield Promise.all(localPubs.map((pub) => __awaiter(this, void 0, void 0, function* () {
                const track = pub.track;
                yield this.unpublishTrack(track, false);
                if (restartTracks && !track.isMuted && track.source !== Track.Source.ScreenShare && track.source !== Track.Source.ScreenShareAudio && (track instanceof LocalAudioTrack || track instanceof LocalVideoTrack) && !track.isUserProvided) {
                  this.log.debug("restarting existing track", Object.assign(Object.assign({}, this.logContext), {
                    track: pub.trackSid
                  }));
                  yield track.restartTrack();
                }
                yield this.publishOrRepublishTrack(track, pub.options, true);
              })));
              resolve();
            } catch (error) {
              reject(error);
            } finally {
              this.republishPromise = void 0;
            }
          }));
          yield _this3.republishPromise;
        }();
      });
    }
    /**
     * Publish a new data payload to the room. Data will be forwarded to each
     * participant in the room if the destination field in publishOptions is empty
     *
     * @param data Uint8Array of the payload. To send string data, use TextEncoder.encode
     * @param options optionally specify a `reliable`, `topic` and `destination`
     */
    publishData(data_1) {
      return __awaiter(this, arguments, void 0, function(data) {
        var _this4 = this;
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return function* () {
          const kind = options.reliable ? DataPacket_Kind.RELIABLE : DataPacket_Kind.LOSSY;
          const destinationIdentities = options.destinationIdentities;
          const topic = options.topic;
          const packet = new DataPacket({
            kind,
            value: {
              case: "user",
              value: new UserPacket({
                participantIdentity: _this4.identity,
                payload: data,
                destinationIdentities,
                topic
              })
            }
          });
          yield _this4.engine.sendDataPacket(packet, kind);
        }();
      });
    }
    /**
     * Publish SIP DTMF message to the room.
     *
     * @param code DTMF code
     * @param digit DTMF digit
     */
    publishDtmf(code, digit) {
      return __awaiter(this, void 0, void 0, function* () {
        const packet = new DataPacket({
          kind: DataPacket_Kind.RELIABLE,
          value: {
            case: "sipDtmf",
            value: new SipDTMF({
              code,
              digit
            })
          }
        });
        yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
      });
    }
    sendChatMessage(text) {
      return __awaiter(this, void 0, void 0, function* () {
        const msg = {
          id: crypto.randomUUID(),
          message: text,
          timestamp: Date.now()
        };
        const packet = new DataPacket({
          value: {
            case: "chatMessage",
            value: new ChatMessage(Object.assign(Object.assign({}, msg), {
              timestamp: protoInt64.parse(msg.timestamp)
            }))
          }
        });
        yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
        this.emit(ParticipantEvent.ChatMessage, msg);
        return msg;
      });
    }
    editChatMessage(editText, originalMessage) {
      return __awaiter(this, void 0, void 0, function* () {
        const msg = Object.assign(Object.assign({}, originalMessage), {
          message: editText,
          editTimestamp: Date.now()
        });
        const packet = new DataPacket({
          value: {
            case: "chatMessage",
            value: new ChatMessage(Object.assign(Object.assign({}, msg), {
              timestamp: protoInt64.parse(msg.timestamp),
              editTimestamp: protoInt64.parse(msg.editTimestamp)
            }))
          }
        });
        yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
        this.emit(ParticipantEvent.ChatMessage, msg);
        return msg;
      });
    }
    /**
     * Initiate an RPC call to a remote participant
     * @param params - Parameters for initiating the RPC call, see {@link PerformRpcParams}
     * @returns A promise that resolves with the response payload or rejects with an error.
     * @throws Error on failure. Details in `message`.
     */
    performRpc(_a) {
      return __awaiter(this, arguments, void 0, function(_ref3) {
        var _this5 = this;
        let {
          destinationIdentity,
          method,
          payload,
          responseTimeout = 1e4
        } = _ref3;
        return function* () {
          const maxRoundTripLatency = 2e3;
          return new Promise((resolve, reject) => __awaiter(_this5, void 0, void 0, function* () {
            var _a2, _b, _c, _d;
            if (byteLength(payload) > MAX_PAYLOAD_BYTES) {
              reject(RpcError.builtIn("REQUEST_PAYLOAD_TOO_LARGE"));
              return;
            }
            if (((_b = (_a2 = this.engine.latestJoinResponse) === null || _a2 === void 0 ? void 0 : _a2.serverInfo) === null || _b === void 0 ? void 0 : _b.version) && compareVersions((_d = (_c = this.engine.latestJoinResponse) === null || _c === void 0 ? void 0 : _c.serverInfo) === null || _d === void 0 ? void 0 : _d.version, "1.8.0") < 0) {
              reject(RpcError.builtIn("UNSUPPORTED_SERVER"));
              return;
            }
            const id = crypto.randomUUID();
            yield this.publishRpcRequest(destinationIdentity, id, method, payload, responseTimeout - maxRoundTripLatency);
            const ackTimeoutId = setTimeout(() => {
              this.pendingAcks.delete(id);
              reject(RpcError.builtIn("CONNECTION_TIMEOUT"));
              this.pendingResponses.delete(id);
              clearTimeout(responseTimeoutId);
            }, maxRoundTripLatency);
            this.pendingAcks.set(id, {
              resolve: () => {
                clearTimeout(ackTimeoutId);
              },
              participantIdentity: destinationIdentity
            });
            const responseTimeoutId = setTimeout(() => {
              this.pendingResponses.delete(id);
              reject(RpcError.builtIn("RESPONSE_TIMEOUT"));
            }, responseTimeout);
            this.pendingResponses.set(id, {
              resolve: (responsePayload, responseError) => {
                clearTimeout(responseTimeoutId);
                if (this.pendingAcks.has(id)) {
                  console.warn("RPC response received before ack", id);
                  this.pendingAcks.delete(id);
                  clearTimeout(ackTimeoutId);
                }
                if (responseError) {
                  reject(responseError);
                } else {
                  resolve(responsePayload !== null && responsePayload !== void 0 ? responsePayload : "");
                }
              },
              participantIdentity: destinationIdentity
            });
          }));
        }();
      });
    }
    /**
     * Establishes the participant as a receiver for calls of the specified RPC method.
     * Will overwrite any existing callback for the same method.
     *
     * @param method - The name of the indicated RPC method
     * @param handler - Will be invoked when an RPC request for this method is received
     * @returns A promise that resolves when the method is successfully registered
     *
     * @example
     * ```typescript
     * room.localParticipant?.registerRpcMethod(
     *   'greet',
     *   async (data: RpcInvocationData) => {
     *     console.log(`Received greeting from ${data.callerIdentity}: ${data.payload}`);
     *     return `Hello, ${data.callerIdentity}!`;
     *   }
     * );
     * ```
     *
     * The handler should return a Promise that resolves to a string.
     * If unable to respond within `responseTimeout`, the request will result in an error on the caller's side.
     *
     * You may throw errors of type `RpcError` with a string `message` in the handler,
     * and they will be received on the caller's side with the message intact.
     * Other errors thrown in your handler will not be transmitted as-is, and will instead arrive to the caller as `1500` ("Application Error").
     */
    registerRpcMethod(method, handler) {
      this.rpcHandlers.set(method, handler);
    }
    /**
     * Unregisters a previously registered RPC method.
     *
     * @param method - The name of the RPC method to unregister
     */
    unregisterRpcMethod(method) {
      this.rpcHandlers.delete(method);
    }
    /**
     * Control who can subscribe to LocalParticipant's published tracks.
     *
     * By default, all participants can subscribe. This allows fine-grained control over
     * who is able to subscribe at a participant and track level.
     *
     * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and
     * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks
     * will not grant permissions to any participants and will require a subsequent
     * permissions update to allow subscription.
     *
     * @param allParticipantsAllowed Allows all participants to subscribe all tracks.
     *  Takes precedence over [[participantTrackPermissions]] if set to true.
     *  By default this is set to true.
     * @param participantTrackPermissions Full list of individual permissions per
     *  participant/track. Any omitted participants will not receive any permissions.
     */
    setTrackSubscriptionPermissions(allParticipantsAllowed) {
      let participantTrackPermissions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      this.participantTrackPermissions = participantTrackPermissions;
      this.allParticipantsAllowedToSubscribe = allParticipantsAllowed;
      if (!this.engine.client.isDisconnected) {
        this.updateTrackSubscriptionPermissions();
      }
    }
    handleIncomingRpcAck(requestId) {
      const handler = this.pendingAcks.get(requestId);
      if (handler) {
        handler.resolve();
        this.pendingAcks.delete(requestId);
      } else {
        console.error("Ack received for unexpected RPC request", requestId);
      }
    }
    handleIncomingRpcResponse(requestId, payload, error) {
      const handler = this.pendingResponses.get(requestId);
      if (handler) {
        handler.resolve(payload, error);
        this.pendingResponses.delete(requestId);
      } else {
        console.error("Response received for unexpected RPC request", requestId);
      }
    }
    handleIncomingRpcRequest(callerIdentity, requestId, method, payload, responseTimeout, version2) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.publishRpcAck(callerIdentity, requestId);
        if (version2 !== 1) {
          yield this.publishRpcResponse(callerIdentity, requestId, null, RpcError.builtIn("UNSUPPORTED_VERSION"));
          return;
        }
        const handler = this.rpcHandlers.get(method);
        if (!handler) {
          yield this.publishRpcResponse(callerIdentity, requestId, null, RpcError.builtIn("UNSUPPORTED_METHOD"));
          return;
        }
        let responseError = null;
        let responsePayload = null;
        try {
          const response = yield handler({
            requestId,
            callerIdentity,
            payload,
            responseTimeout
          });
          if (byteLength(response) > MAX_PAYLOAD_BYTES) {
            responseError = RpcError.builtIn("RESPONSE_PAYLOAD_TOO_LARGE");
            console.warn("RPC Response payload too large for ".concat(method));
          } else {
            responsePayload = response;
          }
        } catch (error) {
          if (error instanceof RpcError) {
            responseError = error;
          } else {
            console.warn("Uncaught error returned by RPC handler for ".concat(method, ". Returning APPLICATION_ERROR instead."), error);
            responseError = RpcError.builtIn("APPLICATION_ERROR");
          }
        }
        yield this.publishRpcResponse(callerIdentity, requestId, responsePayload, responseError);
      });
    }
    /** @internal */
    publishRpcRequest(destinationIdentity, requestId, method, payload, responseTimeout) {
      return __awaiter(this, void 0, void 0, function* () {
        const packet = new DataPacket({
          destinationIdentities: [destinationIdentity],
          kind: DataPacket_Kind.RELIABLE,
          value: {
            case: "rpcRequest",
            value: new RpcRequest({
              id: requestId,
              method,
              payload,
              responseTimeoutMs: responseTimeout,
              version: 1
            })
          }
        });
        yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
      });
    }
    /** @internal */
    publishRpcResponse(destinationIdentity, requestId, payload, error) {
      return __awaiter(this, void 0, void 0, function* () {
        const packet = new DataPacket({
          destinationIdentities: [destinationIdentity],
          kind: DataPacket_Kind.RELIABLE,
          value: {
            case: "rpcResponse",
            value: new RpcResponse({
              requestId,
              value: error ? {
                case: "error",
                value: error.toProto()
              } : {
                case: "payload",
                value: payload !== null && payload !== void 0 ? payload : ""
              }
            })
          }
        });
        yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
      });
    }
    /** @internal */
    publishRpcAck(destinationIdentity, requestId) {
      return __awaiter(this, void 0, void 0, function* () {
        const packet = new DataPacket({
          destinationIdentities: [destinationIdentity],
          kind: DataPacket_Kind.RELIABLE,
          value: {
            case: "rpcAck",
            value: new RpcAck({
              requestId
            })
          }
        });
        yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
      });
    }
    /** @internal */
    handleParticipantDisconnected(participantIdentity) {
      for (const [id, {
        participantIdentity: pendingIdentity
      }] of this.pendingAcks) {
        if (pendingIdentity === participantIdentity) {
          this.pendingAcks.delete(id);
        }
      }
      for (const [id, {
        participantIdentity: pendingIdentity,
        resolve
      }] of this.pendingResponses) {
        if (pendingIdentity === participantIdentity) {
          resolve(null, RpcError.builtIn("RECIPIENT_DISCONNECTED"));
          this.pendingResponses.delete(id);
        }
      }
    }
    /** @internal */
    setEnabledPublishCodecs(codecs) {
      this.enabledPublishVideoCodecs = codecs.filter((c) => c.mime.split("/")[0].toLowerCase() === "video");
    }
    /** @internal */
    updateInfo(info) {
      if (info.sid !== this.sid) {
        return false;
      }
      if (!super.updateInfo(info)) {
        return false;
      }
      info.tracks.forEach((ti) => {
        var _a, _b;
        const pub = this.trackPublications.get(ti.sid);
        if (pub) {
          const mutedOnServer = pub.isMuted || ((_b = (_a = pub.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused) !== null && _b !== void 0 ? _b : false);
          if (mutedOnServer !== ti.muted) {
            this.log.debug("updating server mute state after reconcile", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)), {
              mutedOnServer
            }));
            this.engine.client.sendMuteTrack(ti.sid, mutedOnServer);
          }
        }
      });
      return true;
    }
    getPublicationForTrack(track) {
      let publication;
      this.trackPublications.forEach((pub) => {
        const localTrack = pub.track;
        if (!localTrack) {
          return;
        }
        if (track instanceof MediaStreamTrack) {
          if (localTrack instanceof LocalAudioTrack || localTrack instanceof LocalVideoTrack) {
            if (localTrack.mediaStreamTrack === track) {
              publication = pub;
            }
          }
        } else if (track === localTrack) {
          publication = pub;
        }
      });
      return publication;
    }
    waitForPendingPublicationOfSource(source) {
      return __awaiter(this, void 0, void 0, function* () {
        const waitForPendingTimeout = 1e4;
        const startTime = Date.now();
        while (Date.now() < startTime + waitForPendingTimeout) {
          const publishPromiseEntry = Array.from(this.pendingPublishPromises.entries()).find((_ref4) => {
            let [pendingTrack] = _ref4;
            return pendingTrack.source === source;
          });
          if (publishPromiseEntry) {
            return publishPromiseEntry[1];
          }
          yield sleep(20);
        }
      });
    }
  };
  var RemoteTrackPublication = class extends TrackPublication {
    constructor(kind, ti, autoSubscribe, loggerOptions) {
      super(kind, ti.sid, ti.name, loggerOptions);
      this.track = void 0;
      this.allowed = true;
      this.disabled = false;
      this.currentVideoQuality = VideoQuality.HIGH;
      this.handleEnded = (track) => {
        this.setTrack(void 0);
        this.emit(TrackEvent.Ended, track);
      };
      this.handleVisibilityChange = (visible) => {
        this.log.debug("adaptivestream video visibility ".concat(this.trackSid, ", visible=").concat(visible), this.logContext);
        this.disabled = !visible;
        this.emitTrackUpdate();
      };
      this.handleVideoDimensionsChange = (dimensions) => {
        this.log.debug("adaptivestream video dimensions ".concat(dimensions.width, "x").concat(dimensions.height), this.logContext);
        this.videoDimensions = dimensions;
        this.emitTrackUpdate();
      };
      this.subscribed = autoSubscribe;
      this.updateInfo(ti);
    }
    /**
     * Subscribe or unsubscribe to this remote track
     * @param subscribed true to subscribe to a track, false to unsubscribe
     */
    setSubscribed(subscribed) {
      const prevStatus = this.subscriptionStatus;
      const prevPermission = this.permissionStatus;
      this.subscribed = subscribed;
      if (subscribed) {
        this.allowed = true;
      }
      const sub = new UpdateSubscription({
        trackSids: [this.trackSid],
        subscribe: this.subscribed,
        participantTracks: [new ParticipantTracks({
          // sending an empty participant id since TrackPublication doesn't keep it
          // this is filled in by the participant that receives this message
          participantSid: "",
          trackSids: [this.trackSid]
        })]
      });
      this.emit(TrackEvent.UpdateSubscription, sub);
      this.emitSubscriptionUpdateIfChanged(prevStatus);
      this.emitPermissionUpdateIfChanged(prevPermission);
    }
    get subscriptionStatus() {
      if (this.subscribed === false) {
        return TrackPublication.SubscriptionStatus.Unsubscribed;
      }
      if (!super.isSubscribed) {
        return TrackPublication.SubscriptionStatus.Desired;
      }
      return TrackPublication.SubscriptionStatus.Subscribed;
    }
    get permissionStatus() {
      return this.allowed ? TrackPublication.PermissionStatus.Allowed : TrackPublication.PermissionStatus.NotAllowed;
    }
    /**
     * Returns true if track is subscribed, and ready for playback
     */
    get isSubscribed() {
      if (this.subscribed === false) {
        return false;
      }
      return super.isSubscribed;
    }
    // returns client's desire to subscribe to a track, also true if autoSubscribe is enabled
    get isDesired() {
      return this.subscribed !== false;
    }
    get isEnabled() {
      return !this.disabled;
    }
    /**
     * disable server from sending down data for this track. this is useful when
     * the participant is off screen, you may disable streaming down their video
     * to reduce bandwidth requirements
     * @param enabled
     */
    setEnabled(enabled) {
      if (!this.isManualOperationAllowed() || this.disabled === !enabled) {
        return;
      }
      this.disabled = !enabled;
      this.emitTrackUpdate();
    }
    /**
     * for tracks that support simulcasting, adjust subscribed quality
     *
     * This indicates the highest quality the client can accept. if network
     * bandwidth does not allow, server will automatically reduce quality to
     * optimize for uninterrupted video
     */
    setVideoQuality(quality) {
      if (!this.isManualOperationAllowed() || this.currentVideoQuality === quality) {
        return;
      }
      this.currentVideoQuality = quality;
      this.videoDimensions = void 0;
      this.emitTrackUpdate();
    }
    setVideoDimensions(dimensions) {
      var _a, _b;
      if (!this.isManualOperationAllowed()) {
        return;
      }
      if (((_a = this.videoDimensions) === null || _a === void 0 ? void 0 : _a.width) === dimensions.width && ((_b = this.videoDimensions) === null || _b === void 0 ? void 0 : _b.height) === dimensions.height) {
        return;
      }
      if (this.track instanceof RemoteVideoTrack) {
        this.videoDimensions = dimensions;
      }
      this.currentVideoQuality = void 0;
      this.emitTrackUpdate();
    }
    setVideoFPS(fps) {
      if (!this.isManualOperationAllowed()) {
        return;
      }
      if (!(this.track instanceof RemoteVideoTrack)) {
        return;
      }
      if (this.fps === fps) {
        return;
      }
      this.fps = fps;
      this.emitTrackUpdate();
    }
    get videoQuality() {
      return this.currentVideoQuality;
    }
    /** @internal */
    setTrack(track) {
      const prevStatus = this.subscriptionStatus;
      const prevPermission = this.permissionStatus;
      const prevTrack = this.track;
      if (prevTrack === track) {
        return;
      }
      if (prevTrack) {
        prevTrack.off(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);
        prevTrack.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange);
        prevTrack.off(TrackEvent.Ended, this.handleEnded);
        prevTrack.detach();
        prevTrack.stopMonitor();
        this.emit(TrackEvent.Unsubscribed, prevTrack);
      }
      super.setTrack(track);
      if (track) {
        track.sid = this.trackSid;
        track.on(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);
        track.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange);
        track.on(TrackEvent.Ended, this.handleEnded);
        this.emit(TrackEvent.Subscribed, track);
      }
      this.emitPermissionUpdateIfChanged(prevPermission);
      this.emitSubscriptionUpdateIfChanged(prevStatus);
    }
    /** @internal */
    setAllowed(allowed) {
      const prevStatus = this.subscriptionStatus;
      const prevPermission = this.permissionStatus;
      this.allowed = allowed;
      this.emitPermissionUpdateIfChanged(prevPermission);
      this.emitSubscriptionUpdateIfChanged(prevStatus);
    }
    /** @internal */
    setSubscriptionError(error) {
      this.emit(TrackEvent.SubscriptionFailed, error);
    }
    /** @internal */
    updateInfo(info) {
      super.updateInfo(info);
      const prevMetadataMuted = this.metadataMuted;
      this.metadataMuted = info.muted;
      if (this.track) {
        this.track.setMuted(info.muted);
      } else if (prevMetadataMuted !== info.muted) {
        this.emit(info.muted ? TrackEvent.Muted : TrackEvent.Unmuted);
      }
    }
    emitSubscriptionUpdateIfChanged(previousStatus) {
      const currentStatus = this.subscriptionStatus;
      if (previousStatus === currentStatus) {
        return;
      }
      this.emit(TrackEvent.SubscriptionStatusChanged, currentStatus, previousStatus);
    }
    emitPermissionUpdateIfChanged(previousPermissionStatus) {
      const currentPermissionStatus = this.permissionStatus;
      if (currentPermissionStatus !== previousPermissionStatus) {
        this.emit(TrackEvent.SubscriptionPermissionChanged, this.permissionStatus, previousPermissionStatus);
      }
    }
    isManualOperationAllowed() {
      if (this.kind === Track.Kind.Video && this.isAdaptiveStream) {
        this.log.warn("adaptive stream is enabled, cannot change video track settings", this.logContext);
        return false;
      }
      if (!this.isDesired) {
        this.log.warn("cannot update track settings when not subscribed", this.logContext);
        return false;
      }
      return true;
    }
    get isAdaptiveStream() {
      return this.track instanceof RemoteVideoTrack && this.track.isAdaptiveStream;
    }
    /* @internal */
    emitTrackUpdate() {
      const settings = new UpdateTrackSettings({
        trackSids: [this.trackSid],
        disabled: this.disabled,
        fps: this.fps
      });
      if (this.videoDimensions) {
        settings.width = Math.ceil(this.videoDimensions.width);
        settings.height = Math.ceil(this.videoDimensions.height);
      } else if (this.currentVideoQuality !== void 0) {
        settings.quality = this.currentVideoQuality;
      } else {
        settings.quality = VideoQuality.HIGH;
      }
      this.emit(TrackEvent.UpdateSettings, settings);
    }
  };
  var RemoteParticipant = class _RemoteParticipant extends Participant {
    /** @internal */
    static fromParticipantInfo(signalClient, pi, loggerOptions) {
      return new _RemoteParticipant(signalClient, pi.sid, pi.identity, pi.name, pi.metadata, pi.attributes, loggerOptions, pi.kind);
    }
    get logContext() {
      return Object.assign(Object.assign({}, super.logContext), {
        rpID: this.sid,
        remoteParticipant: this.identity
      });
    }
    /** @internal */
    constructor(signalClient, sid, identity, name, metadata, attributes, loggerOptions) {
      let kind = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : ParticipantInfo_Kind.STANDARD;
      super(sid, identity || "", name, metadata, attributes, loggerOptions, kind);
      this.signalClient = signalClient;
      this.trackPublications = /* @__PURE__ */ new Map();
      this.audioTrackPublications = /* @__PURE__ */ new Map();
      this.videoTrackPublications = /* @__PURE__ */ new Map();
      this.volumeMap = /* @__PURE__ */ new Map();
    }
    addTrackPublication(publication) {
      super.addTrackPublication(publication);
      publication.on(TrackEvent.UpdateSettings, (settings) => {
        this.log.debug("send update settings", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));
        this.signalClient.sendUpdateTrackSettings(settings);
      });
      publication.on(TrackEvent.UpdateSubscription, (sub) => {
        sub.participantTracks.forEach((pt) => {
          pt.participantSid = this.sid;
        });
        this.signalClient.sendUpdateSubscription(sub);
      });
      publication.on(TrackEvent.SubscriptionPermissionChanged, (status) => {
        this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, publication, status);
      });
      publication.on(TrackEvent.SubscriptionStatusChanged, (status) => {
        this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, publication, status);
      });
      publication.on(TrackEvent.Subscribed, (track) => {
        this.emit(ParticipantEvent.TrackSubscribed, track, publication);
      });
      publication.on(TrackEvent.Unsubscribed, (previousTrack) => {
        this.emit(ParticipantEvent.TrackUnsubscribed, previousTrack, publication);
      });
      publication.on(TrackEvent.SubscriptionFailed, (error) => {
        this.emit(ParticipantEvent.TrackSubscriptionFailed, publication.trackSid, error);
      });
    }
    getTrackPublication(source) {
      const track = super.getTrackPublication(source);
      if (track) {
        return track;
      }
    }
    getTrackPublicationByName(name) {
      const track = super.getTrackPublicationByName(name);
      if (track) {
        return track;
      }
    }
    /**
     * sets the volume on the participant's audio track
     * by default, this affects the microphone publication
     * a different source can be passed in as a second argument
     * if no track exists the volume will be applied when the microphone track is added
     */
    setVolume(volume) {
      let source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Track.Source.Microphone;
      this.volumeMap.set(source, volume);
      const audioPublication = this.getTrackPublication(source);
      if (audioPublication && audioPublication.track) {
        audioPublication.track.setVolume(volume);
      }
    }
    /**
     * gets the volume on the participant's microphone track
     */
    getVolume() {
      let source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Track.Source.Microphone;
      const audioPublication = this.getTrackPublication(source);
      if (audioPublication && audioPublication.track) {
        return audioPublication.track.getVolume();
      }
      return this.volumeMap.get(source);
    }
    /** @internal */
    addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft) {
      let publication = this.getTrackPublicationBySid(sid);
      if (!publication) {
        if (!sid.startsWith("TR")) {
          this.trackPublications.forEach((p) => {
            if (!publication && mediaTrack.kind === p.kind.toString()) {
              publication = p;
            }
          });
        }
      }
      if (!publication) {
        if (triesLeft === 0) {
          this.log.error("could not find published track", Object.assign(Object.assign({}, this.logContext), {
            trackSid: sid
          }));
          this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);
          return;
        }
        if (triesLeft === void 0) triesLeft = 20;
        setTimeout(() => {
          this.addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft - 1);
        }, 150);
        return;
      }
      if (mediaTrack.readyState === "ended") {
        this.log.error("unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));
        this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);
        return;
      }
      const isVideo = mediaTrack.kind === "video";
      let track;
      if (isVideo) {
        track = new RemoteVideoTrack(mediaTrack, sid, receiver, adaptiveStreamSettings);
      } else {
        track = new RemoteAudioTrack(mediaTrack, sid, receiver, this.audioContext, this.audioOutput);
      }
      track.source = publication.source;
      track.isMuted = publication.isMuted;
      track.setMediaStream(mediaStream);
      track.start();
      publication.setTrack(track);
      if (this.volumeMap.has(publication.source) && track instanceof RemoteAudioTrack) {
        track.setVolume(this.volumeMap.get(publication.source));
      }
      return publication;
    }
    /** @internal */
    get hasMetadata() {
      return !!this.participantInfo;
    }
    /**
     * @internal
     */
    getTrackPublicationBySid(sid) {
      return this.trackPublications.get(sid);
    }
    /** @internal */
    updateInfo(info) {
      if (!super.updateInfo(info)) {
        return false;
      }
      const validTracks = /* @__PURE__ */ new Map();
      const newTracks = /* @__PURE__ */ new Map();
      info.tracks.forEach((ti) => {
        var _a, _b;
        let publication = this.getTrackPublicationBySid(ti.sid);
        if (!publication) {
          const kind = Track.kindFromProto(ti.type);
          if (!kind) {
            return;
          }
          publication = new RemoteTrackPublication(kind, ti, (_a = this.signalClient.connectOptions) === null || _a === void 0 ? void 0 : _a.autoSubscribe, {
            loggerContextCb: () => this.logContext,
            loggerName: (_b = this.loggerOptions) === null || _b === void 0 ? void 0 : _b.loggerName
          });
          publication.updateInfo(ti);
          newTracks.set(ti.sid, publication);
          const existingTrackOfSource = Array.from(this.trackPublications.values()).find((publishedTrack) => publishedTrack.source === (publication === null || publication === void 0 ? void 0 : publication.source));
          if (existingTrackOfSource && publication.source !== Track.Source.Unknown) {
            this.log.debug("received a second track publication for ".concat(this.identity, " with the same source: ").concat(publication.source), Object.assign(Object.assign({}, this.logContext), {
              oldTrack: getLogContextFromTrack(existingTrackOfSource),
              newTrack: getLogContextFromTrack(publication)
            }));
          }
          this.addTrackPublication(publication);
        } else {
          publication.updateInfo(ti);
        }
        validTracks.set(ti.sid, publication);
      });
      this.trackPublications.forEach((publication) => {
        if (!validTracks.has(publication.trackSid)) {
          this.log.trace("detected removed track on remote participant, unpublishing", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));
          this.unpublishTrack(publication.trackSid, true);
        }
      });
      newTracks.forEach((publication) => {
        this.emit(ParticipantEvent.TrackPublished, publication);
      });
      return true;
    }
    /** @internal */
    unpublishTrack(sid, sendUnpublish) {
      const publication = this.trackPublications.get(sid);
      if (!publication) {
        return;
      }
      const {
        track
      } = publication;
      if (track) {
        track.stop();
        publication.setTrack(void 0);
      }
      this.trackPublications.delete(sid);
      switch (publication.kind) {
        case Track.Kind.Audio:
          this.audioTrackPublications.delete(sid);
          break;
        case Track.Kind.Video:
          this.videoTrackPublications.delete(sid);
          break;
      }
      if (sendUnpublish) {
        this.emit(ParticipantEvent.TrackUnpublished, publication);
      }
    }
    /**
     * @internal
     */
    setAudioOutput(output) {
      return __awaiter(this, void 0, void 0, function* () {
        this.audioOutput = output;
        const promises = [];
        this.audioTrackPublications.forEach((pub) => {
          var _a;
          if (pub.track instanceof RemoteAudioTrack) {
            promises.push(pub.track.setSinkId((_a = output.deviceId) !== null && _a !== void 0 ? _a : "default"));
          }
        });
        yield Promise.all(promises);
      });
    }
    /** @internal */
    emit(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      this.log.trace("participant event", Object.assign(Object.assign({}, this.logContext), {
        event,
        args
      }));
      return super.emit(event, ...args);
    }
  };
  var ConnectionState;
  (function(ConnectionState2) {
    ConnectionState2["Disconnected"] = "disconnected";
    ConnectionState2["Connecting"] = "connecting";
    ConnectionState2["Connected"] = "connected";
    ConnectionState2["Reconnecting"] = "reconnecting";
    ConnectionState2["SignalReconnecting"] = "signalReconnecting";
  })(ConnectionState || (ConnectionState = {}));
  var connectionReconcileFrequency = 4 * 1e3;
  var Room = class extends eventsExports.EventEmitter {
    /**
     * Creates a new Room, the primary construct for a LiveKit session.
     * @param options
     */
    constructor(options) {
      var _this;
      var _a, _b;
      super();
      _this = this;
      this.state = ConnectionState.Disconnected;
      this.activeSpeakers = [];
      this.isE2EEEnabled = false;
      this.audioEnabled = true;
      this.isVideoPlaybackBlocked = false;
      this.log = livekitLogger;
      this.bufferedEvents = [];
      this.isResuming = false;
      this.connect = (url2, token, opts) => __awaiter(this, void 0, void 0, function* () {
        var _a2;
        if (!isBrowserSupported()) {
          if (isReactNative()) {
            throw Error("WebRTC isn't detected, have you called registerGlobals?");
          } else {
            throw Error("LiveKit doesn't seem to be supported on this browser. Try to update your browser and make sure no browser extensions are disabling webRTC.");
          }
        }
        const unlockDisconnect = yield this.disconnectLock.lock();
        if (this.state === ConnectionState.Connected) {
          this.log.info("already connected to room ".concat(this.name), this.logContext);
          unlockDisconnect();
          return Promise.resolve();
        }
        if (this.connectFuture) {
          unlockDisconnect();
          return this.connectFuture.promise;
        }
        this.setAndEmitConnectionState(ConnectionState.Connecting);
        if (((_a2 = this.regionUrlProvider) === null || _a2 === void 0 ? void 0 : _a2.getServerUrl().toString()) !== url2) {
          this.regionUrl = void 0;
          this.regionUrlProvider = void 0;
        }
        if (isCloud(new URL(url2))) {
          if (this.regionUrlProvider === void 0) {
            this.regionUrlProvider = new RegionUrlProvider(url2, token);
          } else {
            this.regionUrlProvider.updateToken(token);
          }
          this.regionUrlProvider.fetchRegionSettings().then((settings) => {
            var _a3;
            (_a3 = this.regionUrlProvider) === null || _a3 === void 0 ? void 0 : _a3.setServerReportedRegions(settings);
          }).catch((e) => {
            this.log.warn("could not fetch region settings", Object.assign(Object.assign({}, this.logContext), {
              error: e
            }));
          });
        }
        const connectFn = (resolve, reject, regionUrl2) => __awaiter(this, void 0, void 0, function* () {
          var _a3, _b2;
          if (this.abortController) {
            this.abortController.abort();
          }
          const abortController = new AbortController();
          this.abortController = abortController;
          unlockDisconnect === null || unlockDisconnect === void 0 ? void 0 : unlockDisconnect();
          try {
            yield this.attemptConnection(regionUrl2 !== null && regionUrl2 !== void 0 ? regionUrl2 : url2, token, opts, abortController);
            this.abortController = void 0;
            resolve();
          } catch (e) {
            if (this.regionUrlProvider && e instanceof ConnectionError && e.reason !== ConnectionErrorReason.Cancelled && e.reason !== ConnectionErrorReason.NotAllowed) {
              let nextUrl = null;
              try {
                nextUrl = yield this.regionUrlProvider.getNextBestRegionUrl((_a3 = this.abortController) === null || _a3 === void 0 ? void 0 : _a3.signal);
              } catch (error) {
                if (error instanceof ConnectionError && (error.status === 401 || error.reason === ConnectionErrorReason.Cancelled)) {
                  this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);
                  reject(error);
                  return;
                }
              }
              if (nextUrl && !((_b2 = this.abortController) === null || _b2 === void 0 ? void 0 : _b2.signal.aborted)) {
                this.log.info("Initial connection failed with ConnectionError: ".concat(e.message, ". Retrying with another region: ").concat(nextUrl), this.logContext);
                this.recreateEngine();
                yield connectFn(resolve, reject, nextUrl);
              } else {
                this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, getDisconnectReasonFromConnectionError(e));
                reject(e);
              }
            } else {
              let disconnectReason = DisconnectReason.UNKNOWN_REASON;
              if (e instanceof ConnectionError) {
                disconnectReason = getDisconnectReasonFromConnectionError(e);
              }
              this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, disconnectReason);
              reject(e);
            }
          }
        });
        const regionUrl = this.regionUrl;
        this.regionUrl = void 0;
        this.connectFuture = new Future((resolve, reject) => {
          connectFn(resolve, reject, regionUrl);
        }, () => {
          this.clearConnectionFutures();
        });
        return this.connectFuture.promise;
      });
      this.connectSignal = (url2, token, engine, connectOptions, roomOptions, abortController) => __awaiter(this, void 0, void 0, function* () {
        var _a2, _b2, _c;
        const joinResponse = yield engine.join(url2, token, {
          autoSubscribe: connectOptions.autoSubscribe,
          adaptiveStream: typeof roomOptions.adaptiveStream === "object" ? true : roomOptions.adaptiveStream,
          maxRetries: connectOptions.maxRetries,
          e2eeEnabled: !!this.e2eeManager,
          websocketTimeout: connectOptions.websocketTimeout
        }, abortController.signal);
        let serverInfo = joinResponse.serverInfo;
        if (!serverInfo) {
          serverInfo = {
            version: joinResponse.serverVersion,
            region: joinResponse.serverRegion
          };
        }
        this.serverInfo = serverInfo;
        this.log.debug("connected to Livekit Server ".concat(Object.entries(serverInfo).map((_ref) => {
          let [key, value] = _ref;
          return "".concat(key, ": ").concat(value);
        }).join(", ")), {
          room: (_a2 = joinResponse.room) === null || _a2 === void 0 ? void 0 : _a2.name,
          roomSid: (_b2 = joinResponse.room) === null || _b2 === void 0 ? void 0 : _b2.sid,
          identity: (_c = joinResponse.participant) === null || _c === void 0 ? void 0 : _c.identity
        });
        if (!serverInfo.version) {
          throw new UnsupportedServer("unknown server version");
        }
        if (serverInfo.version === "0.15.1" && this.options.dynacast) {
          this.log.debug("disabling dynacast due to server version", this.logContext);
          roomOptions.dynacast = false;
        }
        return joinResponse;
      });
      this.applyJoinResponse = (joinResponse) => {
        const pi = joinResponse.participant;
        this.localParticipant.sid = pi.sid;
        this.localParticipant.identity = pi.identity;
        this.localParticipant.setEnabledPublishCodecs(joinResponse.enabledPublishCodecs);
        if (this.options.e2ee && this.e2eeManager) {
          try {
            this.e2eeManager.setSifTrailer(joinResponse.sifTrailer);
          } catch (e) {
            this.log.error(e instanceof Error ? e.message : "Could not set SifTrailer", Object.assign(Object.assign({}, this.logContext), {
              error: e
            }));
          }
        }
        this.handleParticipantUpdates([pi, ...joinResponse.otherParticipants]);
        if (joinResponse.room) {
          this.handleRoomUpdate(joinResponse.room);
        }
      };
      this.attemptConnection = (url2, token, opts, abortController) => __awaiter(this, void 0, void 0, function* () {
        var _a2, _b2, _c;
        if (this.state === ConnectionState.Reconnecting || this.isResuming || ((_a2 = this.engine) === null || _a2 === void 0 ? void 0 : _a2.pendingReconnect)) {
          this.log.info("Reconnection attempt replaced by new connection attempt", this.logContext);
          this.recreateEngine();
        } else {
          this.maybeCreateEngine();
        }
        if ((_b2 = this.regionUrlProvider) === null || _b2 === void 0 ? void 0 : _b2.isCloud()) {
          this.engine.setRegionUrlProvider(this.regionUrlProvider);
        }
        this.acquireAudioContext();
        this.connOptions = Object.assign(Object.assign({}, roomConnectOptionDefaults), opts);
        if (this.connOptions.rtcConfig) {
          this.engine.rtcConfig = this.connOptions.rtcConfig;
        }
        if (this.connOptions.peerConnectionTimeout) {
          this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout;
        }
        try {
          const joinResponse = yield this.connectSignal(url2, token, this.engine, this.connOptions, this.options, abortController);
          this.applyJoinResponse(joinResponse);
          this.setupLocalParticipantEvents();
          this.emit(RoomEvent.SignalConnected);
        } catch (err) {
          yield this.engine.close();
          this.recreateEngine();
          const resultingError = new ConnectionError("could not establish signal connection", ConnectionErrorReason.ServerUnreachable);
          if (err instanceof Error) {
            resultingError.message = "".concat(resultingError.message, ": ").concat(err.message);
          }
          if (err instanceof ConnectionError) {
            resultingError.reason = err.reason;
            resultingError.status = err.status;
          }
          this.log.debug("error trying to establish signal connection", Object.assign(Object.assign({}, this.logContext), {
            error: err
          }));
          throw resultingError;
        }
        if (abortController.signal.aborted) {
          yield this.engine.close();
          this.recreateEngine();
          throw new ConnectionError("Connection attempt aborted", ConnectionErrorReason.Cancelled);
        }
        try {
          yield this.engine.waitForPCInitialConnection(this.connOptions.peerConnectionTimeout, abortController);
        } catch (e) {
          yield this.engine.close();
          this.recreateEngine();
          throw e;
        }
        if (isWeb() && this.options.disconnectOnPageLeave) {
          window.addEventListener("pagehide", this.onPageLeave);
          window.addEventListener("beforeunload", this.onPageLeave);
        }
        if (isWeb()) {
          document.addEventListener("freeze", this.onPageLeave);
          (_c = navigator.mediaDevices) === null || _c === void 0 ? void 0 : _c.addEventListener("devicechange", this.handleDeviceChange);
        }
        this.setAndEmitConnectionState(ConnectionState.Connected);
        this.emit(RoomEvent.Connected);
        this.registerConnectionReconcile();
      });
      this.disconnect = function() {
        for (var _len = arguments.length, args_1 = new Array(_len), _key = 0; _key < _len; _key++) {
          args_1[_key] = arguments[_key];
        }
        return __awaiter(_this, [...args_1], void 0, function() {
          var _this2 = this;
          let stopTracks = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          return function* () {
            var _a2, _b2, _c, _d;
            const unlock = yield _this2.disconnectLock.lock();
            try {
              if (_this2.state === ConnectionState.Disconnected) {
                _this2.log.debug("already disconnected", _this2.logContext);
                return;
              }
              _this2.log.info("disconnect from room", Object.assign({}, _this2.logContext));
              if (_this2.state === ConnectionState.Connecting || _this2.state === ConnectionState.Reconnecting || _this2.isResuming) {
                _this2.log.warn("abort connection attempt", _this2.logContext);
                (_a2 = _this2.abortController) === null || _a2 === void 0 ? void 0 : _a2.abort();
                (_c = (_b2 = _this2.connectFuture) === null || _b2 === void 0 ? void 0 : _b2.reject) === null || _c === void 0 ? void 0 : _c.call(_b2, new ConnectionError("Client initiated disconnect", ConnectionErrorReason.Cancelled));
                _this2.connectFuture = void 0;
              }
              if (!((_d = _this2.engine) === null || _d === void 0 ? void 0 : _d.client.isDisconnected)) {
                yield _this2.engine.client.sendLeave();
              }
              if (_this2.engine) {
                yield _this2.engine.close();
              }
              _this2.handleDisconnect(stopTracks, DisconnectReason.CLIENT_INITIATED);
              _this2.engine = void 0;
            } finally {
              unlock();
            }
          }();
        });
      };
      this.onPageLeave = () => __awaiter(this, void 0, void 0, function* () {
        this.log.info("Page leave detected, disconnecting", this.logContext);
        yield this.disconnect();
      });
      this.startAudio = () => __awaiter(this, void 0, void 0, function* () {
        const elements = [];
        const browser = getBrowser();
        if (browser && browser.os === "iOS") {
          const audioId = "livekit-dummy-audio-el";
          let dummyAudioEl = document.getElementById(audioId);
          if (!dummyAudioEl) {
            dummyAudioEl = document.createElement("audio");
            dummyAudioEl.id = audioId;
            dummyAudioEl.autoplay = true;
            dummyAudioEl.hidden = true;
            const track = getEmptyAudioStreamTrack();
            track.enabled = true;
            const stream4 = new MediaStream([track]);
            dummyAudioEl.srcObject = stream4;
            document.addEventListener("visibilitychange", () => {
              if (!dummyAudioEl) {
                return;
              }
              dummyAudioEl.srcObject = document.hidden ? null : stream4;
              if (!document.hidden) {
                this.log.debug("page visible again, triggering startAudio to resume playback and update playback status", this.logContext);
                this.startAudio();
              }
            });
            document.body.append(dummyAudioEl);
            this.once(RoomEvent.Disconnected, () => {
              dummyAudioEl === null || dummyAudioEl === void 0 ? void 0 : dummyAudioEl.remove();
              dummyAudioEl = null;
            });
          }
          elements.push(dummyAudioEl);
        }
        this.remoteParticipants.forEach((p) => {
          p.audioTrackPublications.forEach((t) => {
            if (t.track) {
              t.track.attachedElements.forEach((e) => {
                elements.push(e);
              });
            }
          });
        });
        try {
          yield Promise.all([this.acquireAudioContext(), ...elements.map((e) => {
            e.muted = false;
            return e.play();
          })]);
          this.handleAudioPlaybackStarted();
        } catch (err) {
          this.handleAudioPlaybackFailed(err);
          throw err;
        }
      });
      this.startVideo = () => __awaiter(this, void 0, void 0, function* () {
        const elements = [];
        for (const p of this.remoteParticipants.values()) {
          p.videoTrackPublications.forEach((tr) => {
            var _a2;
            (_a2 = tr.track) === null || _a2 === void 0 ? void 0 : _a2.attachedElements.forEach((el) => {
              if (!elements.includes(el)) {
                elements.push(el);
              }
            });
          });
        }
        yield Promise.all(elements.map((el) => el.play())).then(() => {
          this.handleVideoPlaybackStarted();
        }).catch((e) => {
          if (e.name === "NotAllowedError") {
            this.handleVideoPlaybackFailed();
          } else {
            this.log.warn("Resuming video playback failed, make sure you call `startVideo` directly in a user gesture handler", this.logContext);
          }
        });
      });
      this.handleRestarting = () => {
        this.clearConnectionReconcile();
        this.isResuming = false;
        for (const p of this.remoteParticipants.values()) {
          this.handleParticipantDisconnected(p.identity, p);
        }
        if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {
          this.emit(RoomEvent.Reconnecting);
        }
      };
      this.handleSignalRestarted = (joinResponse) => __awaiter(this, void 0, void 0, function* () {
        this.log.debug("signal reconnected to server, region ".concat(joinResponse.serverRegion), Object.assign(Object.assign({}, this.logContext), {
          region: joinResponse.serverRegion
        }));
        this.bufferedEvents = [];
        this.applyJoinResponse(joinResponse);
        try {
          yield this.localParticipant.republishAllTracks(void 0, true);
        } catch (error) {
          this.log.error("error trying to re-publish tracks after reconnection", Object.assign(Object.assign({}, this.logContext), {
            error
          }));
        }
        try {
          yield this.engine.waitForRestarted();
          this.log.debug("fully reconnected to server", Object.assign(Object.assign({}, this.logContext), {
            region: joinResponse.serverRegion
          }));
        } catch (_a2) {
          return;
        }
        this.setAndEmitConnectionState(ConnectionState.Connected);
        this.emit(RoomEvent.Reconnected);
        this.registerConnectionReconcile();
        this.emitBufferedEvents();
      });
      this.handleParticipantUpdates = (participantInfos) => {
        participantInfos.forEach((info) => {
          var _a2;
          if (info.identity === this.localParticipant.identity) {
            this.localParticipant.updateInfo(info);
            return;
          }
          if (info.identity === "") {
            info.identity = (_a2 = this.sidToIdentity.get(info.sid)) !== null && _a2 !== void 0 ? _a2 : "";
          }
          let remoteParticipant = this.remoteParticipants.get(info.identity);
          if (info.state === ParticipantInfo_State.DISCONNECTED) {
            this.handleParticipantDisconnected(info.identity, remoteParticipant);
          } else {
            remoteParticipant = this.getOrCreateParticipant(info.identity, info);
          }
        });
      };
      this.handleActiveSpeakersUpdate = (speakers) => {
        const activeSpeakers = [];
        const seenSids = {};
        speakers.forEach((speaker) => {
          seenSids[speaker.sid] = true;
          if (speaker.sid === this.localParticipant.sid) {
            this.localParticipant.audioLevel = speaker.level;
            this.localParticipant.setIsSpeaking(true);
            activeSpeakers.push(this.localParticipant);
          } else {
            const p = this.getRemoteParticipantBySid(speaker.sid);
            if (p) {
              p.audioLevel = speaker.level;
              p.setIsSpeaking(true);
              activeSpeakers.push(p);
            }
          }
        });
        if (!seenSids[this.localParticipant.sid]) {
          this.localParticipant.audioLevel = 0;
          this.localParticipant.setIsSpeaking(false);
        }
        this.remoteParticipants.forEach((p) => {
          if (!seenSids[p.sid]) {
            p.audioLevel = 0;
            p.setIsSpeaking(false);
          }
        });
        this.activeSpeakers = activeSpeakers;
        this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);
      };
      this.handleSpeakersChanged = (speakerUpdates) => {
        const lastSpeakers = /* @__PURE__ */ new Map();
        this.activeSpeakers.forEach((p) => {
          const remoteParticipant = this.remoteParticipants.get(p.identity);
          if (remoteParticipant && remoteParticipant.sid !== p.sid) {
            return;
          }
          lastSpeakers.set(p.sid, p);
        });
        speakerUpdates.forEach((speaker) => {
          let p = this.getRemoteParticipantBySid(speaker.sid);
          if (speaker.sid === this.localParticipant.sid) {
            p = this.localParticipant;
          }
          if (!p) {
            return;
          }
          p.audioLevel = speaker.level;
          p.setIsSpeaking(speaker.active);
          if (speaker.active) {
            lastSpeakers.set(speaker.sid, p);
          } else {
            lastSpeakers.delete(speaker.sid);
          }
        });
        const activeSpeakers = Array.from(lastSpeakers.values());
        activeSpeakers.sort((a, b) => b.audioLevel - a.audioLevel);
        this.activeSpeakers = activeSpeakers;
        this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);
      };
      this.handleStreamStateUpdate = (streamStateUpdate) => {
        streamStateUpdate.streamStates.forEach((streamState) => {
          const participant = this.getRemoteParticipantBySid(streamState.participantSid);
          if (!participant) {
            return;
          }
          const pub = participant.getTrackPublicationBySid(streamState.trackSid);
          if (!pub || !pub.track) {
            return;
          }
          const newStreamState = Track.streamStateFromProto(streamState.state);
          if (newStreamState !== pub.track.streamState) {
            pub.track.streamState = newStreamState;
            participant.emit(ParticipantEvent.TrackStreamStateChanged, pub, pub.track.streamState);
            this.emitWhenConnected(RoomEvent.TrackStreamStateChanged, pub, pub.track.streamState, participant);
          }
        });
      };
      this.handleSubscriptionPermissionUpdate = (update) => {
        const participant = this.getRemoteParticipantBySid(update.participantSid);
        if (!participant) {
          return;
        }
        const pub = participant.getTrackPublicationBySid(update.trackSid);
        if (!pub) {
          return;
        }
        pub.setAllowed(update.allowed);
      };
      this.handleSubscriptionError = (update) => {
        const participant = Array.from(this.remoteParticipants.values()).find((p) => p.trackPublications.has(update.trackSid));
        if (!participant) {
          return;
        }
        const pub = participant.getTrackPublicationBySid(update.trackSid);
        if (!pub) {
          return;
        }
        pub.setSubscriptionError(update.err);
      };
      this.handleDataPacket = (packet) => {
        const participant = this.remoteParticipants.get(packet.participantIdentity);
        if (packet.value.case === "user") {
          this.handleUserPacket(participant, packet.value.value, packet.kind);
        } else if (packet.value.case === "transcription") {
          this.handleTranscription(participant, packet.value.value);
        } else if (packet.value.case === "sipDtmf") {
          this.handleSipDtmf(participant, packet.value.value);
        } else if (packet.value.case === "chatMessage") {
          this.handleChatMessage(participant, packet.value.value);
        } else if (packet.value.case === "metrics") {
          this.handleMetrics(packet.value.value, participant);
        }
      };
      this.handleUserPacket = (participant, userPacket, kind) => {
        this.emit(RoomEvent.DataReceived, userPacket.payload, participant, kind, userPacket.topic);
        participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.DataReceived, userPacket.payload, kind);
      };
      this.handleSipDtmf = (participant, dtmf) => {
        this.emit(RoomEvent.SipDTMFReceived, dtmf, participant);
        participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.SipDTMFReceived, dtmf);
      };
      this.bufferedSegments = /* @__PURE__ */ new Map();
      this.handleTranscription = (_remoteParticipant, transcription) => {
        const participant = transcription.transcribedParticipantIdentity === this.localParticipant.identity ? this.localParticipant : this.getParticipantByIdentity(transcription.transcribedParticipantIdentity);
        const publication = participant === null || participant === void 0 ? void 0 : participant.trackPublications.get(transcription.trackId);
        const segments = extractTranscriptionSegments(transcription, this.transcriptionReceivedTimes);
        publication === null || publication === void 0 ? void 0 : publication.emit(TrackEvent.TranscriptionReceived, segments);
        participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.TranscriptionReceived, segments, publication);
        this.emit(RoomEvent.TranscriptionReceived, segments, participant, publication);
      };
      this.handleChatMessage = (participant, chatMessage) => {
        const msg = extractChatMessage(chatMessage);
        this.emit(RoomEvent.ChatMessage, msg, participant);
      };
      this.handleMetrics = (metrics, participant) => {
        this.emit(RoomEvent.MetricsReceived, metrics, participant);
      };
      this.handleAudioPlaybackStarted = () => {
        if (this.canPlaybackAudio) {
          return;
        }
        this.audioEnabled = true;
        this.emit(RoomEvent.AudioPlaybackStatusChanged, true);
      };
      this.handleAudioPlaybackFailed = (e) => {
        this.log.warn("could not playback audio", Object.assign(Object.assign({}, this.logContext), {
          error: e
        }));
        if (!this.canPlaybackAudio) {
          return;
        }
        this.audioEnabled = false;
        this.emit(RoomEvent.AudioPlaybackStatusChanged, false);
      };
      this.handleVideoPlaybackStarted = () => {
        if (this.isVideoPlaybackBlocked) {
          this.isVideoPlaybackBlocked = false;
          this.emit(RoomEvent.VideoPlaybackStatusChanged, true);
        }
      };
      this.handleVideoPlaybackFailed = () => {
        if (!this.isVideoPlaybackBlocked) {
          this.isVideoPlaybackBlocked = true;
          this.emit(RoomEvent.VideoPlaybackStatusChanged, false);
        }
      };
      this.handleDeviceChange = () => __awaiter(this, void 0, void 0, function* () {
        const availableDevices = yield DeviceManager.getInstance().getDevices(void 0, false);
        const kinds = ["audiooutput"];
        for (let kind of kinds) {
          const devicesOfKind = availableDevices.filter((d) => d.kind === kind);
          if (devicesOfKind.length > 0 && !devicesOfKind.find((deviceInfo) => deviceInfo.deviceId === this.getActiveDevice(kind))) {
            yield this.switchActiveDevice(kind, devicesOfKind[0].deviceId);
          }
        }
        this.emit(RoomEvent.MediaDevicesChanged);
      });
      this.handleRoomUpdate = (room) => {
        const oldRoom = this.roomInfo;
        this.roomInfo = room;
        if (oldRoom && oldRoom.metadata !== room.metadata) {
          this.emitWhenConnected(RoomEvent.RoomMetadataChanged, room.metadata);
        }
        if ((oldRoom === null || oldRoom === void 0 ? void 0 : oldRoom.activeRecording) !== room.activeRecording) {
          this.emitWhenConnected(RoomEvent.RecordingStatusChanged, room.activeRecording);
        }
      };
      this.handleConnectionQualityUpdate = (update) => {
        update.updates.forEach((info) => {
          if (info.participantSid === this.localParticipant.sid) {
            this.localParticipant.setConnectionQuality(info.quality);
            return;
          }
          const participant = this.getRemoteParticipantBySid(info.participantSid);
          if (participant) {
            participant.setConnectionQuality(info.quality);
          }
        });
      };
      this.onLocalParticipantMetadataChanged = (metadata) => {
        this.emit(RoomEvent.ParticipantMetadataChanged, metadata, this.localParticipant);
      };
      this.onLocalParticipantNameChanged = (name) => {
        this.emit(RoomEvent.ParticipantNameChanged, name, this.localParticipant);
      };
      this.onLocalAttributesChanged = (changedAttributes) => {
        this.emit(RoomEvent.ParticipantAttributesChanged, changedAttributes, this.localParticipant);
      };
      this.onLocalTrackMuted = (pub) => {
        this.emit(RoomEvent.TrackMuted, pub, this.localParticipant);
      };
      this.onLocalTrackUnmuted = (pub) => {
        this.emit(RoomEvent.TrackUnmuted, pub, this.localParticipant);
      };
      this.onTrackProcessorUpdate = (processor) => {
        var _a2;
        (_a2 = processor === null || processor === void 0 ? void 0 : processor.onPublish) === null || _a2 === void 0 ? void 0 : _a2.call(processor, this);
      };
      this.onLocalTrackPublished = (pub) => __awaiter(this, void 0, void 0, function* () {
        var _a2, _b2, _c, _d, _e, _f;
        (_a2 = pub.track) === null || _a2 === void 0 ? void 0 : _a2.on(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate);
        (_b2 = pub.track) === null || _b2 === void 0 ? void 0 : _b2.on(TrackEvent.Restarted, this.onLocalTrackRestarted);
        (_e = (_d = (_c = pub.track) === null || _c === void 0 ? void 0 : _c.getProcessor()) === null || _d === void 0 ? void 0 : _d.onPublish) === null || _e === void 0 ? void 0 : _e.call(_d, this);
        this.emit(RoomEvent.LocalTrackPublished, pub, this.localParticipant);
        if (pub.track instanceof LocalAudioTrack) {
          const trackIsSilent = yield pub.track.checkForSilence();
          if (trackIsSilent) {
            this.emit(RoomEvent.LocalAudioSilenceDetected, pub);
          }
        }
        const deviceId = yield (_f = pub.track) === null || _f === void 0 ? void 0 : _f.getDeviceId();
        const deviceKind = sourceToKind(pub.source);
        if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {
          this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);
          this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);
        }
      });
      this.onLocalTrackUnpublished = (pub) => {
        var _a2, _b2;
        (_a2 = pub.track) === null || _a2 === void 0 ? void 0 : _a2.off(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate);
        (_b2 = pub.track) === null || _b2 === void 0 ? void 0 : _b2.off(TrackEvent.Restarted, this.onLocalTrackRestarted);
        this.emit(RoomEvent.LocalTrackUnpublished, pub, this.localParticipant);
      };
      this.onLocalTrackRestarted = (track) => __awaiter(this, void 0, void 0, function* () {
        const deviceId = yield track.getDeviceId(false);
        const deviceKind = sourceToKind(track.source);
        if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {
          this.log.debug("local track restarted, setting ".concat(deviceKind, " ").concat(deviceId, " active"), this.logContext);
          this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);
          this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);
        }
      });
      this.onLocalConnectionQualityChanged = (quality) => {
        this.emit(RoomEvent.ConnectionQualityChanged, quality, this.localParticipant);
      };
      this.onMediaDevicesError = (e) => {
        this.emit(RoomEvent.MediaDevicesError, e);
      };
      this.onLocalParticipantPermissionsChanged = (prevPermissions) => {
        this.emit(RoomEvent.ParticipantPermissionsChanged, prevPermissions, this.localParticipant);
      };
      this.onLocalChatMessageSent = (msg) => {
        this.emit(RoomEvent.ChatMessage, msg, this.localParticipant);
      };
      this.setMaxListeners(100);
      this.remoteParticipants = /* @__PURE__ */ new Map();
      this.sidToIdentity = /* @__PURE__ */ new Map();
      this.options = Object.assign(Object.assign({}, roomOptionDefaults), options);
      this.log = getLogger((_a = this.options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Room);
      this.transcriptionReceivedTimes = /* @__PURE__ */ new Map();
      this.options.audioCaptureDefaults = Object.assign(Object.assign({}, audioDefaults), options === null || options === void 0 ? void 0 : options.audioCaptureDefaults);
      this.options.videoCaptureDefaults = Object.assign(Object.assign({}, videoDefaults), options === null || options === void 0 ? void 0 : options.videoCaptureDefaults);
      this.options.publishDefaults = Object.assign(Object.assign({}, publishDefaults), options === null || options === void 0 ? void 0 : options.publishDefaults);
      this.maybeCreateEngine();
      this.disconnectLock = new h();
      this.localParticipant = new LocalParticipant("", "", this.engine, this.options);
      if (this.options.videoCaptureDefaults.deviceId) {
        this.localParticipant.activeDeviceMap.set("videoinput", unwrapConstraint(this.options.videoCaptureDefaults.deviceId));
      }
      if (this.options.audioCaptureDefaults.deviceId) {
        this.localParticipant.activeDeviceMap.set("audioinput", unwrapConstraint(this.options.audioCaptureDefaults.deviceId));
      }
      if ((_b = this.options.audioOutput) === null || _b === void 0 ? void 0 : _b.deviceId) {
        this.switchActiveDevice("audiooutput", unwrapConstraint(this.options.audioOutput.deviceId)).catch((e) => this.log.warn("Could not set audio output: ".concat(e.message), this.logContext));
      }
      if (this.options.e2ee) {
        this.setupE2EE();
      }
    }
    /**
     * @experimental
     */
    setE2EEEnabled(enabled) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.e2eeManager) {
          yield Promise.all([this.localParticipant.setE2EEEnabled(enabled)]);
          if (this.localParticipant.identity !== "") {
            this.e2eeManager.setParticipantCryptorEnabled(enabled, this.localParticipant.identity);
          }
        } else {
          throw Error("e2ee not configured, please set e2ee settings within the room options");
        }
      });
    }
    setupE2EE() {
      var _a;
      if (this.options.e2ee) {
        if ("e2eeManager" in this.options.e2ee) {
          this.e2eeManager = this.options.e2ee.e2eeManager;
        } else {
          this.e2eeManager = new E2EEManager(this.options.e2ee);
        }
        this.e2eeManager.on(EncryptionEvent.ParticipantEncryptionStatusChanged, (enabled, participant) => {
          if (participant instanceof LocalParticipant) {
            this.isE2EEEnabled = enabled;
          }
          this.emit(RoomEvent.ParticipantEncryptionStatusChanged, enabled, participant);
        });
        this.e2eeManager.on(EncryptionEvent.EncryptionError, (error) => this.emit(RoomEvent.EncryptionError, error));
        (_a = this.e2eeManager) === null || _a === void 0 ? void 0 : _a.setup(this);
      }
    }
    get logContext() {
      var _a;
      return {
        room: this.name,
        roomID: (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.sid,
        participant: this.localParticipant.identity,
        pID: this.localParticipant.sid
      };
    }
    /**
     * if the current room has a participant with `recorder: true` in its JWT grant
     **/
    get isRecording() {
      var _a, _b;
      return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.activeRecording) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * server assigned unique room id.
     * returns once a sid has been issued by the server.
     */
    getSid() {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.state === ConnectionState.Disconnected) {
          return "";
        }
        if (this.roomInfo && this.roomInfo.sid !== "") {
          return this.roomInfo.sid;
        }
        return new Promise((resolve, reject) => {
          const handleRoomUpdate = (roomInfo) => {
            if (roomInfo.sid !== "") {
              this.engine.off(EngineEvent.RoomUpdate, handleRoomUpdate);
              resolve(roomInfo.sid);
            }
          };
          this.engine.on(EngineEvent.RoomUpdate, handleRoomUpdate);
          this.once(RoomEvent.Disconnected, () => {
            this.engine.off(EngineEvent.RoomUpdate, handleRoomUpdate);
            reject("Room disconnected before room server id was available");
          });
        });
      });
    }
    /** user assigned name, derived from JWT token */
    get name() {
      var _a, _b;
      return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : "";
    }
    /** room metadata */
    get metadata() {
      var _a;
      return (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.metadata;
    }
    get numParticipants() {
      var _a, _b;
      return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numParticipants) !== null && _b !== void 0 ? _b : 0;
    }
    get numPublishers() {
      var _a, _b;
      return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numPublishers) !== null && _b !== void 0 ? _b : 0;
    }
    maybeCreateEngine() {
      if (this.engine && !this.engine.isClosed) {
        return;
      }
      this.engine = new RTCEngine(this.options);
      this.engine.on(EngineEvent.ParticipantUpdate, this.handleParticipantUpdates).on(EngineEvent.RoomUpdate, this.handleRoomUpdate).on(EngineEvent.SpeakersChanged, this.handleSpeakersChanged).on(EngineEvent.StreamStateChanged, this.handleStreamStateUpdate).on(EngineEvent.ConnectionQualityUpdate, this.handleConnectionQualityUpdate).on(EngineEvent.SubscriptionError, this.handleSubscriptionError).on(EngineEvent.SubscriptionPermissionUpdate, this.handleSubscriptionPermissionUpdate).on(EngineEvent.MediaTrackAdded, (mediaTrack, stream4, receiver) => {
        this.onTrackAdded(mediaTrack, stream4, receiver);
      }).on(EngineEvent.Disconnected, (reason) => {
        this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, reason);
      }).on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate).on(EngineEvent.DataPacketReceived, this.handleDataPacket).on(EngineEvent.Resuming, () => {
        this.clearConnectionReconcile();
        this.isResuming = true;
        this.log.info("Resuming signal connection", this.logContext);
        if (this.setAndEmitConnectionState(ConnectionState.SignalReconnecting)) {
          this.emit(RoomEvent.SignalReconnecting);
        }
      }).on(EngineEvent.Resumed, () => {
        this.registerConnectionReconcile();
        this.isResuming = false;
        this.log.info("Resumed signal connection", this.logContext);
        this.updateSubscriptions();
        this.emitBufferedEvents();
        if (this.setAndEmitConnectionState(ConnectionState.Connected)) {
          this.emit(RoomEvent.Reconnected);
        }
      }).on(EngineEvent.SignalResumed, () => {
        this.bufferedEvents = [];
        if (this.state === ConnectionState.Reconnecting || this.isResuming) {
          this.sendSyncState();
        }
      }).on(EngineEvent.Restarting, this.handleRestarting).on(EngineEvent.SignalRestarted, this.handleSignalRestarted).on(EngineEvent.Offline, () => {
        if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {
          this.emit(RoomEvent.Reconnecting);
        }
      }).on(EngineEvent.DCBufferStatusChanged, (status, kind) => {
        this.emit(RoomEvent.DCBufferStatusChanged, status, kind);
      }).on(EngineEvent.LocalTrackSubscribed, (subscribedSid) => {
        const trackPublication = this.localParticipant.getTrackPublications().find((_ref2) => {
          let {
            trackSid
          } = _ref2;
          return trackSid === subscribedSid;
        });
        if (!trackPublication) {
          this.log.warn("could not find local track subscription for subscribed event", this.logContext);
          return;
        }
        this.localParticipant.emit(ParticipantEvent.LocalTrackSubscribed, trackPublication);
        this.emitWhenConnected(RoomEvent.LocalTrackSubscribed, trackPublication, this.localParticipant);
      });
      if (this.localParticipant) {
        this.localParticipant.setupEngine(this.engine);
      }
      if (this.e2eeManager) {
        this.e2eeManager.setupEngine(this.engine);
      }
    }
    /**
     * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.
     * In particular, it requests device permissions by default if needed
     * and makes sure the returned device does not consist of dummy devices
     * @param kind
     * @returns a list of available local devices
     */
    static getLocalDevices(kind) {
      let requestPermissions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      return DeviceManager.getInstance().getDevices(kind, requestPermissions);
    }
    /**
     * prepareConnection should be called as soon as the page is loaded, in order
     * to speed up the connection attempt. This function will
     * - perform DNS resolution and pre-warm the DNS cache
     * - establish TLS connection and cache TLS keys
     *
     * With LiveKit Cloud, it will also determine the best edge data center for
     * the current client to connect to if a token is provided.
     */
    prepareConnection(url2, token) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.state !== ConnectionState.Disconnected) {
          return;
        }
        this.log.debug("prepareConnection to ".concat(url2), this.logContext);
        try {
          if (isCloud(new URL(url2)) && token) {
            this.regionUrlProvider = new RegionUrlProvider(url2, token);
            const regionUrl = yield this.regionUrlProvider.getNextBestRegionUrl();
            if (regionUrl && this.state === ConnectionState.Disconnected) {
              this.regionUrl = regionUrl;
              yield fetch(toHttpUrl(regionUrl), {
                method: "HEAD"
              });
              this.log.debug("prepared connection to ".concat(regionUrl), this.logContext);
            }
          } else {
            yield fetch(toHttpUrl(url2), {
              method: "HEAD"
            });
          }
        } catch (e) {
          this.log.warn("could not prepare connection", Object.assign(Object.assign({}, this.logContext), {
            error: e
          }));
        }
      });
    }
    /**
     * retrieves a participant by identity
     * @param identity
     * @returns
     */
    getParticipantByIdentity(identity) {
      if (this.localParticipant.identity === identity) {
        return this.localParticipant;
      }
      return this.remoteParticipants.get(identity);
    }
    clearConnectionFutures() {
      this.connectFuture = void 0;
    }
    /**
     * @internal for testing
     */
    simulateScenario(scenario, arg) {
      return __awaiter(this, void 0, void 0, function* () {
        let postAction = () => {
        };
        let req;
        switch (scenario) {
          case "signal-reconnect":
            yield this.engine.client.handleOnClose("simulate disconnect");
            break;
          case "speaker":
            req = new SimulateScenario({
              scenario: {
                case: "speakerUpdate",
                value: 3
              }
            });
            break;
          case "node-failure":
            req = new SimulateScenario({
              scenario: {
                case: "nodeFailure",
                value: true
              }
            });
            break;
          case "server-leave":
            req = new SimulateScenario({
              scenario: {
                case: "serverLeave",
                value: true
              }
            });
            break;
          case "migration":
            req = new SimulateScenario({
              scenario: {
                case: "migration",
                value: true
              }
            });
            break;
          case "resume-reconnect":
            this.engine.failNext();
            yield this.engine.client.handleOnClose("simulate resume-disconnect");
            break;
          case "disconnect-signal-on-resume":
            postAction = () => __awaiter(this, void 0, void 0, function* () {
              yield this.engine.client.handleOnClose("simulate resume-disconnect");
            });
            req = new SimulateScenario({
              scenario: {
                case: "disconnectSignalOnResume",
                value: true
              }
            });
            break;
          case "disconnect-signal-on-resume-no-messages":
            postAction = () => __awaiter(this, void 0, void 0, function* () {
              yield this.engine.client.handleOnClose("simulate resume-disconnect");
            });
            req = new SimulateScenario({
              scenario: {
                case: "disconnectSignalOnResumeNoMessages",
                value: true
              }
            });
            break;
          case "full-reconnect":
            this.engine.fullReconnectOnNext = true;
            yield this.engine.client.handleOnClose("simulate full-reconnect");
            break;
          case "force-tcp":
          case "force-tls":
            req = new SimulateScenario({
              scenario: {
                case: "switchCandidateProtocol",
                value: scenario === "force-tls" ? 2 : 1
              }
            });
            postAction = () => __awaiter(this, void 0, void 0, function* () {
              const onLeave = this.engine.client.onLeave;
              if (onLeave) {
                onLeave(new LeaveRequest({
                  reason: DisconnectReason.CLIENT_INITIATED,
                  action: LeaveRequest_Action.RECONNECT
                }));
              }
            });
            break;
          case "subscriber-bandwidth":
            if (arg === void 0 || typeof arg !== "number") {
              throw new Error("subscriber-bandwidth requires a number as argument");
            }
            req = new SimulateScenario({
              scenario: {
                case: "subscriberBandwidth",
                value: BigInt(arg)
              }
            });
            break;
          case "leave-full-reconnect":
            req = new SimulateScenario({
              scenario: {
                case: "leaveRequestFullReconnect",
                value: true
              }
            });
        }
        if (req) {
          yield this.engine.client.sendSimulateScenario(req);
          yield postAction();
        }
      });
    }
    /**
     * Returns true if audio playback is enabled
     */
    get canPlaybackAudio() {
      return this.audioEnabled;
    }
    /**
     * Returns true if video playback is enabled
     */
    get canPlaybackVideo() {
      return !this.isVideoPlaybackBlocked;
    }
    getActiveDevice(kind) {
      return this.localParticipant.activeDeviceMap.get(kind);
    }
    /**
     * Switches all active devices used in this room to the given device.
     *
     * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)
     *
     * @param kind use `videoinput` for camera track,
     *  `audioinput` for microphone track,
     *  `audiooutput` to set speaker for all incoming audio tracks
     * @param deviceId
     */
    switchActiveDevice(kind_1, deviceId_1) {
      return __awaiter(this, arguments, void 0, function(kind, deviceId) {
        var _this3 = this;
        let exact = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        return function* () {
          var _a, _b, _c, _d, _e, _f;
          var _g;
          let deviceHasChanged = false;
          let success = true;
          const deviceConstraint = exact ? {
            exact: deviceId
          } : deviceId;
          if (kind === "audioinput") {
            const prevDeviceId = (_a = _this3.getActiveDevice(kind)) !== null && _a !== void 0 ? _a : _this3.options.audioCaptureDefaults.deviceId;
            _this3.options.audioCaptureDefaults.deviceId = deviceConstraint;
            deviceHasChanged = prevDeviceId !== deviceConstraint;
            const tracks = Array.from(_this3.localParticipant.audioTrackPublications.values()).filter((track) => track.source === Track.Source.Microphone);
            try {
              success = (yield Promise.all(tracks.map((t) => {
                var _a2;
                return (_a2 = t.audioTrack) === null || _a2 === void 0 ? void 0 : _a2.setDeviceId(deviceConstraint);
              }))).every((val) => val === true);
            } catch (e) {
              _this3.options.audioCaptureDefaults.deviceId = prevDeviceId;
              throw e;
            }
          } else if (kind === "videoinput") {
            const prevDeviceId = (_b = _this3.getActiveDevice(kind)) !== null && _b !== void 0 ? _b : _this3.options.videoCaptureDefaults.deviceId;
            _this3.options.videoCaptureDefaults.deviceId = deviceConstraint;
            deviceHasChanged = prevDeviceId !== deviceConstraint;
            const tracks = Array.from(_this3.localParticipant.videoTrackPublications.values()).filter((track) => track.source === Track.Source.Camera);
            try {
              success = (yield Promise.all(tracks.map((t) => {
                var _a2;
                return (_a2 = t.videoTrack) === null || _a2 === void 0 ? void 0 : _a2.setDeviceId(deviceConstraint);
              }))).every((val) => val === true);
            } catch (e) {
              _this3.options.videoCaptureDefaults.deviceId = prevDeviceId;
              throw e;
            }
          } else if (kind === "audiooutput") {
            if (!supportsSetSinkId() && !_this3.options.webAudioMix || _this3.options.webAudioMix && _this3.audioContext && !("setSinkId" in _this3.audioContext)) {
              throw new Error("cannot switch audio output, setSinkId not supported");
            }
            if (_this3.options.webAudioMix) {
              deviceId = (_c = yield DeviceManager.getInstance().normalizeDeviceId("audiooutput", deviceId)) !== null && _c !== void 0 ? _c : "";
            }
            (_d = (_g = _this3.options).audioOutput) !== null && _d !== void 0 ? _d : _g.audioOutput = {};
            const prevDeviceId = (_e = _this3.getActiveDevice(kind)) !== null && _e !== void 0 ? _e : _this3.options.audioOutput.deviceId;
            _this3.options.audioOutput.deviceId = deviceId;
            deviceHasChanged = prevDeviceId !== deviceConstraint;
            try {
              if (_this3.options.webAudioMix) {
                (_f = _this3.audioContext) === null || _f === void 0 ? void 0 : _f.setSinkId(deviceId);
              }
              yield Promise.all(Array.from(_this3.remoteParticipants.values()).map((p) => p.setAudioOutput({
                deviceId
              })));
            } catch (e) {
              _this3.options.audioOutput.deviceId = prevDeviceId;
              throw e;
            }
          }
          if (deviceHasChanged && success) {
            _this3.localParticipant.activeDeviceMap.set(kind, deviceId);
            _this3.emit(RoomEvent.ActiveDeviceChanged, kind, deviceId);
          }
          return success;
        }();
      });
    }
    setupLocalParticipantEvents() {
      this.localParticipant.on(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).on(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).on(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged).on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).on(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).on(ParticipantEvent.AudioStreamAcquired, this.startAudio).on(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent).on(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);
    }
    recreateEngine() {
      var _a;
      (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();
      this.engine = void 0;
      this.isResuming = false;
      this.remoteParticipants.clear();
      this.sidToIdentity.clear();
      this.bufferedEvents = [];
      this.maybeCreateEngine();
    }
    onTrackAdded(mediaTrack, stream4, receiver) {
      if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {
        const reconnectedHandler = () => {
          this.onTrackAdded(mediaTrack, stream4, receiver);
          cleanup();
        };
        const cleanup = () => {
          this.off(RoomEvent.Reconnected, reconnectedHandler);
          this.off(RoomEvent.Connected, reconnectedHandler);
          this.off(RoomEvent.Disconnected, cleanup);
        };
        this.once(RoomEvent.Reconnected, reconnectedHandler);
        this.once(RoomEvent.Connected, reconnectedHandler);
        this.once(RoomEvent.Disconnected, cleanup);
        return;
      }
      if (this.state === ConnectionState.Disconnected) {
        this.log.warn("skipping incoming track after Room disconnected", this.logContext);
        return;
      }
      const parts = unpackStreamId(stream4.id);
      const participantSid = parts[0];
      let streamId = parts[1];
      let trackId = mediaTrack.id;
      if (streamId && streamId.startsWith("TR")) trackId = streamId;
      if (participantSid === this.localParticipant.sid) {
        this.log.warn("tried to create RemoteParticipant for local participant", this.logContext);
        return;
      }
      const participant = Array.from(this.remoteParticipants.values()).find((p) => p.sid === participantSid);
      if (!participant) {
        this.log.error("Tried to add a track for a participant, that's not present. Sid: ".concat(participantSid), this.logContext);
        return;
      }
      let adaptiveStreamSettings;
      if (this.options.adaptiveStream) {
        if (typeof this.options.adaptiveStream === "object") {
          adaptiveStreamSettings = this.options.adaptiveStream;
        } else {
          adaptiveStreamSettings = {};
        }
      }
      participant.addSubscribedMediaTrack(mediaTrack, trackId, stream4, receiver, adaptiveStreamSettings);
    }
    handleDisconnect() {
      let shouldStopTracks = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      let reason = arguments.length > 1 ? arguments[1] : void 0;
      var _a;
      this.clearConnectionReconcile();
      this.isResuming = false;
      this.bufferedEvents = [];
      this.transcriptionReceivedTimes.clear();
      if (this.state === ConnectionState.Disconnected) {
        return;
      }
      this.regionUrl = void 0;
      try {
        this.remoteParticipants.forEach((p) => {
          p.trackPublications.forEach((pub) => {
            p.unpublishTrack(pub.trackSid);
          });
        });
        this.localParticipant.trackPublications.forEach((pub) => {
          var _a2, _b, _c;
          if (pub.track) {
            this.localParticipant.unpublishTrack(pub.track, shouldStopTracks);
          }
          if (shouldStopTracks) {
            (_a2 = pub.track) === null || _a2 === void 0 ? void 0 : _a2.detach();
            (_b = pub.track) === null || _b === void 0 ? void 0 : _b.stop();
          } else {
            (_c = pub.track) === null || _c === void 0 ? void 0 : _c.stopMonitor();
          }
        });
        this.localParticipant.off(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).off(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).off(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged).off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).off(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).off(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).off(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).off(ParticipantEvent.AudioStreamAcquired, this.startAudio).off(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent).off(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);
        this.localParticipant.trackPublications.clear();
        this.localParticipant.videoTrackPublications.clear();
        this.localParticipant.audioTrackPublications.clear();
        this.remoteParticipants.clear();
        this.sidToIdentity.clear();
        this.activeSpeakers = [];
        if (this.audioContext && typeof this.options.webAudioMix === "boolean") {
          this.audioContext.close();
          this.audioContext = void 0;
        }
        if (isWeb()) {
          window.removeEventListener("beforeunload", this.onPageLeave);
          window.removeEventListener("pagehide", this.onPageLeave);
          window.removeEventListener("freeze", this.onPageLeave);
          (_a = navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.removeEventListener("devicechange", this.handleDeviceChange);
        }
      } finally {
        this.setAndEmitConnectionState(ConnectionState.Disconnected);
        this.emit(RoomEvent.Disconnected, reason);
      }
    }
    handleParticipantDisconnected(identity, participant) {
      var _a;
      this.remoteParticipants.delete(identity);
      if (!participant) {
        return;
      }
      participant.trackPublications.forEach((publication) => {
        participant.unpublishTrack(publication.trackSid, true);
      });
      this.emit(RoomEvent.ParticipantDisconnected, participant);
      (_a = this.localParticipant) === null || _a === void 0 ? void 0 : _a.handleParticipantDisconnected(participant.identity);
    }
    acquireAudioContext() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        if (typeof this.options.webAudioMix !== "boolean" && this.options.webAudioMix.audioContext) {
          this.audioContext = this.options.webAudioMix.audioContext;
        } else if (!this.audioContext || this.audioContext.state === "closed") {
          this.audioContext = (_a = getNewAudioContext()) !== null && _a !== void 0 ? _a : void 0;
        }
        if (this.audioContext && this.audioContext.state === "suspended") {
          try {
            yield this.audioContext.resume();
          } catch (e) {
            this.log.warn("Could not resume audio context", Object.assign(Object.assign({}, this.logContext), {
              error: e
            }));
          }
        }
        if (this.options.webAudioMix) {
          this.remoteParticipants.forEach((participant) => participant.setAudioContext(this.audioContext));
        }
        this.localParticipant.setAudioContext(this.audioContext);
        const newContextIsRunning = ((_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.state) === "running";
        if (newContextIsRunning !== this.canPlaybackAudio) {
          this.audioEnabled = newContextIsRunning;
          this.emit(RoomEvent.AudioPlaybackStatusChanged, newContextIsRunning);
        }
      });
    }
    createParticipant(identity, info) {
      var _a;
      let participant;
      if (info) {
        participant = RemoteParticipant.fromParticipantInfo(this.engine.client, info, {
          loggerContextCb: () => this.logContext,
          loggerName: this.options.loggerName
        });
      } else {
        participant = new RemoteParticipant(this.engine.client, "", identity, void 0, void 0, void 0, {
          loggerContextCb: () => this.logContext,
          loggerName: this.options.loggerName
        });
      }
      if (this.options.webAudioMix) {
        participant.setAudioContext(this.audioContext);
      }
      if ((_a = this.options.audioOutput) === null || _a === void 0 ? void 0 : _a.deviceId) {
        participant.setAudioOutput(this.options.audioOutput).catch((e) => this.log.warn("Could not set audio output: ".concat(e.message), this.logContext));
      }
      return participant;
    }
    getOrCreateParticipant(identity, info) {
      if (this.remoteParticipants.has(identity)) {
        const existingParticipant = this.remoteParticipants.get(identity);
        if (info) {
          const wasUpdated = existingParticipant.updateInfo(info);
          if (wasUpdated) {
            this.sidToIdentity.set(info.sid, info.identity);
          }
        }
        return existingParticipant;
      }
      const participant = this.createParticipant(identity, info);
      this.remoteParticipants.set(identity, participant);
      this.sidToIdentity.set(info.sid, info.identity);
      this.emitWhenConnected(RoomEvent.ParticipantConnected, participant);
      participant.on(ParticipantEvent.TrackPublished, (trackPublication) => {
        this.emitWhenConnected(RoomEvent.TrackPublished, trackPublication, participant);
      }).on(ParticipantEvent.TrackSubscribed, (track, publication) => {
        if (track.kind === Track.Kind.Audio) {
          track.on(TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted);
          track.on(TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed);
        } else if (track.kind === Track.Kind.Video) {
          track.on(TrackEvent.VideoPlaybackFailed, this.handleVideoPlaybackFailed);
          track.on(TrackEvent.VideoPlaybackStarted, this.handleVideoPlaybackStarted);
        }
        this.emit(RoomEvent.TrackSubscribed, track, publication, participant);
      }).on(ParticipantEvent.TrackUnpublished, (publication) => {
        this.emit(RoomEvent.TrackUnpublished, publication, participant);
      }).on(ParticipantEvent.TrackUnsubscribed, (track, publication) => {
        this.emit(RoomEvent.TrackUnsubscribed, track, publication, participant);
      }).on(ParticipantEvent.TrackSubscriptionFailed, (sid) => {
        this.emit(RoomEvent.TrackSubscriptionFailed, sid, participant);
      }).on(ParticipantEvent.TrackMuted, (pub) => {
        this.emitWhenConnected(RoomEvent.TrackMuted, pub, participant);
      }).on(ParticipantEvent.TrackUnmuted, (pub) => {
        this.emitWhenConnected(RoomEvent.TrackUnmuted, pub, participant);
      }).on(ParticipantEvent.ParticipantMetadataChanged, (metadata) => {
        this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, metadata, participant);
      }).on(ParticipantEvent.ParticipantNameChanged, (name) => {
        this.emitWhenConnected(RoomEvent.ParticipantNameChanged, name, participant);
      }).on(ParticipantEvent.AttributesChanged, (changedAttributes) => {
        this.emitWhenConnected(RoomEvent.ParticipantAttributesChanged, changedAttributes, participant);
      }).on(ParticipantEvent.ConnectionQualityChanged, (quality) => {
        this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, quality, participant);
      }).on(ParticipantEvent.ParticipantPermissionsChanged, (prevPermissions) => {
        this.emitWhenConnected(RoomEvent.ParticipantPermissionsChanged, prevPermissions, participant);
      }).on(ParticipantEvent.TrackSubscriptionStatusChanged, (pub, status) => {
        this.emitWhenConnected(RoomEvent.TrackSubscriptionStatusChanged, pub, status, participant);
      }).on(ParticipantEvent.TrackSubscriptionFailed, (trackSid, error) => {
        this.emit(RoomEvent.TrackSubscriptionFailed, trackSid, participant, error);
      }).on(ParticipantEvent.TrackSubscriptionPermissionChanged, (pub, status) => {
        this.emitWhenConnected(RoomEvent.TrackSubscriptionPermissionChanged, pub, status, participant);
      });
      if (info) {
        participant.updateInfo(info);
      }
      return participant;
    }
    sendSyncState() {
      const remoteTracks = Array.from(this.remoteParticipants.values()).reduce((acc, participant) => {
        acc.push(...participant.getTrackPublications());
        return acc;
      }, []);
      const localTracks = this.localParticipant.getTrackPublications();
      this.engine.sendSyncState(remoteTracks, localTracks);
    }
    /**
     * After resuming, we'll need to notify the server of the current
     * subscription settings.
     */
    updateSubscriptions() {
      for (const p of this.remoteParticipants.values()) {
        for (const pub of p.videoTrackPublications.values()) {
          if (pub.isSubscribed && pub instanceof RemoteTrackPublication) {
            pub.emitTrackUpdate();
          }
        }
      }
    }
    getRemoteParticipantBySid(sid) {
      const identity = this.sidToIdentity.get(sid);
      if (identity) {
        return this.remoteParticipants.get(identity);
      }
    }
    registerConnectionReconcile() {
      this.clearConnectionReconcile();
      let consecutiveFailures = 0;
      this.connectionReconcileInterval = CriticalTimers.setInterval(() => {
        if (
          // ensure we didn't tear it down
          !this.engine || // engine detected close, but Room missed it
          this.engine.isClosed || // transports failed without notifying engine
          !this.engine.verifyTransport()
        ) {
          consecutiveFailures++;
          this.log.warn("detected connection state mismatch", Object.assign(Object.assign({}, this.logContext), {
            numFailures: consecutiveFailures,
            engine: this.engine ? {
              closed: this.engine.isClosed,
              transportsConnected: this.engine.verifyTransport()
            } : void 0
          }));
          if (consecutiveFailures >= 3) {
            this.recreateEngine();
            this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, DisconnectReason.STATE_MISMATCH);
          }
        } else {
          consecutiveFailures = 0;
        }
      }, connectionReconcileFrequency);
    }
    clearConnectionReconcile() {
      if (this.connectionReconcileInterval) {
        CriticalTimers.clearInterval(this.connectionReconcileInterval);
      }
    }
    setAndEmitConnectionState(state) {
      if (state === this.state) {
        return false;
      }
      this.state = state;
      this.emit(RoomEvent.ConnectionStateChanged, this.state);
      return true;
    }
    emitBufferedEvents() {
      this.bufferedEvents.forEach((_ref3) => {
        let [ev, args] = _ref3;
        this.emit(ev, ...args);
      });
      this.bufferedEvents = [];
    }
    emitWhenConnected(event) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      if (this.state === ConnectionState.Reconnecting || this.isResuming || !this.engine || this.engine.pendingReconnect) {
        this.bufferedEvents.push([event, args]);
      } else if (this.state === ConnectionState.Connected) {
        return this.emit(event, ...args);
      }
      return false;
    }
    /**
     * Allows to populate a room with simulated participants.
     * No actual connection to a server will be established, all state is
     * @experimental
     */
    simulateParticipants(options) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        const publishOptions = Object.assign({
          audio: true,
          video: true,
          useRealTracks: false
        }, options.publish);
        const participantOptions = Object.assign({
          count: 9,
          audio: false,
          video: true,
          aspectRatios: [1.66, 1.7, 1.3]
        }, options.participants);
        this.handleDisconnect();
        this.roomInfo = new Room$1({
          sid: "RM_SIMULATED",
          name: "simulated-room",
          emptyTimeout: 0,
          maxParticipants: 0,
          creationTime: protoInt64.parse((/* @__PURE__ */ new Date()).getTime()),
          metadata: "",
          numParticipants: 1,
          numPublishers: 1,
          turnPassword: "",
          enabledCodecs: [],
          activeRecording: false
        });
        this.localParticipant.updateInfo(new ParticipantInfo({
          identity: "simulated-local",
          name: "local-name"
        }));
        this.setupLocalParticipantEvents();
        this.emit(RoomEvent.SignalConnected);
        this.emit(RoomEvent.Connected);
        this.setAndEmitConnectionState(ConnectionState.Connected);
        if (publishOptions.video) {
          const camPub = new LocalTrackPublication(Track.Kind.Video, new TrackInfo({
            source: TrackSource.CAMERA,
            sid: Math.floor(Math.random() * 1e4).toString(),
            type: TrackType.AUDIO,
            name: "video-dummy"
          }), new LocalVideoTrack(publishOptions.useRealTracks ? (yield window.navigator.mediaDevices.getUserMedia({
            video: true
          })).getVideoTracks()[0] : createDummyVideoStreamTrack(160 * ((_a = participantOptions.aspectRatios[0]) !== null && _a !== void 0 ? _a : 1), 160, true, true), void 0, false, {
            loggerName: this.options.loggerName,
            loggerContextCb: () => this.logContext
          }), {
            loggerName: this.options.loggerName,
            loggerContextCb: () => this.logContext
          });
          this.localParticipant.addTrackPublication(camPub);
          this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, camPub);
        }
        if (publishOptions.audio) {
          const audioPub = new LocalTrackPublication(Track.Kind.Audio, new TrackInfo({
            source: TrackSource.MICROPHONE,
            sid: Math.floor(Math.random() * 1e4).toString(),
            type: TrackType.AUDIO
          }), new LocalAudioTrack(publishOptions.useRealTracks ? (yield navigator.mediaDevices.getUserMedia({
            audio: true
          })).getAudioTracks()[0] : getEmptyAudioStreamTrack(), void 0, false, this.audioContext, {
            loggerName: this.options.loggerName,
            loggerContextCb: () => this.logContext
          }), {
            loggerName: this.options.loggerName,
            loggerContextCb: () => this.logContext
          });
          this.localParticipant.addTrackPublication(audioPub);
          this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, audioPub);
        }
        for (let i = 0; i < participantOptions.count - 1; i += 1) {
          let info = new ParticipantInfo({
            sid: Math.floor(Math.random() * 1e4).toString(),
            identity: "simulated-".concat(i),
            state: ParticipantInfo_State.ACTIVE,
            tracks: [],
            joinedAt: protoInt64.parse(Date.now())
          });
          const p = this.getOrCreateParticipant(info.identity, info);
          if (participantOptions.video) {
            const dummyVideo = createDummyVideoStreamTrack(160 * ((_b = participantOptions.aspectRatios[i % participantOptions.aspectRatios.length]) !== null && _b !== void 0 ? _b : 1), 160, false, true);
            const videoTrack = new TrackInfo({
              source: TrackSource.CAMERA,
              sid: Math.floor(Math.random() * 1e4).toString(),
              type: TrackType.AUDIO
            });
            p.addSubscribedMediaTrack(dummyVideo, videoTrack.sid, new MediaStream([dummyVideo]), new RTCRtpReceiver());
            info.tracks = [...info.tracks, videoTrack];
          }
          if (participantOptions.audio) {
            const dummyTrack = getEmptyAudioStreamTrack();
            const audioTrack = new TrackInfo({
              source: TrackSource.MICROPHONE,
              sid: Math.floor(Math.random() * 1e4).toString(),
              type: TrackType.AUDIO
            });
            p.addSubscribedMediaTrack(dummyTrack, audioTrack.sid, new MediaStream([dummyTrack]), new RTCRtpReceiver());
            info.tracks = [...info.tracks, audioTrack];
          }
          p.updateInfo(info);
        }
      });
    }
    // /** @internal */
    emit(event) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      if (event !== RoomEvent.ActiveSpeakersChanged) {
        const minimizedArgs = mapArgs(args).filter((arg) => arg !== void 0);
        this.log.debug("room event ".concat(event), Object.assign(Object.assign({}, this.logContext), {
          event,
          args: minimizedArgs
        }));
      }
      return super.emit(event, ...args);
    }
  };
  function mapArgs(args) {
    return args.map((arg) => {
      if (!arg) {
        return;
      }
      if (Array.isArray(arg)) {
        return mapArgs(arg);
      }
      if (typeof arg === "object") {
        return "logContext" in arg && arg.logContext;
      }
      return arg;
    });
  }
  var CheckStatus;
  (function(CheckStatus2) {
    CheckStatus2[CheckStatus2["IDLE"] = 0] = "IDLE";
    CheckStatus2[CheckStatus2["RUNNING"] = 1] = "RUNNING";
    CheckStatus2[CheckStatus2["SKIPPED"] = 2] = "SKIPPED";
    CheckStatus2[CheckStatus2["SUCCESS"] = 3] = "SUCCESS";
    CheckStatus2[CheckStatus2["FAILED"] = 4] = "FAILED";
  })(CheckStatus || (CheckStatus = {}));
  var Checker = class extends eventsExports.EventEmitter {
    constructor(url2, token) {
      let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      super();
      this.status = CheckStatus.IDLE;
      this.logs = [];
      this.errorsAsWarnings = false;
      this.url = url2;
      this.token = token;
      this.name = this.constructor.name;
      this.room = new Room(options.roomOptions);
      this.connectOptions = options.connectOptions;
      if (options.errorsAsWarnings) {
        this.errorsAsWarnings = options.errorsAsWarnings;
      }
    }
    run(onComplete) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.status !== CheckStatus.IDLE) {
          throw Error("check is running already");
        }
        this.setStatus(CheckStatus.RUNNING);
        try {
          yield this.perform();
        } catch (err) {
          if (err instanceof Error) {
            if (this.errorsAsWarnings) {
              this.appendWarning(err.message);
            } else {
              this.appendError(err.message);
            }
          }
        }
        yield this.disconnect();
        yield new Promise((resolve) => setTimeout(resolve, 500));
        if (this.status !== CheckStatus.SKIPPED) {
          this.setStatus(this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED);
        }
        if (onComplete) {
          onComplete();
        }
        return this.getInfo();
      });
    }
    isSuccess() {
      return !this.logs.some((l2) => l2.level === "error");
    }
    connect() {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.room.state === ConnectionState.Connected) {
          return this.room;
        }
        yield this.room.connect(this.url, this.token, this.connectOptions);
        return this.room;
      });
    }
    disconnect() {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.room && this.room.state !== ConnectionState.Disconnected) {
          yield this.room.disconnect();
          yield new Promise((resolve) => setTimeout(resolve, 500));
        }
      });
    }
    skip() {
      this.setStatus(CheckStatus.SKIPPED);
    }
    appendMessage(message) {
      this.logs.push({
        level: "info",
        message
      });
      this.emit("update", this.getInfo());
    }
    appendWarning(message) {
      this.logs.push({
        level: "warning",
        message
      });
      this.emit("update", this.getInfo());
    }
    appendError(message) {
      this.logs.push({
        level: "error",
        message
      });
      this.emit("update", this.getInfo());
    }
    setStatus(status) {
      this.status = status;
      this.emit("update", this.getInfo());
    }
    get engine() {
      var _a;
      return (_a = this.room) === null || _a === void 0 ? void 0 : _a.engine;
    }
    getInfo() {
      return {
        logs: this.logs,
        name: this.name,
        status: this.status,
        description: this.description
      };
    }
  };
  function createLocalTracks(options) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a, _b;
      options !== null && options !== void 0 ? options : options = {};
      (_a = options.audio) !== null && _a !== void 0 ? _a : options.audio = true;
      (_b = options.video) !== null && _b !== void 0 ? _b : options.video = true;
      const {
        audioProcessor,
        videoProcessor
      } = extractProcessorsFromOptions(options);
      const opts = mergeDefaultOptions(options, audioDefaults, videoDefaults);
      const constraints = constraintsForOptions(opts);
      const mediaPromise = navigator.mediaDevices.getUserMedia(constraints);
      if (options.audio) {
        DeviceManager.userMediaPromiseMap.set("audioinput", mediaPromise);
        mediaPromise.catch(() => DeviceManager.userMediaPromiseMap.delete("audioinput"));
      }
      if (options.video) {
        DeviceManager.userMediaPromiseMap.set("videoinput", mediaPromise);
        mediaPromise.catch(() => DeviceManager.userMediaPromiseMap.delete("videoinput"));
      }
      const stream4 = yield mediaPromise;
      return Promise.all(stream4.getTracks().map((mediaStreamTrack) => __awaiter(this, void 0, void 0, function* () {
        const isAudio = mediaStreamTrack.kind === "audio";
        isAudio ? opts.audio : opts.video;
        let trackConstraints;
        const conOrBool = isAudio ? constraints.audio : constraints.video;
        if (typeof conOrBool !== "boolean") {
          trackConstraints = conOrBool;
        }
        if (trackConstraints) {
          trackConstraints.deviceId = mediaStreamTrack.getSettings().deviceId;
        } else {
          trackConstraints = {
            deviceId: mediaStreamTrack.getSettings().deviceId
          };
        }
        const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints);
        if (track.kind === Track.Kind.Video) {
          track.source = Track.Source.Camera;
        } else if (track.kind === Track.Kind.Audio) {
          track.source = Track.Source.Microphone;
        }
        track.mediaStream = stream4;
        if (track instanceof LocalAudioTrack && audioProcessor) {
          yield track.setProcessor(audioProcessor);
        } else if (track instanceof LocalVideoTrack && videoProcessor) {
          yield track.setProcessor(videoProcessor);
        }
        return track;
      })));
    });
  }
  function createLocalVideoTrack(options) {
    return __awaiter(this, void 0, void 0, function* () {
      const tracks = yield createLocalTracks({
        audio: false,
        video: options
      });
      return tracks[0];
    });
  }
  function createLocalAudioTrack(options) {
    return __awaiter(this, void 0, void 0, function* () {
      const tracks = yield createLocalTracks({
        audio: options,
        video: false
      });
      return tracks[0];
    });
  }
  var PublishAudioCheck = class extends Checker {
    get description() {
      return "Can publish audio";
    }
    perform() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const room = yield this.connect();
        const track = yield createLocalAudioTrack();
        room.localParticipant.publishTrack(track);
        yield new Promise((resolve) => setTimeout(resolve, 3e3));
        const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();
        if (!stats) {
          throw new Error("Could not get RTCStats");
        }
        let numPackets = 0;
        stats.forEach((stat) => {
          if (stat.type === "outbound-rtp" && (stat.kind === "audio" || !stat.kind && stat.mediaType === "audio")) {
            numPackets = stat.packetsSent;
          }
        });
        if (numPackets === 0) {
          throw new Error("Could not determine packets are sent");
        }
        this.appendMessage("published ".concat(numPackets, " audio packets"));
      });
    }
  };
  var PublishVideoCheck = class extends Checker {
    get description() {
      return "Can publish video";
    }
    perform() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const room = yield this.connect();
        const track = yield createLocalVideoTrack();
        room.localParticipant.publishTrack(track);
        yield new Promise((resolve) => setTimeout(resolve, 5e3));
        const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();
        if (!stats) {
          throw new Error("Could not get RTCStats");
        }
        let numPackets = 0;
        stats.forEach((stat) => {
          if (stat.type === "outbound-rtp" && (stat.kind === "video" || !stat.kind && stat.mediaType === "video")) {
            numPackets += stat.packetsSent;
          }
        });
        if (numPackets === 0) {
          throw new Error("Could not determine packets are sent");
        }
        this.appendMessage("published ".concat(numPackets, " video packets"));
      });
    }
  };
  var ReconnectCheck = class extends Checker {
    get description() {
      return "Resuming connection after interruption";
    }
    perform() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const room = yield this.connect();
        let reconnectingTriggered = false;
        let reconnected = false;
        let reconnectResolver;
        const reconnectTimeout = new Promise((resolve) => {
          setTimeout(resolve, 5e3);
          reconnectResolver = resolve;
        });
        const handleReconnecting = () => {
          reconnectingTriggered = true;
        };
        room.on(RoomEvent.SignalReconnecting, handleReconnecting).on(RoomEvent.Reconnecting, handleReconnecting).on(RoomEvent.Reconnected, () => {
          reconnected = true;
          reconnectResolver(true);
        });
        (_a = room.engine.client.ws) === null || _a === void 0 ? void 0 : _a.close();
        const onClose = room.engine.client.onClose;
        if (onClose) {
          onClose("");
        }
        yield reconnectTimeout;
        if (!reconnectingTriggered) {
          throw new Error("Did not attempt to reconnect");
        } else if (!reconnected || room.state !== ConnectionState.Connected) {
          this.appendWarning("reconnection is only possible in Redis-based configurations");
          throw new Error("Not able to reconnect");
        }
      });
    }
  };
  var TURNCheck = class extends Checker {
    get description() {
      return "Can connect via TURN";
    }
    perform() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        const signalClient = new SignalClient();
        const joinRes = yield signalClient.join(this.url, this.token, {
          autoSubscribe: true,
          maxRetries: 0,
          e2eeEnabled: false,
          websocketTimeout: 15e3
        });
        let hasTLS = false;
        let hasTURN = false;
        let hasSTUN = false;
        for (let iceServer of joinRes.iceServers) {
          for (let url2 of iceServer.urls) {
            if (url2.startsWith("turn:")) {
              hasTURN = true;
              hasSTUN = true;
            } else if (url2.startsWith("turns:")) {
              hasTURN = true;
              hasSTUN = true;
              hasTLS = true;
            }
            if (url2.startsWith("stun:")) {
              hasSTUN = true;
            }
          }
        }
        if (!hasSTUN) {
          this.appendWarning("No STUN servers configured on server side.");
        } else if (hasTURN && !hasTLS) {
          this.appendWarning("TURN is configured server side, but TURN/TLS is unavailable.");
        }
        yield signalClient.close();
        if (((_b = (_a = this.connectOptions) === null || _a === void 0 ? void 0 : _a.rtcConfig) === null || _b === void 0 ? void 0 : _b.iceServers) || hasTURN) {
          yield this.room.connect(this.url, this.token, {
            rtcConfig: {
              iceTransportPolicy: "relay"
            }
          });
        } else {
          this.appendWarning("No TURN servers configured.");
          this.skip();
          yield new Promise((resolve) => setTimeout(resolve, 0));
        }
      });
    }
  };
  var WebRTCCheck = class extends Checker {
    get description() {
      return "Establishing WebRTC connection";
    }
    perform() {
      return __awaiter(this, void 0, void 0, function* () {
        let hasTcp = false;
        let hasIpv4Udp = false;
        this.room.on(RoomEvent.SignalConnected, () => {
          const prevTrickle = this.room.engine.client.onTrickle;
          this.room.engine.client.onTrickle = (sd, target) => {
            if (sd.candidate) {
              const candidate = new RTCIceCandidate(sd);
              let str = "".concat(candidate.protocol, " ").concat(candidate.address, ":").concat(candidate.port, " ").concat(candidate.type);
              if (candidate.address) {
                if (isIPPrivate(candidate.address)) {
                  str += " (private)";
                } else {
                  if (candidate.protocol === "tcp" && candidate.tcpType === "passive") {
                    hasTcp = true;
                    str += " (passive)";
                  } else if (candidate.protocol === "udp") {
                    hasIpv4Udp = true;
                  }
                }
              }
              this.appendMessage(str);
            }
            if (prevTrickle) {
              prevTrickle(sd, target);
            }
          };
          if (this.room.engine.pcManager) {
            this.room.engine.pcManager.subscriber.onIceCandidateError = (ev) => {
              if (ev instanceof RTCPeerConnectionIceErrorEvent) {
                this.appendWarning("error with ICE candidate: ".concat(ev.errorCode, " ").concat(ev.errorText, " ").concat(ev.url));
              }
            };
          }
        });
        try {
          yield this.connect();
          livekitLogger.info("now the room is connected");
        } catch (err) {
          this.appendWarning("ports need to be open on firewall in order to connect.");
          throw err;
        }
        if (!hasTcp) {
          this.appendWarning("Server is not configured for ICE/TCP");
        }
        if (!hasIpv4Udp) {
          this.appendWarning("No public IPv4 UDP candidates were found. Your server is likely not configured correctly");
        }
      });
    }
  };
  function isIPPrivate(address) {
    const parts = address.split(".");
    if (parts.length === 4) {
      if (parts[0] === "10") {
        return true;
      } else if (parts[0] === "192" && parts[1] === "168") {
        return true;
      } else if (parts[0] === "172") {
        const second = parseInt(parts[1], 10);
        if (second >= 16 && second <= 31) {
          return true;
        }
      }
    }
    return false;
  }
  var WebSocketCheck = class extends Checker {
    get description() {
      return "Connecting to signal connection via WebSocket";
    }
    perform() {
      return __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c;
        if (this.url.startsWith("ws:") || this.url.startsWith("http:")) {
          this.appendWarning("Server is insecure, clients may block connections to it");
        }
        let signalClient = new SignalClient();
        const joinRes = yield signalClient.join(this.url, this.token, {
          autoSubscribe: true,
          maxRetries: 0,
          e2eeEnabled: false,
          websocketTimeout: 15e3
        });
        this.appendMessage("Connected to server, version ".concat(joinRes.serverVersion, "."));
        if (((_a = joinRes.serverInfo) === null || _a === void 0 ? void 0 : _a.edition) === ServerInfo_Edition.Cloud && ((_b = joinRes.serverInfo) === null || _b === void 0 ? void 0 : _b.region)) {
          this.appendMessage("LiveKit Cloud: ".concat((_c = joinRes.serverInfo) === null || _c === void 0 ? void 0 : _c.region));
        }
        yield signalClient.close();
      });
    }
  };
  var ConnectionCheck = class extends eventsExports.EventEmitter {
    constructor(url2, token) {
      let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      super();
      this.options = {};
      this.checkResults = /* @__PURE__ */ new Map();
      this.url = url2;
      this.token = token;
      this.options = options;
    }
    getNextCheckId() {
      const nextId = this.checkResults.size;
      this.checkResults.set(nextId, {
        logs: [],
        status: CheckStatus.IDLE,
        name: "",
        description: ""
      });
      return nextId;
    }
    updateCheck(checkId, info) {
      this.checkResults.set(checkId, info);
      this.emit("checkUpdate", checkId, info);
    }
    isSuccess() {
      return Array.from(this.checkResults.values()).every((r2) => r2.status !== CheckStatus.FAILED);
    }
    getResults() {
      return Array.from(this.checkResults.values());
    }
    createAndRunCheck(check) {
      return __awaiter(this, void 0, void 0, function* () {
        const checkId = this.getNextCheckId();
        const test2 = new check(this.url, this.token, this.options);
        const handleUpdate = (info) => {
          this.updateCheck(checkId, info);
        };
        test2.on("update", handleUpdate);
        const result = yield test2.run();
        test2.off("update", handleUpdate);
        return result;
      });
    }
    checkWebsocket() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.createAndRunCheck(WebSocketCheck);
      });
    }
    checkWebRTC() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.createAndRunCheck(WebRTCCheck);
      });
    }
    checkTURN() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.createAndRunCheck(TURNCheck);
      });
    }
    checkReconnect() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.createAndRunCheck(ReconnectCheck);
      });
    }
    checkPublishAudio() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.createAndRunCheck(PublishAudioCheck);
      });
    }
    checkPublishVideo() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.createAndRunCheck(PublishVideoCheck);
      });
    }
  };

  // src/TrackVolumeVisualizer.ts
  var TrackVolumeVisualizer = class {
    constructor({ bands, onTick }) {
      this.cleanup = null;
      this.bands = bands;
      this.callback = onTick;
    }
    setTrack(track) {
      if (this.interval) {
        clearInterval(this.interval);
      }
      if (this.cleanup) {
        this.cleanup();
      }
      const { analyser, cleanup, calculateVolume } = createAudioAnalyser(track, {
        fftSize: 256,
        smoothingTimeConstant: 0.7
      });
      this.cleanup = cleanup;
      const dataArray = new Float32Array(this.bands);
      this.interval = setInterval(() => {
        analyser.getFloatFrequencyData(dataArray);
        const result = [];
        for (let i = 0; i < dataArray.length; i++) {
          result.push(Math.max(0, dataArray[i] + 140) / 140);
        }
        this.callback(result, calculateVolume());
      }, 1e3 / 100);
    }
  };

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/bind.js
  function bind(fn, thisArg) {
    return function wrap() {
      return fn.apply(thisArg, arguments);
    };
  }

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/utils.js
  var { toString } = Object.prototype;
  var { getPrototypeOf } = Object;
  var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null));
  var kindOfTest = (type) => {
    type = type.toLowerCase();
    return (thing) => kindOf(thing) === type;
  };
  var typeOfTest = (type) => (thing) => typeof thing === type;
  var { isArray } = Array;
  var isUndefined = typeOfTest("undefined");
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }
  var isArrayBuffer = kindOfTest("ArrayBuffer");
  function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  var isString = typeOfTest("string");
  var isFunction = typeOfTest("function");
  var isNumber = typeOfTest("number");
  var isObject2 = (thing) => thing !== null && typeof thing === "object";
  var isBoolean = (thing) => thing === true || thing === false;
  var isPlainObject = (val) => {
    if (kindOf(val) !== "object") {
      return false;
    }
    const prototype3 = getPrototypeOf(val);
    return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
  };
  var isDate = kindOfTest("Date");
  var isFile = kindOfTest("File");
  var isBlob = kindOfTest("Blob");
  var isFileList = kindOfTest("FileList");
  var isStream = (val) => isObject2(val) && isFunction(val.pipe);
  var isFormData = (thing) => {
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
  };
  var isURLSearchParams = kindOfTest("URLSearchParams");
  var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
  var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function forEach(obj, fn, { allOwnKeys = false } = {}) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    let i;
    let l2;
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray(obj)) {
      for (i = 0, l2 = obj.length; i < l2; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
      const len = keys.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys[i];
        fn.call(null, obj[key], key, obj);
      }
    }
  }
  function findKey(obj, key) {
    key = key.toLowerCase();
    const keys = Object.keys(obj);
    let i = keys.length;
    let _key;
    while (i-- > 0) {
      _key = keys[i];
      if (key === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }
  var _global = (() => {
    if (typeof globalThis !== "undefined") return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
  })();
  var isContextDefined = (context) => !isUndefined(context) && context !== _global;
  function merge() {
    const { caseless } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key) => {
      const targetKey = caseless && findKey(result, key) || key;
      if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
        result[targetKey] = merge(result[targetKey], val);
      } else if (isPlainObject(val)) {
        result[targetKey] = merge({}, val);
      } else if (isArray(val)) {
        result[targetKey] = val.slice();
      } else {
        result[targetKey] = val;
      }
    };
    for (let i = 0, l2 = arguments.length; i < l2; i++) {
      arguments[i] && forEach(arguments[i], assignValue);
    }
    return result;
  }
  var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
    forEach(b, (val, key) => {
      if (thisArg && isFunction(val)) {
        a[key] = bind(val, thisArg);
      } else {
        a[key] = val;
      }
    }, { allOwnKeys });
    return a;
  };
  var stripBOM = (content) => {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  };
  var inherits = (constructor, superConstructor, props, descriptors2) => {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
      value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
  };
  var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
    let props;
    let i;
    let prop;
    const merged = {};
    destObj = destObj || {};
    if (sourceObj == null) return destObj;
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i = props.length;
      while (i-- > 0) {
        prop = props[i];
        if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  };
  var endsWith = (str, searchString, position) => {
    str = String(str);
    if (position === void 0 || position > str.length) {
      position = str.length;
    }
    position -= searchString.length;
    const lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  };
  var toArray = (thing) => {
    if (!thing) return null;
    if (isArray(thing)) return thing;
    let i = thing.length;
    if (!isNumber(i)) return null;
    const arr = new Array(i);
    while (i-- > 0) {
      arr[i] = thing[i];
    }
    return arr;
  };
  var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
    return (thing) => {
      return TypedArray && thing instanceof TypedArray;
    };
  })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
  var forEachEntry = (obj, fn) => {
    const generator = obj && obj[Symbol.iterator];
    const iterator = generator.call(obj);
    let result;
    while ((result = iterator.next()) && !result.done) {
      const pair = result.value;
      fn.call(obj, pair[0], pair[1]);
    }
  };
  var matchAll = (regExp, str) => {
    let matches;
    const arr = [];
    while ((matches = regExp.exec(str)) !== null) {
      arr.push(matches);
    }
    return arr;
  };
  var isHTMLForm = kindOfTest("HTMLFormElement");
  var toCamelCase = (str) => {
    return str.toLowerCase().replace(
      /[-_\s]([a-z\d])(\w*)/g,
      function replacer(m, p1, p2) {
        return p1.toUpperCase() + p2;
      }
    );
  };
  var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
  var isRegExp = kindOfTest("RegExp");
  var reduceDescriptors = (obj, reducer) => {
    const descriptors2 = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    forEach(descriptors2, (descriptor, name) => {
      let ret;
      if ((ret = reducer(descriptor, name, obj)) !== false) {
        reducedDescriptors[name] = ret || descriptor;
      }
    });
    Object.defineProperties(obj, reducedDescriptors);
  };
  var freezeMethods = (obj) => {
    reduceDescriptors(obj, (descriptor, name) => {
      if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
        return false;
      }
      const value = obj[name];
      if (!isFunction(value)) return;
      descriptor.enumerable = false;
      if ("writable" in descriptor) {
        descriptor.writable = false;
        return;
      }
      if (!descriptor.set) {
        descriptor.set = () => {
          throw Error("Can not rewrite read-only method '" + name + "'");
        };
      }
    });
  };
  var toObjectSet = (arrayOrString, delimiter) => {
    const obj = {};
    const define = (arr) => {
      arr.forEach((value) => {
        obj[value] = true;
      });
    };
    isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
    return obj;
  };
  var noop = () => {
  };
  var toFiniteNumber = (value, defaultValue) => {
    return value != null && Number.isFinite(value = +value) ? value : defaultValue;
  };
  var ALPHA = "abcdefghijklmnopqrstuvwxyz";
  var DIGIT = "0123456789";
  var ALPHABET = {
    DIGIT,
    ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
  };
  var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
    let str = "";
    const { length } = alphabet;
    while (size--) {
      str += alphabet[Math.random() * length | 0];
    }
    return str;
  };
  function isSpecCompliantForm(thing) {
    return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
  }
  var toJSONObject = (obj) => {
    const stack = new Array(10);
    const visit = (source, i) => {
      if (isObject2(source)) {
        if (stack.indexOf(source) >= 0) {
          return;
        }
        if (!("toJSON" in source)) {
          stack[i] = source;
          const target = isArray(source) ? [] : {};
          forEach(source, (value, key) => {
            const reducedValue = visit(value, i + 1);
            !isUndefined(reducedValue) && (target[key] = reducedValue);
          });
          stack[i] = void 0;
          return target;
        }
      }
      return source;
    };
    return visit(obj, 0);
  };
  var isAsyncFn = kindOfTest("AsyncFunction");
  var isThenable = (thing) => thing && (isObject2(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
  var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
    if (setImmediateSupported) {
      return setImmediate;
    }
    return postMessageSupported ? ((token, callbacks) => {
      _global.addEventListener("message", ({ source, data }) => {
        if (source === _global && data === token) {
          callbacks.length && callbacks.shift()();
        }
      }, false);
      return (cb) => {
        callbacks.push(cb);
        _global.postMessage(token, "*");
      };
    })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
  })(
    typeof setImmediate === "function",
    isFunction(_global.postMessage)
  );
  var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
  var utils_default = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isBoolean,
    isObject: isObject2,
    isPlainObject,
    isReadableStream,
    isRequest,
    isResponse,
    isHeaders,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    ALPHABET,
    generateString,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable,
    setImmediate: _setImmediate,
    asap
  };

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/core/AxiosError.js
  function AxiosError(message, code, config, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }
    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    if (response) {
      this.response = response;
      this.status = response.status ? response.status : null;
    }
  }
  utils_default.inherits(AxiosError, Error, {
    toJSON: function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: utils_default.toJSONObject(this.config),
        code: this.code,
        status: this.status
      };
    }
  });
  var prototype = AxiosError.prototype;
  var descriptors = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
    // eslint-disable-next-line func-names
  ].forEach((code) => {
    descriptors[code] = { value: code };
  });
  Object.defineProperties(AxiosError, descriptors);
  Object.defineProperty(prototype, "isAxiosError", { value: true });
  AxiosError.from = (error, code, config, request, response, customProps) => {
    const axiosError = Object.create(prototype);
    utils_default.toFlatObject(error, axiosError, function filter2(obj) {
      return obj !== Error.prototype;
    }, (prop) => {
      return prop !== "isAxiosError";
    });
    AxiosError.call(axiosError, error.message, code, config, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  var AxiosError_default = AxiosError;

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/platform/node/classes/FormData.js
  var import_form_data = __toESM(require_form_data(), 1);
  var FormData_default = import_form_data.default;

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/toFormData.js
  function isVisitable(thing) {
    return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
  }
  function removeBrackets(key) {
    return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
  }
  function renderKey(path, key, dots) {
    if (!path) return key;
    return path.concat(key).map(function each(token, i) {
      token = removeBrackets(token);
      return !dots && i ? "[" + token + "]" : token;
    }).join(dots ? "." : "");
  }
  function isFlatArray(arr) {
    return utils_default.isArray(arr) && !arr.some(isVisitable);
  }
  var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
    return /^is[A-Z]/.test(prop);
  });
  function toFormData(obj, formData, options) {
    if (!utils_default.isObject(obj)) {
      throw new TypeError("target must be an object");
    }
    formData = formData || new (FormData_default || FormData)();
    options = utils_default.toFlatObject(options, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function defined(option, source) {
      return !utils_default.isUndefined(source[option]);
    });
    const metaTokens = options.metaTokens;
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
    if (!utils_default.isFunction(visitor)) {
      throw new TypeError("visitor must be a function");
    }
    function convertValue(value) {
      if (value === null) return "";
      if (utils_default.isDate(value)) {
        return value.toISOString();
      }
      if (!useBlob && utils_default.isBlob(value)) {
        throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
      }
      if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
        return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
      }
      return value;
    }
    function defaultVisitor(value, key, path) {
      let arr = value;
      if (value && !path && typeof value === "object") {
        if (utils_default.endsWith(key, "{}")) {
          key = metaTokens ? key : key.slice(0, -2);
          value = JSON.stringify(value);
        } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
          key = removeBrackets(key);
          arr.forEach(function each(el, index) {
            !(utils_default.isUndefined(el) || el === null) && formData.append(
              // eslint-disable-next-line no-nested-ternary
              indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
              convertValue(el)
            );
          });
          return false;
        }
      }
      if (isVisitable(value)) {
        return true;
      }
      formData.append(renderKey(path, key, dots), convertValue(value));
      return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates, {
      defaultVisitor,
      convertValue,
      isVisitable
    });
    function build(value, path) {
      if (utils_default.isUndefined(value)) return;
      if (stack.indexOf(value) !== -1) {
        throw Error("Circular reference detected in " + path.join("."));
      }
      stack.push(value);
      utils_default.forEach(value, function each(el, key) {
        const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
          formData,
          el,
          utils_default.isString(key) ? key.trim() : key,
          path,
          exposedHelpers
        );
        if (result === true) {
          build(el, path ? path.concat(key) : [key]);
        }
      });
      stack.pop();
    }
    if (!utils_default.isObject(obj)) {
      throw new TypeError("data must be an object");
    }
    build(obj);
    return formData;
  }
  var toFormData_default = toFormData;

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/AxiosURLSearchParams.js
  function encode(str) {
    const charMap = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
      return charMap[match];
    });
  }
  function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && toFormData_default(params, this, options);
  }
  var prototype2 = AxiosURLSearchParams.prototype;
  prototype2.append = function append(name, value) {
    this._pairs.push([name, value]);
  };
  prototype2.toString = function toString2(encoder) {
    const _encode = encoder ? function(value) {
      return encoder.call(this, value, encode);
    } : encode;
    return this._pairs.map(function each(pair) {
      return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
  };
  var AxiosURLSearchParams_default = AxiosURLSearchParams;

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/buildURL.js
  function encode2(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  function buildURL(url2, params, options) {
    if (!params) {
      return url2;
    }
    const _encode = options && options.encode || encode2;
    if (utils_default.isFunction(options)) {
      options = {
        serialize: options
      };
    }
    const serializeFn = options && options.serialize;
    let serializedParams;
    if (serializeFn) {
      serializedParams = serializeFn(params, options);
    } else {
      serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
    }
    if (serializedParams) {
      const hashmarkIndex = url2.indexOf("#");
      if (hashmarkIndex !== -1) {
        url2 = url2.slice(0, hashmarkIndex);
      }
      url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url2;
  }

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/core/InterceptorManager.js
  var InterceptorManager = class {
    constructor() {
      this.handlers = [];
    }
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    }
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
     */
    eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    }
    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    }
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(fn) {
      utils_default.forEach(this.handlers, function forEachHandler(h2) {
        if (h2 !== null) {
          fn(h2);
        }
      });
    }
  };
  var InterceptorManager_default = InterceptorManager;

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/defaults/transitional.js
  var transitional_default = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/platform/node/classes/URLSearchParams.js
  var import_url = __toESM(__require("url"), 1);
  var URLSearchParams_default = import_url.default.URLSearchParams;

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/platform/node/index.js
  var node_default = {
    isNode: true,
    classes: {
      URLSearchParams: URLSearchParams_default,
      FormData: FormData_default,
      Blob: typeof Blob !== "undefined" && Blob || null
    },
    protocols: ["http", "https", "file", "data"]
  };

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/platform/common/utils.js
  var utils_exports = {};
  __export(utils_exports, {
    hasBrowserEnv: () => hasBrowserEnv,
    hasStandardBrowserEnv: () => hasStandardBrowserEnv,
    hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
    navigator: () => _navigator,
    origin: () => origin
  });
  var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
  var _navigator = typeof navigator === "object" && navigator || void 0;
  var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
  var hasStandardBrowserWebWorkerEnv = (() => {
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
  })();
  var origin = hasBrowserEnv && window.location.href || "http://localhost";

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/platform/index.js
  var platform_default = {
    ...utils_exports,
    ...node_default
  };

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/toURLEncodedForm.js
  function toURLEncodedForm(data, options) {
    return toFormData_default(data, new platform_default.classes.URLSearchParams(), Object.assign({
      visitor: function(value, key, path, helpers) {
        if (platform_default.isNode && utils_default.isBuffer(value)) {
          this.append(key, value.toString("base64"));
          return false;
        }
        return helpers.defaultVisitor.apply(this, arguments);
      }
    }, options));
  }

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/formDataToJSON.js
  function parsePropPath(name) {
    return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
      return match[0] === "[]" ? "" : match[1] || match[0];
    });
  }
  function arrayToObject(arr) {
    const obj = {};
    const keys = Object.keys(arr);
    let i;
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      obj[key] = arr[key];
    }
    return obj;
  }
  function formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
      let name = path[index++];
      if (name === "__proto__") return true;
      const isNumericKey = Number.isFinite(+name);
      const isLast = index >= path.length;
      name = !name && utils_default.isArray(target) ? target.length : name;
      if (isLast) {
        if (utils_default.hasOwnProp(target, name)) {
          target[name] = [target[name], value];
        } else {
          target[name] = value;
        }
        return !isNumericKey;
      }
      if (!target[name] || !utils_default.isObject(target[name])) {
        target[name] = [];
      }
      const result = buildPath(path, value, target[name], index);
      if (result && utils_default.isArray(target[name])) {
        target[name] = arrayToObject(target[name]);
      }
      return !isNumericKey;
    }
    if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
      const obj = {};
      utils_default.forEachEntry(formData, (name, value) => {
        buildPath(parsePropPath(name), value, obj, 0);
      });
      return obj;
    }
    return null;
  }
  var formDataToJSON_default = formDataToJSON;

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/defaults/index.js
  function stringifySafely(rawValue, parser2, encoder) {
    if (utils_default.isString(rawValue)) {
      try {
        (parser2 || JSON.parse)(rawValue);
        return utils_default.trim(rawValue);
      } catch (e) {
        if (e.name !== "SyntaxError") {
          throw e;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  var defaults = {
    transitional: transitional_default,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function transformRequest(data, headers) {
      const contentType = headers.getContentType() || "";
      const hasJSONContentType = contentType.indexOf("application/json") > -1;
      const isObjectPayload = utils_default.isObject(data);
      if (isObjectPayload && utils_default.isHTMLForm(data)) {
        data = new FormData(data);
      }
      const isFormData2 = utils_default.isFormData(data);
      if (isFormData2) {
        return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
      }
      if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
        return data;
      }
      if (utils_default.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils_default.isURLSearchParams(data)) {
        headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
        return data.toString();
      }
      let isFileList2;
      if (isObjectPayload) {
        if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
          return toURLEncodedForm(data, this.formSerializer).toString();
        }
        if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
          const _FormData = this.env && this.env.FormData;
          return toFormData_default(
            isFileList2 ? { "files[]": data } : data,
            _FormData && new _FormData(),
            this.formSerializer
          );
        }
      }
      if (isObjectPayload || hasJSONContentType) {
        headers.setContentType("application/json", false);
        return stringifySafely(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      const transitional2 = this.transitional || defaults.transitional;
      const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
      const JSONRequested = this.responseType === "json";
      if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
        return data;
      }
      if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
        const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
        const strictJSONParsing = !silentJSONParsing && JSONRequested;
        try {
          return JSON.parse(data);
        } catch (e) {
          if (strictJSONParsing) {
            if (e.name === "SyntaxError") {
              throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e;
          }
        }
      }
      return data;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: platform_default.classes.FormData,
      Blob: platform_default.classes.Blob
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*",
        "Content-Type": void 0
      }
    }
  };
  utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
    defaults.headers[method] = {};
  });
  var defaults_default = defaults;

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/parseHeaders.js
  var ignoreDuplicateOf = utils_default.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]);
  var parseHeaders_default = (rawHeaders) => {
    const parsed = {};
    let key;
    let val;
    let i;
    rawHeaders && rawHeaders.split("\n").forEach(function parser2(line) {
      i = line.indexOf(":");
      key = line.substring(0, i).trim().toLowerCase();
      val = line.substring(i + 1).trim();
      if (!key || parsed[key] && ignoreDuplicateOf[key]) {
        return;
      }
      if (key === "set-cookie") {
        if (parsed[key]) {
          parsed[key].push(val);
        } else {
          parsed[key] = [val];
        }
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
      }
    });
    return parsed;
  };

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/core/AxiosHeaders.js
  var $internals = Symbol("internals");
  function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
  }
  function normalizeValue(value) {
    if (value === false || value == null) {
      return value;
    }
    return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
  }
  function parseTokens(str) {
    const tokens = /* @__PURE__ */ Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;
    while (match = tokensRE.exec(str)) {
      tokens[match[1]] = match[2];
    }
    return tokens;
  }
  var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
  function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
    if (utils_default.isFunction(filter2)) {
      return filter2.call(this, value, header);
    }
    if (isHeaderNameFilter) {
      value = header;
    }
    if (!utils_default.isString(value)) return;
    if (utils_default.isString(filter2)) {
      return value.indexOf(filter2) !== -1;
    }
    if (utils_default.isRegExp(filter2)) {
      return filter2.test(value);
    }
  }
  function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
  }
  function buildAccessors(obj, header) {
    const accessorName = utils_default.toCamelCase(" " + header);
    ["get", "set", "has"].forEach((methodName) => {
      Object.defineProperty(obj, methodName + accessorName, {
        value: function(arg1, arg2, arg3) {
          return this[methodName].call(this, header, arg1, arg2, arg3);
        },
        configurable: true
      });
    });
  }
  var AxiosHeaders = class {
    constructor(headers) {
      headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
      const self2 = this;
      function setHeader(_value, _header, _rewrite) {
        const lHeader = normalizeHeader(_header);
        if (!lHeader) {
          throw new Error("header name must be a non-empty string");
        }
        const key = utils_default.findKey(self2, lHeader);
        if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
          self2[key || _header] = normalizeValue(_value);
        }
      }
      const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
      if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
        setHeaders(header, valueOrRewrite);
      } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
        setHeaders(parseHeaders_default(header), valueOrRewrite);
      } else if (utils_default.isHeaders(header)) {
        for (const [key, value] of header.entries()) {
          setHeader(value, key, rewrite);
        }
      } else {
        header != null && setHeader(valueOrRewrite, header, rewrite);
      }
      return this;
    }
    get(header, parser2) {
      header = normalizeHeader(header);
      if (header) {
        const key = utils_default.findKey(this, header);
        if (key) {
          const value = this[key];
          if (!parser2) {
            return value;
          }
          if (parser2 === true) {
            return parseTokens(value);
          }
          if (utils_default.isFunction(parser2)) {
            return parser2.call(this, value, key);
          }
          if (utils_default.isRegExp(parser2)) {
            return parser2.exec(value);
          }
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(header, matcher) {
      header = normalizeHeader(header);
      if (header) {
        const key = utils_default.findKey(this, header);
        return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
      }
      return false;
    }
    delete(header, matcher) {
      const self2 = this;
      let deleted = false;
      function deleteHeader(_header) {
        _header = normalizeHeader(_header);
        if (_header) {
          const key = utils_default.findKey(self2, _header);
          if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
            delete self2[key];
            deleted = true;
          }
        }
      }
      if (utils_default.isArray(header)) {
        header.forEach(deleteHeader);
      } else {
        deleteHeader(header);
      }
      return deleted;
    }
    clear(matcher) {
      const keys = Object.keys(this);
      let i = keys.length;
      let deleted = false;
      while (i--) {
        const key = keys[i];
        if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
          delete this[key];
          deleted = true;
        }
      }
      return deleted;
    }
    normalize(format) {
      const self2 = this;
      const headers = {};
      utils_default.forEach(this, (value, header) => {
        const key = utils_default.findKey(headers, header);
        if (key) {
          self2[key] = normalizeValue(value);
          delete self2[header];
          return;
        }
        const normalized = format ? formatHeader(header) : String(header).trim();
        if (normalized !== header) {
          delete self2[header];
        }
        self2[normalized] = normalizeValue(value);
        headers[normalized] = true;
      });
      return this;
    }
    concat(...targets) {
      return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
      const obj = /* @__PURE__ */ Object.create(null);
      utils_default.forEach(this, (value, header) => {
        value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
      });
      return obj;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
      const computed = new this(first);
      targets.forEach((target) => computed.set(target));
      return computed;
    }
    static accessor(header) {
      const internals = this[$internals] = this[$internals] = {
        accessors: {}
      };
      const accessors = internals.accessors;
      const prototype3 = this.prototype;
      function defineAccessor(_header) {
        const lHeader = normalizeHeader(_header);
        if (!accessors[lHeader]) {
          buildAccessors(prototype3, _header);
          accessors[lHeader] = true;
        }
      }
      utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
      return this;
    }
  };
  AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
    let mapped = key[0].toUpperCase() + key.slice(1);
    return {
      get: () => value,
      set(headerValue) {
        this[mapped] = headerValue;
      }
    };
  });
  utils_default.freezeMethods(AxiosHeaders);
  var AxiosHeaders_default = AxiosHeaders;

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/core/transformData.js
  function transformData(fns, response) {
    const config = this || defaults_default;
    const context = response || config;
    const headers = AxiosHeaders_default.from(context.headers);
    let data = context.data;
    utils_default.forEach(fns, function transform(fn) {
      data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
    });
    headers.normalize();
    return data;
  }

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/cancel/isCancel.js
  function isCancel(value) {
    return !!(value && value.__CANCEL__);
  }

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/cancel/CanceledError.js
  function CanceledError(message, config, request) {
    AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
    this.name = "CanceledError";
  }
  utils_default.inherits(CanceledError, AxiosError_default, {
    __CANCEL__: true
  });
  var CanceledError_default = CanceledError;

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/core/settle.js
  function settle(resolve, reject, response) {
    const validateStatus2 = response.config.validateStatus;
    if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
      resolve(response);
    } else {
      reject(new AxiosError_default(
        "Request failed with status code " + response.status,
        [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  }

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/isAbsoluteURL.js
  function isAbsoluteURL(url2) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
  }

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/combineURLs.js
  function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  }

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/core/buildFullPath.js
  function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  }

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/adapters/http.js
  var import_proxy_from_env = __toESM(require_proxy_from_env(), 1);
  var import_http = __toESM(__require("http"), 1);
  var import_https = __toESM(__require("https"), 1);
  var import_util2 = __toESM(__require("util"), 1);
  var import_follow_redirects = __toESM(require_follow_redirects(), 1);
  var import_zlib = __toESM(__require("zlib"), 1);

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/env/data.js
  var VERSION = "1.7.9";

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/parseProtocol.js
  function parseProtocol(url2) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
    return match && match[1] || "";
  }

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/fromDataURI.js
  var DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
  function fromDataURI(uri, asBlob, options) {
    const _Blob = options && options.Blob || platform_default.classes.Blob;
    const protocol = parseProtocol(uri);
    if (asBlob === void 0 && _Blob) {
      asBlob = true;
    }
    if (protocol === "data") {
      uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
      const match = DATA_URL_PATTERN.exec(uri);
      if (!match) {
        throw new AxiosError_default("Invalid URL", AxiosError_default.ERR_INVALID_URL);
      }
      const mime = match[1];
      const isBase64 = match[2];
      const body = match[3];
      const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
      if (asBlob) {
        if (!_Blob) {
          throw new AxiosError_default("Blob is not supported", AxiosError_default.ERR_NOT_SUPPORT);
        }
        return new _Blob([buffer], { type: mime });
      }
      return buffer;
    }
    throw new AxiosError_default("Unsupported protocol " + protocol, AxiosError_default.ERR_NOT_SUPPORT);
  }

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/adapters/http.js
  var import_stream4 = __toESM(__require("stream"), 1);

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/AxiosTransformStream.js
  var import_stream = __toESM(__require("stream"), 1);
  var kInternals = Symbol("internals");
  var AxiosTransformStream = class extends import_stream.default.Transform {
    constructor(options) {
      options = utils_default.toFlatObject(options, {
        maxRate: 0,
        chunkSize: 64 * 1024,
        minChunkSize: 100,
        timeWindow: 500,
        ticksRate: 2,
        samplesCount: 15
      }, null, (prop, source) => {
        return !utils_default.isUndefined(source[prop]);
      });
      super({
        readableHighWaterMark: options.chunkSize
      });
      const internals = this[kInternals] = {
        timeWindow: options.timeWindow,
        chunkSize: options.chunkSize,
        maxRate: options.maxRate,
        minChunkSize: options.minChunkSize,
        bytesSeen: 0,
        isCaptured: false,
        notifiedBytesLoaded: 0,
        ts: Date.now(),
        bytes: 0,
        onReadCallback: null
      };
      this.on("newListener", (event) => {
        if (event === "progress") {
          if (!internals.isCaptured) {
            internals.isCaptured = true;
          }
        }
      });
    }
    _read(size) {
      const internals = this[kInternals];
      if (internals.onReadCallback) {
        internals.onReadCallback();
      }
      return super._read(size);
    }
    _transform(chunk, encoding, callback) {
      const internals = this[kInternals];
      const maxRate = internals.maxRate;
      const readableHighWaterMark = this.readableHighWaterMark;
      const timeWindow = internals.timeWindow;
      const divider = 1e3 / timeWindow;
      const bytesThreshold = maxRate / divider;
      const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
      const pushChunk = (_chunk, _callback) => {
        const bytes = Buffer.byteLength(_chunk);
        internals.bytesSeen += bytes;
        internals.bytes += bytes;
        internals.isCaptured && this.emit("progress", internals.bytesSeen);
        if (this.push(_chunk)) {
          process.nextTick(_callback);
        } else {
          internals.onReadCallback = () => {
            internals.onReadCallback = null;
            process.nextTick(_callback);
          };
        }
      };
      const transformChunk = (_chunk, _callback) => {
        const chunkSize = Buffer.byteLength(_chunk);
        let chunkRemainder = null;
        let maxChunkSize = readableHighWaterMark;
        let bytesLeft;
        let passed = 0;
        if (maxRate) {
          const now = Date.now();
          if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
            internals.ts = now;
            bytesLeft = bytesThreshold - internals.bytes;
            internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
            passed = 0;
          }
          bytesLeft = bytesThreshold - internals.bytes;
        }
        if (maxRate) {
          if (bytesLeft <= 0) {
            return setTimeout(() => {
              _callback(null, _chunk);
            }, timeWindow - passed);
          }
          if (bytesLeft < maxChunkSize) {
            maxChunkSize = bytesLeft;
          }
        }
        if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
          chunkRemainder = _chunk.subarray(maxChunkSize);
          _chunk = _chunk.subarray(0, maxChunkSize);
        }
        pushChunk(_chunk, chunkRemainder ? () => {
          process.nextTick(_callback, null, chunkRemainder);
        } : _callback);
      };
      transformChunk(chunk, function transformNextChunk(err, _chunk) {
        if (err) {
          return callback(err);
        }
        if (_chunk) {
          transformChunk(_chunk, transformNextChunk);
        } else {
          callback(null);
        }
      });
    }
  };
  var AxiosTransformStream_default = AxiosTransformStream;

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/adapters/http.js
  var import_events = __require("events");

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/formDataToStream.js
  var import_util = __toESM(__require("util"), 1);
  var import_stream2 = __require("stream");

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/readBlob.js
  var { asyncIterator } = Symbol;
  var readBlob = async function* (blob) {
    if (blob.stream) {
      yield* blob.stream();
    } else if (blob.arrayBuffer) {
      yield await blob.arrayBuffer();
    } else if (blob[asyncIterator]) {
      yield* blob[asyncIterator]();
    } else {
      yield blob;
    }
  };
  var readBlob_default = readBlob;

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/formDataToStream.js
  var BOUNDARY_ALPHABET = utils_default.ALPHABET.ALPHA_DIGIT + "-_";
  var textEncoder = typeof TextEncoder === "function" ? new TextEncoder() : new import_util.default.TextEncoder();
  var CRLF = "\r\n";
  var CRLF_BYTES = textEncoder.encode(CRLF);
  var CRLF_BYTES_COUNT = 2;
  var FormDataPart = class {
    constructor(name, value) {
      const { escapeName } = this.constructor;
      const isStringValue = utils_default.isString(value);
      let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
      if (isStringValue) {
        value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
      } else {
        headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
      }
      this.headers = textEncoder.encode(headers + CRLF);
      this.contentLength = isStringValue ? value.byteLength : value.size;
      this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
      this.name = name;
      this.value = value;
    }
    async *encode() {
      yield this.headers;
      const { value } = this;
      if (utils_default.isTypedArray(value)) {
        yield value;
      } else {
        yield* readBlob_default(value);
      }
      yield CRLF_BYTES;
    }
    static escapeName(name) {
      return String(name).replace(/[\r\n"]/g, (match) => ({
        "\r": "%0D",
        "\n": "%0A",
        '"': "%22"
      })[match]);
    }
  };
  var formDataToStream = (form, headersHandler, options) => {
    const {
      tag = "form-data-boundary",
      size = 25,
      boundary = tag + "-" + utils_default.generateString(size, BOUNDARY_ALPHABET)
    } = options || {};
    if (!utils_default.isFormData(form)) {
      throw TypeError("FormData instance required");
    }
    if (boundary.length < 1 || boundary.length > 70) {
      throw Error("boundary must be 10-70 characters long");
    }
    const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
    const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF + CRLF);
    let contentLength = footerBytes.byteLength;
    const parts = Array.from(form.entries()).map(([name, value]) => {
      const part = new FormDataPart(name, value);
      contentLength += part.size;
      return part;
    });
    contentLength += boundaryBytes.byteLength * parts.length;
    contentLength = utils_default.toFiniteNumber(contentLength);
    const computedHeaders = {
      "Content-Type": `multipart/form-data; boundary=${boundary}`
    };
    if (Number.isFinite(contentLength)) {
      computedHeaders["Content-Length"] = contentLength;
    }
    headersHandler && headersHandler(computedHeaders);
    return import_stream2.Readable.from(async function* () {
      for (const part of parts) {
        yield boundaryBytes;
        yield* part.encode();
      }
      yield footerBytes;
    }());
  };
  var formDataToStream_default = formDataToStream;

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js
  var import_stream3 = __toESM(__require("stream"), 1);
  var ZlibHeaderTransformStream = class extends import_stream3.default.Transform {
    __transform(chunk, encoding, callback) {
      this.push(chunk);
      callback();
    }
    _transform(chunk, encoding, callback) {
      if (chunk.length !== 0) {
        this._transform = this.__transform;
        if (chunk[0] !== 120) {
          const header = Buffer.alloc(2);
          header[0] = 120;
          header[1] = 156;
          this.push(header, encoding);
        }
      }
      this.__transform(chunk, encoding, callback);
    }
  };
  var ZlibHeaderTransformStream_default = ZlibHeaderTransformStream;

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/callbackify.js
  var callbackify = (fn, reducer) => {
    return utils_default.isAsyncFn(fn) ? function(...args) {
      const cb = args.pop();
      fn.apply(this, args).then((value) => {
        try {
          reducer ? cb(null, ...reducer(value)) : cb(null, value);
        } catch (err) {
          cb(err);
        }
      }, cb);
    } : fn;
  };
  var callbackify_default = callbackify;

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/speedometer.js
  function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min = min !== void 0 ? min : 1e3;
    return function push(chunkLength) {
      const now = Date.now();
      const startedAt = timestamps[tail];
      if (!firstSampleTS) {
        firstSampleTS = now;
      }
      bytes[head] = chunkLength;
      timestamps[head] = now;
      let i = tail;
      let bytesCount = 0;
      while (i !== head) {
        bytesCount += bytes[i++];
        i = i % samplesCount;
      }
      head = (head + 1) % samplesCount;
      if (head === tail) {
        tail = (tail + 1) % samplesCount;
      }
      if (now - firstSampleTS < min) {
        return;
      }
      const passed = startedAt && now - startedAt;
      return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
    };
  }
  var speedometer_default = speedometer;

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/throttle.js
  function throttle(fn, freq) {
    let timestamp = 0;
    let threshold = 1e3 / freq;
    let lastArgs;
    let timer;
    const invoke = (args, now = Date.now()) => {
      timestamp = now;
      lastArgs = null;
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      fn.apply(null, args);
    };
    const throttled = (...args) => {
      const now = Date.now();
      const passed = now - timestamp;
      if (passed >= threshold) {
        invoke(args, now);
      } else {
        lastArgs = args;
        if (!timer) {
          timer = setTimeout(() => {
            timer = null;
            invoke(lastArgs);
          }, threshold - passed);
        }
      }
    };
    const flush = () => lastArgs && invoke(lastArgs);
    return [throttled, flush];
  }
  var throttle_default = throttle;

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/progressEventReducer.js
  var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
    let bytesNotified = 0;
    const _speedometer = speedometer_default(50, 250);
    return throttle_default((e) => {
      const loaded = e.loaded;
      const total = e.lengthComputable ? e.total : void 0;
      const progressBytes = loaded - bytesNotified;
      const rate = _speedometer(progressBytes);
      const inRange = loaded <= total;
      bytesNotified = loaded;
      const data = {
        loaded,
        total,
        progress: total ? loaded / total : void 0,
        bytes: progressBytes,
        rate: rate ? rate : void 0,
        estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
        event: e,
        lengthComputable: total != null,
        [isDownloadStream ? "download" : "upload"]: true
      };
      listener(data);
    }, freq);
  };
  var progressEventDecorator = (total, throttled) => {
    const lengthComputable = total != null;
    return [(loaded) => throttled[0]({
      lengthComputable,
      total,
      loaded
    }), throttled[1]];
  };
  var asyncDecorator = (fn) => (...args) => utils_default.asap(() => fn(...args));

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/adapters/http.js
  var zlibOptions = {
    flush: import_zlib.default.constants.Z_SYNC_FLUSH,
    finishFlush: import_zlib.default.constants.Z_SYNC_FLUSH
  };
  var brotliOptions = {
    flush: import_zlib.default.constants.BROTLI_OPERATION_FLUSH,
    finishFlush: import_zlib.default.constants.BROTLI_OPERATION_FLUSH
  };
  var isBrotliSupported = utils_default.isFunction(import_zlib.default.createBrotliDecompress);
  var { http: httpFollow, https: httpsFollow } = import_follow_redirects.default;
  var isHttps = /https:?/;
  var supportedProtocols = platform_default.protocols.map((protocol) => {
    return protocol + ":";
  });
  var flushOnFinish = (stream4, [throttled, flush]) => {
    stream4.on("end", flush).on("error", flush);
    return throttled;
  };
  function dispatchBeforeRedirect(options, responseDetails) {
    if (options.beforeRedirects.proxy) {
      options.beforeRedirects.proxy(options);
    }
    if (options.beforeRedirects.config) {
      options.beforeRedirects.config(options, responseDetails);
    }
  }
  function setProxy(options, configProxy, location) {
    let proxy = configProxy;
    if (!proxy && proxy !== false) {
      const proxyUrl = import_proxy_from_env.default.getProxyForUrl(location);
      if (proxyUrl) {
        proxy = new URL(proxyUrl);
      }
    }
    if (proxy) {
      if (proxy.username) {
        proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
      }
      if (proxy.auth) {
        if (proxy.auth.username || proxy.auth.password) {
          proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
        }
        const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
        options.headers["Proxy-Authorization"] = "Basic " + base64;
      }
      options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
      const proxyHost = proxy.hostname || proxy.host;
      options.hostname = proxyHost;
      options.host = proxyHost;
      options.port = proxy.port;
      options.path = location;
      if (proxy.protocol) {
        options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
      }
    }
    options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
      setProxy(redirectOptions, configProxy, redirectOptions.href);
    };
  }
  var isHttpAdapterSupported = typeof process !== "undefined" && utils_default.kindOf(process) === "process";
  var wrapAsync = (asyncExecutor) => {
    return new Promise((resolve, reject) => {
      let onDone;
      let isDone;
      const done = (value, isRejected) => {
        if (isDone) return;
        isDone = true;
        onDone && onDone(value, isRejected);
      };
      const _resolve = (value) => {
        done(value);
        resolve(value);
      };
      const _reject = (reason) => {
        done(reason, true);
        reject(reason);
      };
      asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
    });
  };
  var resolveFamily = ({ address, family }) => {
    if (!utils_default.isString(address)) {
      throw TypeError("address must be a string");
    }
    return {
      address,
      family: family || (address.indexOf(".") < 0 ? 6 : 4)
    };
  };
  var buildAddressEntry = (address, family) => resolveFamily(utils_default.isObject(address) ? address : { address, family });
  var http_default = isHttpAdapterSupported && function httpAdapter(config) {
    return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
      let { data, lookup, family } = config;
      const { responseType, responseEncoding } = config;
      const method = config.method.toUpperCase();
      let isDone;
      let rejected = false;
      let req;
      if (lookup) {
        const _lookup = callbackify_default(lookup, (value) => utils_default.isArray(value) ? value : [value]);
        lookup = (hostname, opt, cb) => {
          _lookup(hostname, opt, (err, arg0, arg1) => {
            if (err) {
              return cb(err);
            }
            const addresses = utils_default.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
            opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
          });
        };
      }
      const emitter = new import_events.EventEmitter();
      const onFinished = () => {
        if (config.cancelToken) {
          config.cancelToken.unsubscribe(abort);
        }
        if (config.signal) {
          config.signal.removeEventListener("abort", abort);
        }
        emitter.removeAllListeners();
      };
      onDone((value, isRejected) => {
        isDone = true;
        if (isRejected) {
          rejected = true;
          onFinished();
        }
      });
      function abort(reason) {
        emitter.emit("abort", !reason || reason.type ? new CanceledError_default(null, config, req) : reason);
      }
      emitter.once("abort", reject);
      if (config.cancelToken || config.signal) {
        config.cancelToken && config.cancelToken.subscribe(abort);
        if (config.signal) {
          config.signal.aborted ? abort() : config.signal.addEventListener("abort", abort);
        }
      }
      const fullPath = buildFullPath(config.baseURL, config.url);
      const parsed = new URL(fullPath, platform_default.hasBrowserEnv ? platform_default.origin : void 0);
      const protocol = parsed.protocol || supportedProtocols[0];
      if (protocol === "data:") {
        let convertedData;
        if (method !== "GET") {
          return settle(resolve, reject, {
            status: 405,
            statusText: "method not allowed",
            headers: {},
            config
          });
        }
        try {
          convertedData = fromDataURI(config.url, responseType === "blob", {
            Blob: config.env && config.env.Blob
          });
        } catch (err) {
          throw AxiosError_default.from(err, AxiosError_default.ERR_BAD_REQUEST, config);
        }
        if (responseType === "text") {
          convertedData = convertedData.toString(responseEncoding);
          if (!responseEncoding || responseEncoding === "utf8") {
            convertedData = utils_default.stripBOM(convertedData);
          }
        } else if (responseType === "stream") {
          convertedData = import_stream4.default.Readable.from(convertedData);
        }
        return settle(resolve, reject, {
          data: convertedData,
          status: 200,
          statusText: "OK",
          headers: new AxiosHeaders_default(),
          config
        });
      }
      if (supportedProtocols.indexOf(protocol) === -1) {
        return reject(new AxiosError_default(
          "Unsupported protocol " + protocol,
          AxiosError_default.ERR_BAD_REQUEST,
          config
        ));
      }
      const headers = AxiosHeaders_default.from(config.headers).normalize();
      headers.set("User-Agent", "axios/" + VERSION, false);
      const { onUploadProgress, onDownloadProgress } = config;
      const maxRate = config.maxRate;
      let maxUploadRate = void 0;
      let maxDownloadRate = void 0;
      if (utils_default.isSpecCompliantForm(data)) {
        const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
        data = formDataToStream_default(data, (formHeaders) => {
          headers.set(formHeaders);
        }, {
          tag: `axios-${VERSION}-boundary`,
          boundary: userBoundary && userBoundary[1] || void 0
        });
      } else if (utils_default.isFormData(data) && utils_default.isFunction(data.getHeaders)) {
        headers.set(data.getHeaders());
        if (!headers.hasContentLength()) {
          try {
            const knownLength = await import_util2.default.promisify(data.getLength).call(data);
            Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
          } catch (e) {
          }
        }
      } else if (utils_default.isBlob(data) || utils_default.isFile(data)) {
        data.size && headers.setContentType(data.type || "application/octet-stream");
        headers.setContentLength(data.size || 0);
        data = import_stream4.default.Readable.from(readBlob_default(data));
      } else if (data && !utils_default.isStream(data)) {
        if (Buffer.isBuffer(data)) {
        } else if (utils_default.isArrayBuffer(data)) {
          data = Buffer.from(new Uint8Array(data));
        } else if (utils_default.isString(data)) {
          data = Buffer.from(data, "utf-8");
        } else {
          return reject(new AxiosError_default(
            "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
            AxiosError_default.ERR_BAD_REQUEST,
            config
          ));
        }
        headers.setContentLength(data.length, false);
        if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
          return reject(new AxiosError_default(
            "Request body larger than maxBodyLength limit",
            AxiosError_default.ERR_BAD_REQUEST,
            config
          ));
        }
      }
      const contentLength = utils_default.toFiniteNumber(headers.getContentLength());
      if (utils_default.isArray(maxRate)) {
        maxUploadRate = maxRate[0];
        maxDownloadRate = maxRate[1];
      } else {
        maxUploadRate = maxDownloadRate = maxRate;
      }
      if (data && (onUploadProgress || maxUploadRate)) {
        if (!utils_default.isStream(data)) {
          data = import_stream4.default.Readable.from(data, { objectMode: false });
        }
        data = import_stream4.default.pipeline([data, new AxiosTransformStream_default({
          maxRate: utils_default.toFiniteNumber(maxUploadRate)
        })], utils_default.noop);
        onUploadProgress && data.on("progress", flushOnFinish(
          data,
          progressEventDecorator(
            contentLength,
            progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
          )
        ));
      }
      let auth = void 0;
      if (config.auth) {
        const username = config.auth.username || "";
        const password = config.auth.password || "";
        auth = username + ":" + password;
      }
      if (!auth && parsed.username) {
        const urlUsername = parsed.username;
        const urlPassword = parsed.password;
        auth = urlUsername + ":" + urlPassword;
      }
      auth && headers.delete("authorization");
      let path;
      try {
        path = buildURL(
          parsed.pathname + parsed.search,
          config.params,
          config.paramsSerializer
        ).replace(/^\?/, "");
      } catch (err) {
        const customErr = new Error(err.message);
        customErr.config = config;
        customErr.url = config.url;
        customErr.exists = true;
        return reject(customErr);
      }
      headers.set(
        "Accept-Encoding",
        "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
        false
      );
      const options = {
        path,
        method,
        headers: headers.toJSON(),
        agents: { http: config.httpAgent, https: config.httpsAgent },
        auth,
        protocol,
        family,
        beforeRedirect: dispatchBeforeRedirect,
        beforeRedirects: {}
      };
      !utils_default.isUndefined(lookup) && (options.lookup = lookup);
      if (config.socketPath) {
        options.socketPath = config.socketPath;
      } else {
        options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
        options.port = parsed.port;
        setProxy(options, config.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
      }
      let transport;
      const isHttpsRequest = isHttps.test(options.protocol);
      options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
      if (config.transport) {
        transport = config.transport;
      } else if (config.maxRedirects === 0) {
        transport = isHttpsRequest ? import_https.default : import_http.default;
      } else {
        if (config.maxRedirects) {
          options.maxRedirects = config.maxRedirects;
        }
        if (config.beforeRedirect) {
          options.beforeRedirects.config = config.beforeRedirect;
        }
        transport = isHttpsRequest ? httpsFollow : httpFollow;
      }
      if (config.maxBodyLength > -1) {
        options.maxBodyLength = config.maxBodyLength;
      } else {
        options.maxBodyLength = Infinity;
      }
      if (config.insecureHTTPParser) {
        options.insecureHTTPParser = config.insecureHTTPParser;
      }
      req = transport.request(options, function handleResponse(res) {
        if (req.destroyed) return;
        const streams = [res];
        const responseLength = +res.headers["content-length"];
        if (onDownloadProgress || maxDownloadRate) {
          const transformStream = new AxiosTransformStream_default({
            maxRate: utils_default.toFiniteNumber(maxDownloadRate)
          });
          onDownloadProgress && transformStream.on("progress", flushOnFinish(
            transformStream,
            progressEventDecorator(
              responseLength,
              progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
            )
          ));
          streams.push(transformStream);
        }
        let responseStream = res;
        const lastRequest = res.req || req;
        if (config.decompress !== false && res.headers["content-encoding"]) {
          if (method === "HEAD" || res.statusCode === 204) {
            delete res.headers["content-encoding"];
          }
          switch ((res.headers["content-encoding"] || "").toLowerCase()) {
            /*eslint default-case:0*/
            case "gzip":
            case "x-gzip":
            case "compress":
            case "x-compress":
              streams.push(import_zlib.default.createUnzip(zlibOptions));
              delete res.headers["content-encoding"];
              break;
            case "deflate":
              streams.push(new ZlibHeaderTransformStream_default());
              streams.push(import_zlib.default.createUnzip(zlibOptions));
              delete res.headers["content-encoding"];
              break;
            case "br":
              if (isBrotliSupported) {
                streams.push(import_zlib.default.createBrotliDecompress(brotliOptions));
                delete res.headers["content-encoding"];
              }
          }
        }
        responseStream = streams.length > 1 ? import_stream4.default.pipeline(streams, utils_default.noop) : streams[0];
        const offListeners = import_stream4.default.finished(responseStream, () => {
          offListeners();
          onFinished();
        });
        const response = {
          status: res.statusCode,
          statusText: res.statusMessage,
          headers: new AxiosHeaders_default(res.headers),
          config,
          request: lastRequest
        };
        if (responseType === "stream") {
          response.data = responseStream;
          settle(resolve, reject, response);
        } else {
          const responseBuffer = [];
          let totalResponseBytes = 0;
          responseStream.on("data", function handleStreamData(chunk) {
            responseBuffer.push(chunk);
            totalResponseBytes += chunk.length;
            if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
              rejected = true;
              responseStream.destroy();
              reject(new AxiosError_default(
                "maxContentLength size of " + config.maxContentLength + " exceeded",
                AxiosError_default.ERR_BAD_RESPONSE,
                config,
                lastRequest
              ));
            }
          });
          responseStream.on("aborted", function handlerStreamAborted() {
            if (rejected) {
              return;
            }
            const err = new AxiosError_default(
              "stream has been aborted",
              AxiosError_default.ERR_BAD_RESPONSE,
              config,
              lastRequest
            );
            responseStream.destroy(err);
            reject(err);
          });
          responseStream.on("error", function handleStreamError(err) {
            if (req.destroyed) return;
            reject(AxiosError_default.from(err, null, config, lastRequest));
          });
          responseStream.on("end", function handleStreamEnd() {
            try {
              let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
              if (responseType !== "arraybuffer") {
                responseData = responseData.toString(responseEncoding);
                if (!responseEncoding || responseEncoding === "utf8") {
                  responseData = utils_default.stripBOM(responseData);
                }
              }
              response.data = responseData;
            } catch (err) {
              return reject(AxiosError_default.from(err, null, config, response.request, response));
            }
            settle(resolve, reject, response);
          });
        }
        emitter.once("abort", (err) => {
          if (!responseStream.destroyed) {
            responseStream.emit("error", err);
            responseStream.destroy();
          }
        });
      });
      emitter.once("abort", (err) => {
        reject(err);
        req.destroy(err);
      });
      req.on("error", function handleRequestError(err) {
        reject(AxiosError_default.from(err, null, config, req));
      });
      req.on("socket", function handleRequestSocket(socket) {
        socket.setKeepAlive(true, 1e3 * 60);
      });
      if (config.timeout) {
        const timeout = parseInt(config.timeout, 10);
        if (Number.isNaN(timeout)) {
          reject(new AxiosError_default(
            "error trying to parse `config.timeout` to int",
            AxiosError_default.ERR_BAD_OPTION_VALUE,
            config,
            req
          ));
          return;
        }
        req.setTimeout(timeout, function handleRequestTimeout() {
          if (isDone) return;
          let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional2 = config.transitional || transitional_default;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(new AxiosError_default(
            timeoutErrorMessage,
            transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
            config,
            req
          ));
          abort();
        });
      }
      if (utils_default.isStream(data)) {
        let ended = false;
        let errored = false;
        data.on("end", () => {
          ended = true;
        });
        data.once("error", (err) => {
          errored = true;
          req.destroy(err);
        });
        data.on("close", () => {
          if (!ended && !errored) {
            abort(new CanceledError_default("Request stream has been aborted", config, req));
          }
        });
        data.pipe(req);
      } else {
        req.end(data);
      }
    });
  };

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/isURLSameOrigin.js
  var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url2) => {
    url2 = new URL(url2, platform_default.origin);
    return origin2.protocol === url2.protocol && origin2.host === url2.host && (isMSIE || origin2.port === url2.port);
  })(
    new URL(platform_default.origin),
    platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)
  ) : () => true;

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/cookies.js
  var cookies_default = platform_default.hasStandardBrowserEnv ? (
    // Standard browser envs support document.cookie
    {
      write(name, value, expires, path, domain, secure) {
        const cookie = [name + "=" + encodeURIComponent(value)];
        utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
        utils_default.isString(path) && cookie.push("path=" + path);
        utils_default.isString(domain) && cookie.push("domain=" + domain);
        secure === true && cookie.push("secure");
        document.cookie = cookie.join("; ");
      },
      read(name) {
        const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    }
  ) : (
    // Non-standard browser env (web workers, react-native) lack needed support.
    {
      write() {
      },
      read() {
        return null;
      },
      remove() {
      }
    }
  );

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/core/mergeConfig.js
  var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
  function mergeConfig(config1, config2) {
    config2 = config2 || {};
    const config = {};
    function getMergedValue(target, source, prop, caseless) {
      if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
        return utils_default.merge.call({ caseless }, target, source);
      } else if (utils_default.isPlainObject(source)) {
        return utils_default.merge({}, source);
      } else if (utils_default.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(a, b, prop, caseless) {
      if (!utils_default.isUndefined(b)) {
        return getMergedValue(a, b, prop, caseless);
      } else if (!utils_default.isUndefined(a)) {
        return getMergedValue(void 0, a, prop, caseless);
      }
    }
    function valueFromConfig2(a, b) {
      if (!utils_default.isUndefined(b)) {
        return getMergedValue(void 0, b);
      }
    }
    function defaultToConfig2(a, b) {
      if (!utils_default.isUndefined(b)) {
        return getMergedValue(void 0, b);
      } else if (!utils_default.isUndefined(a)) {
        return getMergedValue(void 0, a);
      }
    }
    function mergeDirectKeys(a, b, prop) {
      if (prop in config2) {
        return getMergedValue(a, b);
      } else if (prop in config1) {
        return getMergedValue(void 0, a);
      }
    }
    const mergeMap = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      withXSRFToken: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
    };
    utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
      const merge2 = mergeMap[prop] || mergeDeepProperties;
      const configValue = merge2(config1[prop], config2[prop], prop);
      utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
  }

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/resolveConfig.js
  var resolveConfig_default = (config) => {
    const newConfig = mergeConfig({}, config);
    let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
    newConfig.headers = headers = AxiosHeaders_default.from(headers);
    newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);
    if (auth) {
      headers.set(
        "Authorization",
        "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
      );
    }
    let contentType;
    if (utils_default.isFormData(data)) {
      if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
        headers.setContentType(void 0);
      } else if ((contentType = headers.getContentType()) !== false) {
        const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
        headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
      }
    }
    if (platform_default.hasStandardBrowserEnv) {
      withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
        const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
        if (xsrfValue) {
          headers.set(xsrfHeaderName, xsrfValue);
        }
      }
    }
    return newConfig;
  };

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/adapters/xhr.js
  var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
  var xhr_default = isXHRAdapterSupported && function(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      const _config = resolveConfig_default(config);
      let requestData = _config.data;
      const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
      let { responseType, onUploadProgress, onDownloadProgress } = _config;
      let onCanceled;
      let uploadThrottled, downloadThrottled;
      let flushUpload, flushDownload;
      function done() {
        flushUpload && flushUpload();
        flushDownload && flushDownload();
        _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
        _config.signal && _config.signal.removeEventListener("abort", onCanceled);
      }
      let request = new XMLHttpRequest();
      request.open(_config.method.toUpperCase(), _config.url, true);
      request.timeout = _config.timeout;
      function onloadend() {
        if (!request) {
          return;
        }
        const responseHeaders = AxiosHeaders_default.from(
          "getAllResponseHeaders" in request && request.getAllResponseHeaders()
        );
        const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
        const response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config,
          request
        };
        settle(function _resolve(value) {
          resolve(value);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request = null;
      }
      if ("onloadend" in request) {
        request.onloadend = onloadend;
      } else {
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
        request = null;
      };
      request.onerror = function handleError() {
        reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request));
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional2 = _config.transitional || transitional_default;
        if (_config.timeoutErrorMessage) {
          timeoutErrorMessage = _config.timeoutErrorMessage;
        }
        reject(new AxiosError_default(
          timeoutErrorMessage,
          transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
          config,
          request
        ));
        request = null;
      };
      requestData === void 0 && requestHeaders.setContentType(null);
      if ("setRequestHeader" in request) {
        utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
          request.setRequestHeader(key, val);
        });
      }
      if (!utils_default.isUndefined(_config.withCredentials)) {
        request.withCredentials = !!_config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request.responseType = _config.responseType;
      }
      if (onDownloadProgress) {
        [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
        request.addEventListener("progress", downloadThrottled);
      }
      if (onUploadProgress && request.upload) {
        [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
        request.upload.addEventListener("progress", uploadThrottled);
        request.upload.addEventListener("loadend", flushUpload);
      }
      if (_config.cancelToken || _config.signal) {
        onCanceled = (cancel) => {
          if (!request) {
            return;
          }
          reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
          request.abort();
          request = null;
        };
        _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
        if (_config.signal) {
          _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
        }
      }
      const protocol = parseProtocol(_config.url);
      if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
        reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
        return;
      }
      request.send(requestData || null);
    });
  };

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/composeSignals.js
  var composeSignals = (signals, timeout) => {
    const { length } = signals = signals ? signals.filter(Boolean) : [];
    if (timeout || length) {
      let controller = new AbortController();
      let aborted;
      const onabort = function(reason) {
        if (!aborted) {
          aborted = true;
          unsubscribe();
          const err = reason instanceof Error ? reason : this.reason;
          controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
        }
      };
      let timer = timeout && setTimeout(() => {
        timer = null;
        onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
      }, timeout);
      const unsubscribe = () => {
        if (signals) {
          timer && clearTimeout(timer);
          timer = null;
          signals.forEach((signal2) => {
            signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
          });
          signals = null;
        }
      };
      signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
      const { signal } = controller;
      signal.unsubscribe = () => utils_default.asap(unsubscribe);
      return signal;
    }
  };
  var composeSignals_default = composeSignals;

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/trackStream.js
  var streamChunk = function* (chunk, chunkSize) {
    let len = chunk.byteLength;
    if (!chunkSize || len < chunkSize) {
      yield chunk;
      return;
    }
    let pos = 0;
    let end;
    while (pos < len) {
      end = pos + chunkSize;
      yield chunk.slice(pos, end);
      pos = end;
    }
  };
  var readBytes = async function* (iterable, chunkSize) {
    for await (const chunk of readStream(iterable)) {
      yield* streamChunk(chunk, chunkSize);
    }
  };
  var readStream = async function* (stream4) {
    if (stream4[Symbol.asyncIterator]) {
      yield* stream4;
      return;
    }
    const reader = stream4.getReader();
    try {
      for (; ; ) {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        yield value;
      }
    } finally {
      await reader.cancel();
    }
  };
  var trackStream = (stream4, chunkSize, onProgress, onFinish) => {
    const iterator = readBytes(stream4, chunkSize);
    let bytes = 0;
    let done;
    let _onFinish = (e) => {
      if (!done) {
        done = true;
        onFinish && onFinish(e);
      }
    };
    return new ReadableStream({
      async pull(controller) {
        try {
          const { done: done2, value } = await iterator.next();
          if (done2) {
            _onFinish();
            controller.close();
            return;
          }
          let len = value.byteLength;
          if (onProgress) {
            let loadedBytes = bytes += len;
            onProgress(loadedBytes);
          }
          controller.enqueue(new Uint8Array(value));
        } catch (err) {
          _onFinish(err);
          throw err;
        }
      },
      cancel(reason) {
        _onFinish(reason);
        return iterator.return();
      }
    }, {
      highWaterMark: 2
    });
  };

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/adapters/fetch.js
  var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
  var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
  var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
  var test = (fn, ...args) => {
    try {
      return !!fn(...args);
    } catch (e) {
      return false;
    }
  };
  var supportsRequestStream = isReadableStreamSupported && test(() => {
    let duplexAccessed = false;
    const hasContentType = new Request(platform_default.origin, {
      body: new ReadableStream(),
      method: "POST",
      get duplex() {
        duplexAccessed = true;
        return "half";
      }
    }).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
  });
  var DEFAULT_CHUNK_SIZE = 64 * 1024;
  var supportsResponseStream = isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response("").body));
  var resolvers = {
    stream: supportsResponseStream && ((res) => res.body)
  };
  isFetchSupported && ((res) => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
      !resolvers[type] && (resolvers[type] = utils_default.isFunction(res[type]) ? (res2) => res2[type]() : (_, config) => {
        throw new AxiosError_default(`Response type '${type}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config);
      });
    });
  })(new Response());
  var getBodyLength = async (body) => {
    if (body == null) {
      return 0;
    }
    if (utils_default.isBlob(body)) {
      return body.size;
    }
    if (utils_default.isSpecCompliantForm(body)) {
      const _request = new Request(platform_default.origin, {
        method: "POST",
        body
      });
      return (await _request.arrayBuffer()).byteLength;
    }
    if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
      return body.byteLength;
    }
    if (utils_default.isURLSearchParams(body)) {
      body = body + "";
    }
    if (utils_default.isString(body)) {
      return (await encodeText(body)).byteLength;
    }
  };
  var resolveBodyLength = async (headers, body) => {
    const length = utils_default.toFiniteNumber(headers.getContentLength());
    return length == null ? getBodyLength(body) : length;
  };
  var fetch_default = isFetchSupported && (async (config) => {
    let {
      url: url2,
      method,
      data,
      signal,
      cancelToken,
      timeout,
      onDownloadProgress,
      onUploadProgress,
      responseType,
      headers,
      withCredentials = "same-origin",
      fetchOptions
    } = resolveConfig_default(config);
    responseType = responseType ? (responseType + "").toLowerCase() : "text";
    let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
    let request;
    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
    });
    let requestContentLength;
    try {
      if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
        let _request = new Request(url2, {
          method: "POST",
          body: data,
          duplex: "half"
        });
        let contentTypeHeader;
        if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
          headers.setContentType(contentTypeHeader);
        }
        if (_request.body) {
          const [onProgress, flush] = progressEventDecorator(
            requestContentLength,
            progressEventReducer(asyncDecorator(onUploadProgress))
          );
          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
        }
      }
      if (!utils_default.isString(withCredentials)) {
        withCredentials = withCredentials ? "include" : "omit";
      }
      const isCredentialsSupported = "credentials" in Request.prototype;
      request = new Request(url2, {
        ...fetchOptions,
        signal: composedSignal,
        method: method.toUpperCase(),
        headers: headers.normalize().toJSON(),
        body: data,
        duplex: "half",
        credentials: isCredentialsSupported ? withCredentials : void 0
      });
      let response = await fetch(request);
      const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
      if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
        const options = {};
        ["status", "statusText", "headers"].forEach((prop) => {
          options[prop] = response[prop];
        });
        const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
          responseContentLength,
          progressEventReducer(asyncDecorator(onDownloadProgress), true)
        ) || [];
        response = new Response(
          trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
            flush && flush();
            unsubscribe && unsubscribe();
          }),
          options
        );
      }
      responseType = responseType || "text";
      let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config);
      !isStreamResponse && unsubscribe && unsubscribe();
      return await new Promise((resolve, reject) => {
        settle(resolve, reject, {
          data: responseData,
          headers: AxiosHeaders_default.from(response.headers),
          status: response.status,
          statusText: response.statusText,
          config,
          request
        });
      });
    } catch (err) {
      unsubscribe && unsubscribe();
      if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
        throw Object.assign(
          new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request),
          {
            cause: err.cause || err
          }
        );
      }
      throw AxiosError_default.from(err, err && err.code, config, request);
    }
  });

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/adapters/adapters.js
  var knownAdapters = {
    http: http_default,
    xhr: xhr_default,
    fetch: fetch_default
  };
  utils_default.forEach(knownAdapters, (fn, value) => {
    if (fn) {
      try {
        Object.defineProperty(fn, "name", { value });
      } catch (e) {
      }
      Object.defineProperty(fn, "adapterName", { value });
    }
  });
  var renderReason = (reason) => `- ${reason}`;
  var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
  var adapters_default = {
    getAdapter: (adapters) => {
      adapters = utils_default.isArray(adapters) ? adapters : [adapters];
      const { length } = adapters;
      let nameOrAdapter;
      let adapter;
      const rejectedReasons = {};
      for (let i = 0; i < length; i++) {
        nameOrAdapter = adapters[i];
        let id;
        adapter = nameOrAdapter;
        if (!isResolvedHandle(nameOrAdapter)) {
          adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
          if (adapter === void 0) {
            throw new AxiosError_default(`Unknown adapter '${id}'`);
          }
        }
        if (adapter) {
          break;
        }
        rejectedReasons[id || "#" + i] = adapter;
      }
      if (!adapter) {
        const reasons = Object.entries(rejectedReasons).map(
          ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
        );
        let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
        throw new AxiosError_default(
          `There is no suitable adapter to dispatch the request ` + s,
          "ERR_NOT_SUPPORT"
        );
      }
      return adapter;
    },
    adapters: knownAdapters
  };

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/core/dispatchRequest.js
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
    if (config.signal && config.signal.aborted) {
      throw new CanceledError_default(null, config);
    }
  }
  function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = AxiosHeaders_default.from(config.headers);
    config.data = transformData.call(
      config,
      config.transformRequest
    );
    if (["post", "put", "patch"].indexOf(config.method) !== -1) {
      config.headers.setContentType("application/x-www-form-urlencoded", false);
    }
    const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData.call(
        config,
        config.transformResponse,
        response
      );
      response.headers = AxiosHeaders_default.from(response.headers);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData.call(
            config,
            config.transformResponse,
            reason.response
          );
          reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
        }
      }
      return Promise.reject(reason);
    });
  }

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/validator.js
  var validators = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
    validators[type] = function validator(thing) {
      return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
    };
  });
  var deprecatedWarnings = {};
  validators.transitional = function transitional(validator, version2, message) {
    function formatMessage(opt, desc) {
      return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return (value, opt, opts) => {
      if (validator === false) {
        throw new AxiosError_default(
          formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
          AxiosError_default.ERR_DEPRECATED
        );
      }
      if (version2 && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(
          formatMessage(
            opt,
            " has been deprecated since v" + version2 + " and will be removed in the near future"
          )
        );
      }
      return validator ? validator(value, opt, opts) : true;
    };
  };
  validators.spelling = function spelling(correctSpelling) {
    return (value, opt) => {
      console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
      return true;
    };
  };
  function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") {
      throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
    }
    const keys = Object.keys(options);
    let i = keys.length;
    while (i-- > 0) {
      const opt = keys[i];
      const validator = schema[opt];
      if (validator) {
        const value = options[opt];
        const result = value === void 0 || validator(value, opt, options);
        if (result !== true) {
          throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
      }
    }
  }
  var validator_default = {
    assertOptions,
    validators
  };

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/core/Axios.js
  var validators2 = validator_default.validators;
  var Axios = class {
    constructor(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager_default(),
        response: new InterceptorManager_default()
      };
    }
    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    async request(configOrUrl, config) {
      try {
        return await this._request(configOrUrl, config);
      } catch (err) {
        if (err instanceof Error) {
          let dummy = {};
          Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
          const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
          try {
            if (!err.stack) {
              err.stack = stack;
            } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
              err.stack += "\n" + stack;
            }
          } catch (e) {
          }
        }
        throw err;
      }
    }
    _request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig(this.defaults, config);
      const { transitional: transitional2, paramsSerializer, headers } = config;
      if (transitional2 !== void 0) {
        validator_default.assertOptions(transitional2, {
          silentJSONParsing: validators2.transitional(validators2.boolean),
          forcedJSONParsing: validators2.transitional(validators2.boolean),
          clarifyTimeoutError: validators2.transitional(validators2.boolean)
        }, false);
      }
      if (paramsSerializer != null) {
        if (utils_default.isFunction(paramsSerializer)) {
          config.paramsSerializer = {
            serialize: paramsSerializer
          };
        } else {
          validator_default.assertOptions(paramsSerializer, {
            encode: validators2.function,
            serialize: validators2.function
          }, true);
        }
      }
      validator_default.assertOptions(config, {
        baseUrl: validators2.spelling("baseURL"),
        withXsrfToken: validators2.spelling("withXSRFToken")
      }, true);
      config.method = (config.method || this.defaults.method || "get").toLowerCase();
      let contextHeaders = headers && utils_default.merge(
        headers.common,
        headers[config.method]
      );
      headers && utils_default.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (method) => {
          delete headers[method];
        }
      );
      config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
      const requestInterceptorChain = [];
      let synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      const responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      let promise;
      let i = 0;
      let len;
      if (!synchronousRequestInterceptors) {
        const chain = [dispatchRequest.bind(this), void 0];
        chain.unshift.apply(chain, requestInterceptorChain);
        chain.push.apply(chain, responseInterceptorChain);
        len = chain.length;
        promise = Promise.resolve(config);
        while (i < len) {
          promise = promise.then(chain[i++], chain[i++]);
        }
        return promise;
      }
      len = requestInterceptorChain.length;
      let newConfig = config;
      i = 0;
      while (i < len) {
        const onFulfilled = requestInterceptorChain[i++];
        const onRejected = requestInterceptorChain[i++];
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected.call(this, error);
          break;
        }
      }
      try {
        promise = dispatchRequest.call(this, newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      i = 0;
      len = responseInterceptorChain.length;
      while (i < len) {
        promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
      }
      return promise;
    }
    getUri(config) {
      config = mergeConfig(this.defaults, config);
      const fullPath = buildFullPath(config.baseURL, config.url);
      return buildURL(fullPath, config.params, config.paramsSerializer);
    }
  };
  utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios.prototype[method] = function(url2, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        url: url2,
        data: (config || {}).data
      }));
    };
  });
  utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url2, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url: url2,
          data
        }));
      };
    }
    Axios.prototype[method] = generateHTTPMethod();
    Axios.prototype[method + "Form"] = generateHTTPMethod(true);
  });
  var Axios_default = Axios;

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/cancel/CancelToken.js
  var CancelToken = class _CancelToken {
    constructor(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      let resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      const token = this;
      this.promise.then((cancel) => {
        if (!token._listeners) return;
        let i = token._listeners.length;
        while (i-- > 0) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = (onfulfilled) => {
        let _resolve;
        const promise = new Promise((resolve) => {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message, config, request) {
        if (token.reason) {
          return;
        }
        token.reason = new CanceledError_default(message, config, request);
        resolvePromise(token.reason);
      });
    }
    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }
    /**
     * Subscribe to the cancel signal
     */
    subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    }
    /**
     * Unsubscribe from the cancel signal
     */
    unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      const index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    }
    toAbortSignal() {
      const controller = new AbortController();
      const abort = (err) => {
        controller.abort(err);
      };
      this.subscribe(abort);
      controller.signal.unsubscribe = () => this.unsubscribe(abort);
      return controller.signal;
    }
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let cancel;
      const token = new _CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    }
  };
  var CancelToken_default = CancelToken;

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/spread.js
  function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  }

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/isAxiosError.js
  function isAxiosError(payload) {
    return utils_default.isObject(payload) && payload.isAxiosError === true;
  }

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/helpers/HttpStatusCode.js
  var HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
  };
  Object.entries(HttpStatusCode).forEach(([key, value]) => {
    HttpStatusCode[value] = key;
  });
  var HttpStatusCode_default = HttpStatusCode;

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/axios.js
  function createInstance(defaultConfig) {
    const context = new Axios_default(defaultConfig);
    const instance = bind(Axios_default.prototype.request, context);
    utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
    utils_default.extend(instance, context, null, { allOwnKeys: true });
    instance.create = function create(instanceConfig) {
      return createInstance(mergeConfig(defaultConfig, instanceConfig));
    };
    return instance;
  }
  var axios = createInstance(defaults_default);
  axios.Axios = Axios_default;
  axios.CanceledError = CanceledError_default;
  axios.CancelToken = CancelToken_default;
  axios.isCancel = isCancel;
  axios.VERSION = VERSION;
  axios.toFormData = toFormData_default;
  axios.AxiosError = AxiosError_default;
  axios.Cancel = axios.CanceledError;
  axios.all = function all(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread;
  axios.isAxiosError = isAxiosError;
  axios.mergeConfig = mergeConfig;
  axios.AxiosHeaders = AxiosHeaders_default;
  axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
  axios.getAdapter = adapters_default.getAdapter;
  axios.HttpStatusCode = HttpStatusCode_default;
  axios.default = axios;
  var axios_default = axios;

  // ../../node_modules/.pnpm/axios@1.7.9/node_modules/axios/index.js
  var {
    Axios: Axios2,
    AxiosError: AxiosError2,
    CanceledError: CanceledError2,
    isCancel: isCancel2,
    CancelToken: CancelToken2,
    VERSION: VERSION2,
    all: all2,
    Cancel,
    isAxiosError: isAxiosError2,
    spread: spread2,
    toFormData: toFormData2,
    AxiosHeaders: AxiosHeaders2,
    HttpStatusCode: HttpStatusCode2,
    formToJSON,
    getAdapter,
    mergeConfig: mergeConfig2
  } = axios_default;

  // src/generated/base.ts
  var BASE_PATH = "https://app.gabber.dev".replace(/\/+$/, "");
  var BaseAPI = class {
    constructor(configuration, basePath = BASE_PATH, axios2 = axios_default) {
      this.basePath = basePath;
      this.axios = axios2;
      if (configuration) {
        this.configuration = configuration;
        this.basePath = configuration.basePath ?? basePath;
      }
    }
  };
  var RequiredError = class extends Error {
    constructor(field, msg) {
      super(msg);
      this.field = field;
      this.name = "RequiredError";
    }
  };
  var operationServerMap = {};

  // src/generated/common.ts
  var DUMMY_BASE_URL = "https://example.com";
  var assertParamExists = function(functionName, paramName, paramValue) {
    if (paramValue === null || paramValue === void 0) {
      throw new RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
    }
  };
  var setApiKeyToObject = async function(object, keyParamName, configuration) {
    if (configuration && configuration.apiKey) {
      const localVarApiKeyValue = typeof configuration.apiKey === "function" ? await configuration.apiKey(keyParamName) : await configuration.apiKey;
      object[keyParamName] = localVarApiKeyValue;
    }
  };
  var setBearerAuthToObject = async function(object, configuration) {
    if (configuration && configuration.accessToken) {
      const accessToken = typeof configuration.accessToken === "function" ? await configuration.accessToken() : await configuration.accessToken;
      object["Authorization"] = "Bearer " + accessToken;
    }
  };
  function setFlattenedQueryParams(urlSearchParams, parameter, key = "") {
    if (parameter == null) return;
    if (typeof parameter === "object") {
      if (Array.isArray(parameter)) {
        parameter.forEach((item) => setFlattenedQueryParams(urlSearchParams, item, key));
      } else {
        Object.keys(parameter).forEach(
          (currentKey) => setFlattenedQueryParams(urlSearchParams, parameter[currentKey], `${key}${key !== "" ? "." : ""}${currentKey}`)
        );
      }
    } else {
      if (urlSearchParams.has(key)) {
        urlSearchParams.append(key, parameter);
      } else {
        urlSearchParams.set(key, parameter);
      }
    }
  }
  var setSearchParams = function(url2, ...objects) {
    const searchParams = new URLSearchParams(url2.search);
    setFlattenedQueryParams(searchParams, objects);
    url2.search = searchParams.toString();
  };
  var serializeDataIfNeeded = function(value, requestOptions, configuration) {
    const nonString = typeof value !== "string";
    const needsSerialization = nonString && configuration && configuration.isJsonMime ? configuration.isJsonMime(requestOptions.headers["Content-Type"]) : nonString;
    return needsSerialization ? JSON.stringify(value !== void 0 ? value : {}) : value || "";
  };
  var toPathString = function(url2) {
    return url2.pathname + url2.search + url2.hash;
  };
  var createRequestFunction = function(axiosArgs, globalAxios, BASE_PATH2, configuration) {
    return (axios2 = globalAxios, basePath = BASE_PATH2) => {
      const axiosRequestArgs = { ...axiosArgs.options, url: (axios2.defaults.baseURL ? "" : configuration?.basePath ?? basePath) + axiosArgs.url };
      return axios2.request(axiosRequestArgs);
    };
  };

  // src/generated/api/llmapi.ts
  var LLMApiAxiosParamCreator = function(configuration) {
    return {
      /**
       * Create a new Context with the given configuration. 
       * @summary Create a new Context.
       * @param {ContextCreateRequest} contextCreateRequest 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      createContext: async (contextCreateRequest, xHumanId, options = {}) => {
        assertParamExists("createContext", "contextCreateRequest", contextCreateRequest);
        const localVarPath = `/api/v1/llm/context`;
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        localVarHeaderParameter["Content-Type"] = "application/json";
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        localVarRequestOptions.data = serializeDataIfNeeded(contextCreateRequest, localVarRequestOptions, configuration);
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * Create a new ContextMessage with the given configuration. 
       * @summary Create a new ContextMessage.
       * @param {string} context The unique identifier of the Context.
       * @param {ContextMessageCreateParams} contextMessageCreateParams 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      createContextMessage: async (context, contextMessageCreateParams, xHumanId, options = {}) => {
        assertParamExists("createContextMessage", "context", context);
        assertParamExists("createContextMessage", "contextMessageCreateParams", contextMessageCreateParams);
        const localVarPath = `/api/v1/llm/context/{context}/message`.replace(`{${"context"}}`, encodeURIComponent(String(context)));
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        localVarHeaderParameter["Content-Type"] = "application/json";
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        localVarRequestOptions.data = serializeDataIfNeeded(contextMessageCreateParams, localVarRequestOptions, configuration);
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * Retrieve the Context with the given identifier. 
       * @summary Retrieve a Context.
       * @param {string} context The unique identifier of the Context.
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getContext: async (context, xHumanId, options = {}) => {
        assertParamExists("getContext", "context", context);
        const localVarPath = `/api/v1/llm/context/{context}`.replace(`{${"context"}}`, encodeURIComponent(String(context)));
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * Retrieve the ContextMessage with the given identifier. 
       * @summary Retrieve a ContextMessage.
       * @param {string} context The unique identifier of the Context.
       * @param {string} message The unique identifier of the ContextMessage.
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getContextMessage: async (context, message, xHumanId, options = {}) => {
        assertParamExists("getContextMessage", "context", context);
        assertParamExists("getContextMessage", "message", message);
        const localVarPath = `/api/v1/llm/context/{context}/message/{message}`.replace(`{${"context"}}`, encodeURIComponent(String(context))).replace(`{${"message"}}`, encodeURIComponent(String(message)));
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * 
       * @summary Get a list of llms
       * @param {string} llm 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getLLM: async (llm, xHumanId, options = {}) => {
        assertParamExists("getLLM", "llm", llm);
        const localVarPath = `/api/v1/llm/{llm}`.replace(`{${"llm"}}`, encodeURIComponent(String(llm)));
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * List all ContextMessages associated with the given Context. 
       * @summary List ContextMessages.
       * @param {string} context The unique identifier of the Context.
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      listContextMessages: async (context, xHumanId, options = {}) => {
        assertParamExists("listContextMessages", "context", context);
        const localVarPath = `/api/v1/llm/context/{context}/message/list`.replace(`{${"context"}}`, encodeURIComponent(String(context)));
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * 
       * @summary Get a list of llms
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      listLLMs: async (xHumanId, options = {}) => {
        const localVarPath = `/api/v1/llm/list`;
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      }
    };
  };
  var LLMApiFp = function(configuration) {
    const localVarAxiosParamCreator = LLMApiAxiosParamCreator(configuration);
    return {
      /**
       * Create a new Context with the given configuration. 
       * @summary Create a new Context.
       * @param {ContextCreateRequest} contextCreateRequest 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async createContext(contextCreateRequest, xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.createContext(contextCreateRequest, xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["LLMApi.createContext"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * Create a new ContextMessage with the given configuration. 
       * @summary Create a new ContextMessage.
       * @param {string} context The unique identifier of the Context.
       * @param {ContextMessageCreateParams} contextMessageCreateParams 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async createContextMessage(context, contextMessageCreateParams, xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.createContextMessage(context, contextMessageCreateParams, xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["LLMApi.createContextMessage"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * Retrieve the Context with the given identifier. 
       * @summary Retrieve a Context.
       * @param {string} context The unique identifier of the Context.
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async getContext(context, xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.getContext(context, xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["LLMApi.getContext"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * Retrieve the ContextMessage with the given identifier. 
       * @summary Retrieve a ContextMessage.
       * @param {string} context The unique identifier of the Context.
       * @param {string} message The unique identifier of the ContextMessage.
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async getContextMessage(context, message, xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.getContextMessage(context, message, xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["LLMApi.getContextMessage"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * 
       * @summary Get a list of llms
       * @param {string} llm 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async getLLM(llm, xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.getLLM(llm, xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["LLMApi.getLLM"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * List all ContextMessages associated with the given Context. 
       * @summary List ContextMessages.
       * @param {string} context The unique identifier of the Context.
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async listContextMessages(context, xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.listContextMessages(context, xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["LLMApi.listContextMessages"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * 
       * @summary Get a list of llms
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async listLLMs(xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.listLLMs(xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["LLMApi.listLLMs"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      }
    };
  };
  var LLMApi = class extends BaseAPI {
    /**
     * Create a new Context with the given configuration. 
     * @summary Create a new Context.
     * @param {ContextCreateRequest} contextCreateRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    createContext(contextCreateRequest, xHumanId, options) {
      return LLMApiFp(this.configuration).createContext(contextCreateRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new ContextMessage with the given configuration. 
     * @summary Create a new ContextMessage.
     * @param {string} context The unique identifier of the Context.
     * @param {ContextMessageCreateParams} contextMessageCreateParams 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    createContextMessage(context, contextMessageCreateParams, xHumanId, options) {
      return LLMApiFp(this.configuration).createContextMessage(context, contextMessageCreateParams, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the Context with the given identifier. 
     * @summary Retrieve a Context.
     * @param {string} context The unique identifier of the Context.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    getContext(context, xHumanId, options) {
      return LLMApiFp(this.configuration).getContext(context, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the ContextMessage with the given identifier. 
     * @summary Retrieve a ContextMessage.
     * @param {string} context The unique identifier of the Context.
     * @param {string} message The unique identifier of the ContextMessage.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    getContextMessage(context, message, xHumanId, options) {
      return LLMApiFp(this.configuration).getContextMessage(context, message, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a list of llms
     * @param {string} llm 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    getLLM(llm, xHumanId, options) {
      return LLMApiFp(this.configuration).getLLM(llm, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all ContextMessages associated with the given Context. 
     * @summary List ContextMessages.
     * @param {string} context The unique identifier of the Context.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    listContextMessages(context, xHumanId, options) {
      return LLMApiFp(this.configuration).listContextMessages(context, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a list of llms
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LLMApi
     */
    listLLMs(xHumanId, options) {
      return LLMApiFp(this.configuration).listLLMs(xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
  };

  // src/generated/api/persona-api.ts
  var PersonaApiAxiosParamCreator = function(configuration) {
    return {
      /**
       * 
       * @summary Get a persona
       * @param {CreatePersonaRequest} createPersonaRequest 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      createPersona: async (createPersonaRequest, xHumanId, options = {}) => {
        assertParamExists("createPersona", "createPersonaRequest", createPersonaRequest);
        const localVarPath = `/api/v1/persona`;
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        localVarHeaderParameter["Content-Type"] = "application/json";
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        localVarRequestOptions.data = serializeDataIfNeeded(createPersonaRequest, localVarRequestOptions, configuration);
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * 
       * @summary Delete a persona
       * @param {string} personaId 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      deletePersona: async (personaId, xHumanId, options = {}) => {
        assertParamExists("deletePersona", "personaId", personaId);
        const localVarPath = `/api/v1/persona/{persona_id}`.replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * 
       * @summary Get a persona
       * @param {string} personaId 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getPersona: async (personaId, xHumanId, options = {}) => {
        assertParamExists("getPersona", "personaId", personaId);
        const localVarPath = `/api/v1/persona/{persona_id}`.replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * 
       * @summary Get a list of personas
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      listPersonas: async (xHumanId, options = {}) => {
        const localVarPath = `/api/v1/persona/list`;
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * 
       * @summary Update a persona
       * @param {string} personaId 
       * @param {UpdatePersonaRequest} updatePersonaRequest 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      updatePersona: async (personaId, updatePersonaRequest, xHumanId, options = {}) => {
        assertParamExists("updatePersona", "personaId", personaId);
        assertParamExists("updatePersona", "updatePersonaRequest", updatePersonaRequest);
        const localVarPath = `/api/v1/persona/{persona_id}`.replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        localVarHeaderParameter["Content-Type"] = "application/json";
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        localVarRequestOptions.data = serializeDataIfNeeded(updatePersonaRequest, localVarRequestOptions, configuration);
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      }
    };
  };
  var PersonaApiFp = function(configuration) {
    const localVarAxiosParamCreator = PersonaApiAxiosParamCreator(configuration);
    return {
      /**
       * 
       * @summary Get a persona
       * @param {CreatePersonaRequest} createPersonaRequest 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async createPersona(createPersonaRequest, xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.createPersona(createPersonaRequest, xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["PersonaApi.createPersona"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * 
       * @summary Delete a persona
       * @param {string} personaId 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async deletePersona(personaId, xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.deletePersona(personaId, xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["PersonaApi.deletePersona"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * 
       * @summary Get a persona
       * @param {string} personaId 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async getPersona(personaId, xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.getPersona(personaId, xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["PersonaApi.getPersona"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * 
       * @summary Get a list of personas
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async listPersonas(xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.listPersonas(xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["PersonaApi.listPersonas"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * 
       * @summary Update a persona
       * @param {string} personaId 
       * @param {UpdatePersonaRequest} updatePersonaRequest 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async updatePersona(personaId, updatePersonaRequest, xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.updatePersona(personaId, updatePersonaRequest, xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["PersonaApi.updatePersona"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      }
    };
  };
  var PersonaApi = class extends BaseAPI {
    /**
     * 
     * @summary Get a persona
     * @param {CreatePersonaRequest} createPersonaRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    createPersona(createPersonaRequest, xHumanId, options) {
      return PersonaApiFp(this.configuration).createPersona(createPersonaRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Delete a persona
     * @param {string} personaId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    deletePersona(personaId, xHumanId, options) {
      return PersonaApiFp(this.configuration).deletePersona(personaId, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a persona
     * @param {string} personaId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    getPersona(personaId, xHumanId, options) {
      return PersonaApiFp(this.configuration).getPersona(personaId, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a list of personas
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    listPersonas(xHumanId, options) {
      return PersonaApiFp(this.configuration).listPersonas(xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Update a persona
     * @param {string} personaId 
     * @param {UpdatePersonaRequest} updatePersonaRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    updatePersona(personaId, updatePersonaRequest, xHumanId, options) {
      return PersonaApiFp(this.configuration).updatePersona(personaId, updatePersonaRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
  };

  // src/generated/api/realtime-api.ts
  var RealtimeApiAxiosParamCreator = function(configuration) {
    return {
      /**
       * End the RealtimeSession with the given identifier. 
       * @summary End a RealtimeSession.
       * @param {string} session The unique identifier of the RealtimeSession.
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      endRealtimeSession: async (session, xHumanId, options = {}) => {
        assertParamExists("endRealtimeSession", "session", session);
        const localVarPath = `/api/v1/realtime/{session}/end`.replace(`{${"session"}}`, encodeURIComponent(String(session)));
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * End the RealtimeSession with the given identifier. 
       * @summary Get a RealtimeSession.
       * @param {string} session The unique identifier of the RealtimeSession.
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getRealtimeSession: async (session, xHumanId, options = {}) => {
        assertParamExists("getRealtimeSession", "session", session);
        const localVarPath = `/api/v1/realtime/{session}`.replace(`{${"session"}}`, encodeURIComponent(String(session)));
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * Get all ContextMessages associated with the given RealtimeSession. 
       * @summary Get a RealtimeSession messages.
       * @param {string} session The unique identifier of the RealtimeSession.
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getRealtimeSessionMessages: async (session, xHumanId, options = {}) => {
        assertParamExists("getRealtimeSessionMessages", "session", session);
        const localVarPath = `/api/v1/realtime/{session}/messages`.replace(`{${"session"}}`, encodeURIComponent(String(session)));
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * Get the timeline of the RealtimeSession with the given identifier. 
       * @summary Get a RealtimeSession timeline.
       * @param {string} session The unique identifier of the RealtimeSession.
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getRealtimeSessionTimeline: async (session, xHumanId, options = {}) => {
        assertParamExists("getRealtimeSessionTimeline", "session", session);
        const localVarPath = `/api/v1/realtime/{session}/timeline`.replace(`{${"session"}}`, encodeURIComponent(String(session)));
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * List all Realtime Sessions. 
       * @summary List Realtime Sessions.
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      listRealtimeSessions: async (xHumanId, options = {}) => {
        const localVarPath = `/api/v1/realtime/list`;
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * Start a new RealtimeSession with the given configuration. 
       * @summary Start a new RealtimeSession.
       * @param {StartRealtimeSessionRequest} startRealtimeSessionRequest 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      startRealtimeSession: async (startRealtimeSessionRequest, xHumanId, options = {}) => {
        assertParamExists("startRealtimeSession", "startRealtimeSessionRequest", startRealtimeSessionRequest);
        const localVarPath = `/api/v1/realtime/start`;
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        localVarHeaderParameter["Content-Type"] = "application/json";
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        localVarRequestOptions.data = serializeDataIfNeeded(startRealtimeSessionRequest, localVarRequestOptions, configuration);
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * Update the RealtimeSession with the given identifier. 
       * @summary Update a RealtimeSession.
       * @param {string} session The unique identifier of the RealtimeSession.
       * @param {RealtimeSessionConfigUpdate} realtimeSessionConfigUpdate 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      updateRealtimeSession: async (session, realtimeSessionConfigUpdate, xHumanId, options = {}) => {
        assertParamExists("updateRealtimeSession", "session", session);
        assertParamExists("updateRealtimeSession", "realtimeSessionConfigUpdate", realtimeSessionConfigUpdate);
        const localVarPath = `/api/v1/realtime/{session}/update`.replace(`{${"session"}}`, encodeURIComponent(String(session)));
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        localVarHeaderParameter["Content-Type"] = "application/json";
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        localVarRequestOptions.data = serializeDataIfNeeded(realtimeSessionConfigUpdate, localVarRequestOptions, configuration);
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      }
    };
  };
  var RealtimeApiFp = function(configuration) {
    const localVarAxiosParamCreator = RealtimeApiAxiosParamCreator(configuration);
    return {
      /**
       * End the RealtimeSession with the given identifier. 
       * @summary End a RealtimeSession.
       * @param {string} session The unique identifier of the RealtimeSession.
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async endRealtimeSession(session, xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.endRealtimeSession(session, xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["RealtimeApi.endRealtimeSession"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * End the RealtimeSession with the given identifier. 
       * @summary Get a RealtimeSession.
       * @param {string} session The unique identifier of the RealtimeSession.
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async getRealtimeSession(session, xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.getRealtimeSession(session, xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["RealtimeApi.getRealtimeSession"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * Get all ContextMessages associated with the given RealtimeSession. 
       * @summary Get a RealtimeSession messages.
       * @param {string} session The unique identifier of the RealtimeSession.
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async getRealtimeSessionMessages(session, xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.getRealtimeSessionMessages(session, xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["RealtimeApi.getRealtimeSessionMessages"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * Get the timeline of the RealtimeSession with the given identifier. 
       * @summary Get a RealtimeSession timeline.
       * @param {string} session The unique identifier of the RealtimeSession.
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async getRealtimeSessionTimeline(session, xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.getRealtimeSessionTimeline(session, xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["RealtimeApi.getRealtimeSessionTimeline"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * List all Realtime Sessions. 
       * @summary List Realtime Sessions.
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async listRealtimeSessions(xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.listRealtimeSessions(xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["RealtimeApi.listRealtimeSessions"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * Start a new RealtimeSession with the given configuration. 
       * @summary Start a new RealtimeSession.
       * @param {StartRealtimeSessionRequest} startRealtimeSessionRequest 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async startRealtimeSession(startRealtimeSessionRequest, xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.startRealtimeSession(startRealtimeSessionRequest, xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["RealtimeApi.startRealtimeSession"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * Update the RealtimeSession with the given identifier. 
       * @summary Update a RealtimeSession.
       * @param {string} session The unique identifier of the RealtimeSession.
       * @param {RealtimeSessionConfigUpdate} realtimeSessionConfigUpdate 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async updateRealtimeSession(session, realtimeSessionConfigUpdate, xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.updateRealtimeSession(session, realtimeSessionConfigUpdate, xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["RealtimeApi.updateRealtimeSession"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      }
    };
  };
  var RealtimeApi = class extends BaseAPI {
    /**
     * End the RealtimeSession with the given identifier. 
     * @summary End a RealtimeSession.
     * @param {string} session The unique identifier of the RealtimeSession.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealtimeApi
     */
    endRealtimeSession(session, xHumanId, options) {
      return RealtimeApiFp(this.configuration).endRealtimeSession(session, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * End the RealtimeSession with the given identifier. 
     * @summary Get a RealtimeSession.
     * @param {string} session The unique identifier of the RealtimeSession.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealtimeApi
     */
    getRealtimeSession(session, xHumanId, options) {
      return RealtimeApiFp(this.configuration).getRealtimeSession(session, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all ContextMessages associated with the given RealtimeSession. 
     * @summary Get a RealtimeSession messages.
     * @param {string} session The unique identifier of the RealtimeSession.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealtimeApi
     */
    getRealtimeSessionMessages(session, xHumanId, options) {
      return RealtimeApiFp(this.configuration).getRealtimeSessionMessages(session, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the timeline of the RealtimeSession with the given identifier. 
     * @summary Get a RealtimeSession timeline.
     * @param {string} session The unique identifier of the RealtimeSession.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealtimeApi
     */
    getRealtimeSessionTimeline(session, xHumanId, options) {
      return RealtimeApiFp(this.configuration).getRealtimeSessionTimeline(session, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all Realtime Sessions. 
     * @summary List Realtime Sessions.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealtimeApi
     */
    listRealtimeSessions(xHumanId, options) {
      return RealtimeApiFp(this.configuration).listRealtimeSessions(xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Start a new RealtimeSession with the given configuration. 
     * @summary Start a new RealtimeSession.
     * @param {StartRealtimeSessionRequest} startRealtimeSessionRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealtimeApi
     */
    startRealtimeSession(startRealtimeSessionRequest, xHumanId, options) {
      return RealtimeApiFp(this.configuration).startRealtimeSession(startRealtimeSessionRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update the RealtimeSession with the given identifier. 
     * @summary Update a RealtimeSession.
     * @param {string} session The unique identifier of the RealtimeSession.
     * @param {RealtimeSessionConfigUpdate} realtimeSessionConfigUpdate 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealtimeApi
     */
    updateRealtimeSession(session, realtimeSessionConfigUpdate, xHumanId, options) {
      return RealtimeApiFp(this.configuration).updateRealtimeSession(session, realtimeSessionConfigUpdate, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
  };

  // src/generated/api/scenario-api.ts
  var ScenarioApiAxiosParamCreator = function(configuration) {
    return {
      /**
       * 
       * @summary Create a scenario
       * @param {CreateScenarioRequest} createScenarioRequest 
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      createScenario: async (createScenarioRequest, options = {}) => {
        assertParamExists("createScenario", "createScenarioRequest", createScenarioRequest);
        const localVarPath = `/api/v1/scenario`;
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        localVarHeaderParameter["Content-Type"] = "application/json";
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        localVarRequestOptions.data = serializeDataIfNeeded(createScenarioRequest, localVarRequestOptions, configuration);
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * 
       * @summary Delete a scenario
       * @param {string} scenarioId 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      deleteScenario: async (scenarioId, xHumanId, options = {}) => {
        assertParamExists("deleteScenario", "scenarioId", scenarioId);
        const localVarPath = `/api/v1/scenario/{scenario_id}`.replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * 
       * @summary Get a scenario
       * @param {string} scenarioId 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getScenario: async (scenarioId, xHumanId, options = {}) => {
        assertParamExists("getScenario", "scenarioId", scenarioId);
        const localVarPath = `/api/v1/scenario/{scenario_id}`.replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * 
       * @summary Get a list of scenarios
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      listScenarios: async (xHumanId, options = {}) => {
        const localVarPath = `/api/v1/scenario/list`;
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * 
       * @summary Update a scenario
       * @param {string} scenarioId 
       * @param {UpdateScenarioRequest} updateScenarioRequest 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      updateScenario: async (scenarioId, updateScenarioRequest, xHumanId, options = {}) => {
        assertParamExists("updateScenario", "scenarioId", scenarioId);
        assertParamExists("updateScenario", "updateScenarioRequest", updateScenarioRequest);
        const localVarPath = `/api/v1/scenario/{scenario_id}`.replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        localVarHeaderParameter["Content-Type"] = "application/json";
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        localVarRequestOptions.data = serializeDataIfNeeded(updateScenarioRequest, localVarRequestOptions, configuration);
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      }
    };
  };
  var ScenarioApiFp = function(configuration) {
    const localVarAxiosParamCreator = ScenarioApiAxiosParamCreator(configuration);
    return {
      /**
       * 
       * @summary Create a scenario
       * @param {CreateScenarioRequest} createScenarioRequest 
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async createScenario(createScenarioRequest, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.createScenario(createScenarioRequest, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["ScenarioApi.createScenario"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * 
       * @summary Delete a scenario
       * @param {string} scenarioId 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async deleteScenario(scenarioId, xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScenario(scenarioId, xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["ScenarioApi.deleteScenario"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * 
       * @summary Get a scenario
       * @param {string} scenarioId 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async getScenario(scenarioId, xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.getScenario(scenarioId, xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["ScenarioApi.getScenario"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * 
       * @summary Get a list of scenarios
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async listScenarios(xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.listScenarios(xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["ScenarioApi.listScenarios"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * 
       * @summary Update a scenario
       * @param {string} scenarioId 
       * @param {UpdateScenarioRequest} updateScenarioRequest 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async updateScenario(scenarioId, updateScenarioRequest, xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.updateScenario(scenarioId, updateScenarioRequest, xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["ScenarioApi.updateScenario"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      }
    };
  };
  var ScenarioApi = class extends BaseAPI {
    /**
     * 
     * @summary Create a scenario
     * @param {CreateScenarioRequest} createScenarioRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    createScenario(createScenarioRequest, options) {
      return ScenarioApiFp(this.configuration).createScenario(createScenarioRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Delete a scenario
     * @param {string} scenarioId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    deleteScenario(scenarioId, xHumanId, options) {
      return ScenarioApiFp(this.configuration).deleteScenario(scenarioId, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a scenario
     * @param {string} scenarioId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    getScenario(scenarioId, xHumanId, options) {
      return ScenarioApiFp(this.configuration).getScenario(scenarioId, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a list of scenarios
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    listScenarios(xHumanId, options) {
      return ScenarioApiFp(this.configuration).listScenarios(xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Update a scenario
     * @param {string} scenarioId 
     * @param {UpdateScenarioRequest} updateScenarioRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    updateScenario(scenarioId, updateScenarioRequest, xHumanId, options) {
      return ScenarioApiFp(this.configuration).updateScenario(scenarioId, updateScenarioRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
  };

  // src/generated/api/session-api.ts
  var SessionApiAxiosParamCreator = function(configuration) {
    return {
      /**
       * This endpoint is deprecated. Use Realtime Apis instead.
       * @summary Get a list of sessions
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {string} [human] 
       * @param {*} [options] Override http request option.
       * @deprecated
       * @throws {RequiredError}
       */
      apiV1SessionListGet: async (xHumanId, human, options = {}) => {
        const localVarPath = `/api/v1/session/list`;
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (human !== void 0) {
          localVarQueryParameter["human"] = human;
        }
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * 
       * @summary End a session
       * @param {string} sessionId 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      apiV1SessionSessionIdEndPost: async (sessionId, xHumanId, options = {}) => {
        assertParamExists("apiV1SessionSessionIdEndPost", "sessionId", sessionId);
        const localVarPath = `/api/v1/session/{session_id}/end`.replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * This endpoint is deprecated. Use Realtime Apis instead.
       * @summary Get a session by id
       * @param {string} sessionId 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @deprecated
       * @throws {RequiredError}
       */
      apiV1SessionSessionIdGet: async (sessionId, xHumanId, options = {}) => {
        assertParamExists("apiV1SessionSessionIdGet", "sessionId", sessionId);
        const localVarPath = `/api/v1/session/{session_id}`.replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * This endpoint is deprecated. Use Realtime Apis instead.
       * @summary Get session messages
       * @param {string} sessionId 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @deprecated
       * @throws {RequiredError}
       */
      apiV1SessionSessionIdMessagesGet: async (sessionId, xHumanId, options = {}) => {
        assertParamExists("apiV1SessionSessionIdMessagesGet", "sessionId", sessionId);
        const localVarPath = `/api/v1/session/{session_id}/messages`.replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * This endpoint is deprecated. Use Realtime Apis instead.
       * @summary Update a session by id
       * @param {string} sessionId 
       * @param {UpdateSessionRequest} updateSessionRequest 
       * @param {*} [options] Override http request option.
       * @deprecated
       * @throws {RequiredError}
       */
      apiV1SessionSessionIdPut: async (sessionId, updateSessionRequest, options = {}) => {
        assertParamExists("apiV1SessionSessionIdPut", "sessionId", sessionId);
        assertParamExists("apiV1SessionSessionIdPut", "updateSessionRequest", updateSessionRequest);
        const localVarPath = `/api/v1/session/{session_id}`.replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        localVarHeaderParameter["Content-Type"] = "application/json";
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        localVarRequestOptions.data = serializeDataIfNeeded(updateSessionRequest, localVarRequestOptions, configuration);
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * This endpoint is deprecated. Use Realtime Apis instead.
       * @summary Get a session timeline
       * @param {string} sessionId 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @deprecated
       * @throws {RequiredError}
       */
      apiV1SessionSessionIdTimelineGet: async (sessionId, xHumanId, options = {}) => {
        assertParamExists("apiV1SessionSessionIdTimelineGet", "sessionId", sessionId);
        const localVarPath = `/api/v1/session/{session_id}/timeline`.replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * This endpoint is deprecated. Use Realtime Apis instead.
       * @summary Create a new session
       * @param {SessionStartRequest} sessionStartRequest 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @deprecated
       * @throws {RequiredError}
       */
      apiV1SessionStartPost: async (sessionStartRequest, xHumanId, options = {}) => {
        assertParamExists("apiV1SessionStartPost", "sessionStartRequest", sessionStartRequest);
        const localVarPath = `/api/v1/session/start`;
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        localVarHeaderParameter["Content-Type"] = "application/json";
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        localVarRequestOptions.data = serializeDataIfNeeded(sessionStartRequest, localVarRequestOptions, configuration);
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      }
    };
  };
  var SessionApiFp = function(configuration) {
    const localVarAxiosParamCreator = SessionApiAxiosParamCreator(configuration);
    return {
      /**
       * This endpoint is deprecated. Use Realtime Apis instead.
       * @summary Get a list of sessions
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {string} [human] 
       * @param {*} [options] Override http request option.
       * @deprecated
       * @throws {RequiredError}
       */
      async apiV1SessionListGet(xHumanId, human, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionListGet(xHumanId, human, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["SessionApi.apiV1SessionListGet"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * 
       * @summary End a session
       * @param {string} sessionId 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async apiV1SessionSessionIdEndPost(sessionId, xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdEndPost(sessionId, xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["SessionApi.apiV1SessionSessionIdEndPost"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * This endpoint is deprecated. Use Realtime Apis instead.
       * @summary Get a session by id
       * @param {string} sessionId 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @deprecated
       * @throws {RequiredError}
       */
      async apiV1SessionSessionIdGet(sessionId, xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdGet(sessionId, xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["SessionApi.apiV1SessionSessionIdGet"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * This endpoint is deprecated. Use Realtime Apis instead.
       * @summary Get session messages
       * @param {string} sessionId 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @deprecated
       * @throws {RequiredError}
       */
      async apiV1SessionSessionIdMessagesGet(sessionId, xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdMessagesGet(sessionId, xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["SessionApi.apiV1SessionSessionIdMessagesGet"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * This endpoint is deprecated. Use Realtime Apis instead.
       * @summary Update a session by id
       * @param {string} sessionId 
       * @param {UpdateSessionRequest} updateSessionRequest 
       * @param {*} [options] Override http request option.
       * @deprecated
       * @throws {RequiredError}
       */
      async apiV1SessionSessionIdPut(sessionId, updateSessionRequest, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdPut(sessionId, updateSessionRequest, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["SessionApi.apiV1SessionSessionIdPut"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * This endpoint is deprecated. Use Realtime Apis instead.
       * @summary Get a session timeline
       * @param {string} sessionId 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @deprecated
       * @throws {RequiredError}
       */
      async apiV1SessionSessionIdTimelineGet(sessionId, xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdTimelineGet(sessionId, xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["SessionApi.apiV1SessionSessionIdTimelineGet"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * This endpoint is deprecated. Use Realtime Apis instead.
       * @summary Create a new session
       * @param {SessionStartRequest} sessionStartRequest 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @deprecated
       * @throws {RequiredError}
       */
      async apiV1SessionStartPost(sessionStartRequest, xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionStartPost(sessionStartRequest, xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["SessionApi.apiV1SessionStartPost"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      }
    };
  };
  var SessionApi = class extends BaseAPI {
    /**
     * This endpoint is deprecated. Use Realtime Apis instead.
     * @summary Get a list of sessions
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {string} [human] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    apiV1SessionListGet(xHumanId, human, options) {
      return SessionApiFp(this.configuration).apiV1SessionListGet(xHumanId, human, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary End a session
     * @param {string} sessionId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    apiV1SessionSessionIdEndPost(sessionId, xHumanId, options) {
      return SessionApiFp(this.configuration).apiV1SessionSessionIdEndPost(sessionId, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint is deprecated. Use Realtime Apis instead.
     * @summary Get a session by id
     * @param {string} sessionId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    apiV1SessionSessionIdGet(sessionId, xHumanId, options) {
      return SessionApiFp(this.configuration).apiV1SessionSessionIdGet(sessionId, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint is deprecated. Use Realtime Apis instead.
     * @summary Get session messages
     * @param {string} sessionId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    apiV1SessionSessionIdMessagesGet(sessionId, xHumanId, options) {
      return SessionApiFp(this.configuration).apiV1SessionSessionIdMessagesGet(sessionId, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint is deprecated. Use Realtime Apis instead.
     * @summary Update a session by id
     * @param {string} sessionId 
     * @param {UpdateSessionRequest} updateSessionRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    apiV1SessionSessionIdPut(sessionId, updateSessionRequest, options) {
      return SessionApiFp(this.configuration).apiV1SessionSessionIdPut(sessionId, updateSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint is deprecated. Use Realtime Apis instead.
     * @summary Get a session timeline
     * @param {string} sessionId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    apiV1SessionSessionIdTimelineGet(sessionId, xHumanId, options) {
      return SessionApiFp(this.configuration).apiV1SessionSessionIdTimelineGet(sessionId, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint is deprecated. Use Realtime Apis instead.
     * @summary Create a new session
     * @param {SessionStartRequest} sessionStartRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    apiV1SessionStartPost(sessionStartRequest, xHumanId, options) {
      return SessionApiFp(this.configuration).apiV1SessionStartPost(sessionStartRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
  };

  // src/generated/api/usage-api.ts
  var UsageApiAxiosParamCreator = function(configuration) {
    return {
      /**
       * Requests a token for a human
       * @summary Request new human token
       * @param {UsageTokenRequest} usageTokenRequest 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      createUsageToken: async (usageTokenRequest, xHumanId, options = {}) => {
        assertParamExists("createUsageToken", "usageTokenRequest", usageTokenRequest);
        const localVarPath = `/api/v1/usage/token`;
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        localVarHeaderParameter["Content-Type"] = "application/json";
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        localVarRequestOptions.data = serializeDataIfNeeded(usageTokenRequest, localVarRequestOptions, configuration);
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * Gets the usage limits of a token
       * @summary Get usage limits
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getUsageLimits: async (xHumanId, options = {}) => {
        const localVarPath = `/api/v1/usage/limits`;
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * Updates the usage limits of a human
       * @summary Update limits on a usage token
       * @param {UpdateUsageLimitsRequest} updateUsageLimitsRequest 
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      updateUsageToken: async (updateUsageLimitsRequest, options = {}) => {
        assertParamExists("updateUsageToken", "updateUsageLimitsRequest", updateUsageLimitsRequest);
        const localVarPath = `/api/v1/usage/token`;
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        localVarHeaderParameter["Content-Type"] = "application/json";
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        localVarRequestOptions.data = serializeDataIfNeeded(updateUsageLimitsRequest, localVarRequestOptions, configuration);
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      }
    };
  };
  var UsageApiFp = function(configuration) {
    const localVarAxiosParamCreator = UsageApiAxiosParamCreator(configuration);
    return {
      /**
       * Requests a token for a human
       * @summary Request new human token
       * @param {UsageTokenRequest} usageTokenRequest 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async createUsageToken(usageTokenRequest, xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.createUsageToken(usageTokenRequest, xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["UsageApi.createUsageToken"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * Gets the usage limits of a token
       * @summary Get usage limits
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async getUsageLimits(xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.getUsageLimits(xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["UsageApi.getUsageLimits"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * Updates the usage limits of a human
       * @summary Update limits on a usage token
       * @param {UpdateUsageLimitsRequest} updateUsageLimitsRequest 
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async updateUsageToken(updateUsageLimitsRequest, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.updateUsageToken(updateUsageLimitsRequest, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["UsageApi.updateUsageToken"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      }
    };
  };
  var UsageApi = class extends BaseAPI {
    /**
     * Requests a token for a human
     * @summary Request new human token
     * @param {UsageTokenRequest} usageTokenRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    createUsageToken(usageTokenRequest, xHumanId, options) {
      return UsageApiFp(this.configuration).createUsageToken(usageTokenRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets the usage limits of a token
     * @summary Get usage limits
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    getUsageLimits(xHumanId, options) {
      return UsageApiFp(this.configuration).getUsageLimits(xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the usage limits of a human
     * @summary Update limits on a usage token
     * @param {UpdateUsageLimitsRequest} updateUsageLimitsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    updateUsageToken(updateUsageLimitsRequest, options) {
      return UsageApiFp(this.configuration).updateUsageToken(updateUsageLimitsRequest, options).then((request) => request(this.axios, this.basePath));
    }
  };

  // src/generated/api/voice-api.ts
  var VoiceApiAxiosParamCreator = function(configuration) {
    return {
      /**
       * Creates a new cloned voice based on the input audio file
       * @summary Clone a voice
       * @param {string} name Name of the new voice
       * @param {string} language Language of the voice (e.g., \\\&#39;en\\\&#39;, \\\&#39;es\\\&#39;, \\\&#39;fr\\\&#39;)
       * @param {File} file Audio file for voice cloning (MP3 format)
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      cloneVoice: async (name, language, file, xHumanId, options = {}) => {
        assertParamExists("cloneVoice", "name", name);
        assertParamExists("cloneVoice", "language", language);
        assertParamExists("cloneVoice", "file", file);
        const localVarPath = `/api/v1/voice/clone`;
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        const localVarFormParams = new (configuration && configuration.formDataCtor || FormData)();
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        if (name !== void 0) {
          localVarFormParams.append("name", name);
        }
        if (language !== void 0) {
          localVarFormParams.append("language", language);
        }
        if (file !== void 0) {
          localVarFormParams.append("file", file);
        }
        localVarHeaderParameter["Content-Type"] = "multipart/form-data";
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        localVarRequestOptions.data = localVarFormParams;
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * 
       * @summary Delete a voice
       * @param {string} voiceId 
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      deleteVoice: async (voiceId, options = {}) => {
        assertParamExists("deleteVoice", "voiceId", voiceId);
        const localVarPath = `/api/v1/voice/{voice_id}`.replace(`{${"voice_id"}}`, encodeURIComponent(String(voiceId)));
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * Generates speech from input text and specified voice
       * @summary Generate voice
       * @param {GenerateVoiceRequest} generateVoiceRequest 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      generateVoice: async (generateVoiceRequest, xHumanId, options = {}) => {
        assertParamExists("generateVoice", "generateVoiceRequest", generateVoiceRequest);
        const localVarPath = `/api/v1/voice/generate`;
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        localVarHeaderParameter["Content-Type"] = "application/json";
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        localVarRequestOptions.data = serializeDataIfNeeded(generateVoiceRequest, localVarRequestOptions, configuration);
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * 
       * @summary Get a voice
       * @param {string} voiceId 
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getVoice: async (voiceId, options = {}) => {
        assertParamExists("getVoice", "voiceId", voiceId);
        const localVarPath = `/api/v1/voice/{voice_id}`.replace(`{${"voice_id"}}`, encodeURIComponent(String(voiceId)));
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * 
       * @summary Get a list of voices
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      listVoices: async (xHumanId, options = {}) => {
        const localVarPath = `/api/v1/voice/list`;
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        if (xHumanId != null) {
          localVarHeaderParameter["x-human-id"] = String(xHumanId);
        }
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      },
      /**
       * Updates a voice based on the input request data
       * @summary Update a voice
       * @param {string} voiceId 
       * @param {UpdateVoiceRequest} updateVoiceRequest 
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      updateVoice: async (voiceId, updateVoiceRequest, options = {}) => {
        assertParamExists("updateVoice", "voiceId", voiceId);
        assertParamExists("updateVoice", "updateVoiceRequest", updateVoiceRequest);
        const localVarPath = `/api/v1/voice/{voice_id}`.replace(`{${"voice_id"}}`, encodeURIComponent(String(voiceId)));
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }
        const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
        await setBearerAuthToObject(localVarHeaderParameter, configuration);
        localVarHeaderParameter["Content-Type"] = "application/json";
        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
        localVarRequestOptions.data = serializeDataIfNeeded(updateVoiceRequest, localVarRequestOptions, configuration);
        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions
        };
      }
    };
  };
  var VoiceApiFp = function(configuration) {
    const localVarAxiosParamCreator = VoiceApiAxiosParamCreator(configuration);
    return {
      /**
       * Creates a new cloned voice based on the input audio file
       * @summary Clone a voice
       * @param {string} name Name of the new voice
       * @param {string} language Language of the voice (e.g., \\\&#39;en\\\&#39;, \\\&#39;es\\\&#39;, \\\&#39;fr\\\&#39;)
       * @param {File} file Audio file for voice cloning (MP3 format)
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async cloneVoice(name, language, file, xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.cloneVoice(name, language, file, xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["VoiceApi.cloneVoice"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * 
       * @summary Delete a voice
       * @param {string} voiceId 
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async deleteVoice(voiceId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVoice(voiceId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["VoiceApi.deleteVoice"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * Generates speech from input text and specified voice
       * @summary Generate voice
       * @param {GenerateVoiceRequest} generateVoiceRequest 
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async generateVoice(generateVoiceRequest, xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.generateVoice(generateVoiceRequest, xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["VoiceApi.generateVoice"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * 
       * @summary Get a voice
       * @param {string} voiceId 
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async getVoice(voiceId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.getVoice(voiceId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["VoiceApi.getVoice"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * 
       * @summary Get a list of voices
       * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async listVoices(xHumanId, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.listVoices(xHumanId, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["VoiceApi.listVoices"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      },
      /**
       * Updates a voice based on the input request data
       * @summary Update a voice
       * @param {string} voiceId 
       * @param {UpdateVoiceRequest} updateVoiceRequest 
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      async updateVoice(voiceId, updateVoiceRequest, options) {
        const localVarAxiosArgs = await localVarAxiosParamCreator.updateVoice(voiceId, updateVoiceRequest, options);
        const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
        const localVarOperationServerBasePath = operationServerMap["VoiceApi.updateVoice"]?.[localVarOperationServerIndex]?.url;
        return (axios2, basePath) => createRequestFunction(localVarAxiosArgs, axios_default, BASE_PATH, configuration)(axios2, localVarOperationServerBasePath || basePath);
      }
    };
  };
  var VoiceApi = class extends BaseAPI {
    /**
     * Creates a new cloned voice based on the input audio file
     * @summary Clone a voice
     * @param {string} name Name of the new voice
     * @param {string} language Language of the voice (e.g., \\\&#39;en\\\&#39;, \\\&#39;es\\\&#39;, \\\&#39;fr\\\&#39;)
     * @param {File} file Audio file for voice cloning (MP3 format)
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    cloneVoice(name, language, file, xHumanId, options) {
      return VoiceApiFp(this.configuration).cloneVoice(name, language, file, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Delete a voice
     * @param {string} voiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    deleteVoice(voiceId, options) {
      return VoiceApiFp(this.configuration).deleteVoice(voiceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Generates speech from input text and specified voice
     * @summary Generate voice
     * @param {GenerateVoiceRequest} generateVoiceRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    generateVoice(generateVoiceRequest, xHumanId, options) {
      return VoiceApiFp(this.configuration).generateVoice(generateVoiceRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a voice
     * @param {string} voiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    getVoice(voiceId, options) {
      return VoiceApiFp(this.configuration).getVoice(voiceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get a list of voices
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    listVoices(xHumanId, options) {
      return VoiceApiFp(this.configuration).listVoices(xHumanId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates a voice based on the input request data
     * @summary Update a voice
     * @param {string} voiceId 
     * @param {UpdateVoiceRequest} updateVoiceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoiceApi
     */
    updateVoice(voiceId, updateVoiceRequest, options) {
      return VoiceApiFp(this.configuration).updateVoice(voiceId, updateVoiceRequest, options).then((request) => request(this.axios, this.basePath));
    }
  };

  // src/generated/configuration.ts
  var Configuration = class {
    constructor(param = {}) {
      this.apiKey = param.apiKey;
      this.username = param.username;
      this.password = param.password;
      this.accessToken = param.accessToken;
      this.basePath = param.basePath;
      this.serverIndex = param.serverIndex;
      this.baseOptions = param.baseOptions;
      this.formDataCtor = param.formDataCtor;
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
      const jsonMime = new RegExp("^(application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(;.*)?$", "i");
      return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === "application/json-patch+json");
    }
  };

  // src/generated/model/chat-completion-request-message.ts
  var ChatCompletionRequestMessageRoleEnum = {
    User: "user",
    Assistant: "assistant",
    System: "system"
  };

  // src/generated/model/chat-completion-request-message-content-part-audio.ts
  var ChatCompletionRequestMessageContentPartAudioTypeEnum = {
    InputAudio: "input_audio"
  };

  // src/generated/model/chat-completion-request-message-content-part-audio-input-audio.ts
  var ChatCompletionRequestMessageContentPartAudioInputAudioFormatEnum = {
    Wav: "wav",
    Mp3: "mp3",
    Ogg: "ogg"
  };

  // src/generated/model/chat-completion-request-message-content-part-text.ts
  var ChatCompletionRequestMessageContentPartTextTypeEnum = {
    Text: "text"
  };

  // src/generated/model/chat-completion-response-gabber-message-data-inner.ts
  var ChatCompletionResponseGabberMessageDataInnerTypeEnum = {
    AudioTranscript: "audio_transcript"
  };

  // src/generated/model/chat-completion-response-message.ts
  var ChatCompletionResponseMessageRoleEnum = {
    Assistant: "assistant"
  };

  // src/generated/model/chat-completion-stream-response.ts
  var ChatCompletionStreamResponseObjectEnum = {
    ChatCompletionChunk: "chat.completion.chunk"
  };

  // src/generated/model/chat-completion-stream-response-choices-inner.ts
  var ChatCompletionStreamResponseChoicesInnerFinishReasonEnum = {
    Stop: "stop",
    Length: "length",
    ToolCalls: "tool_calls",
    ContentFilter: "content_filter",
    FunctionCall: "function_call"
  };

  // src/generated/model/chat-completion-stream-response-delta.ts
  var ChatCompletionStreamResponseDeltaRoleEnum = {
    System: "system",
    User: "user",
    Assistant: "assistant"
  };

  // src/generated/model/chat-completion-stream-response-gabber-message-data-inner.ts
  var ChatCompletionStreamResponseGabberMessageDataInnerTypeEnum = {
    AudioTranscript: "audio_transcript"
  };

  // src/generated/model/context-create-request-messages-inner.ts
  var ContextCreateRequestMessagesInnerRoleEnum = {
    Assistant: "assistant",
    System: "system",
    User: "user"
  };

  // src/generated/model/context-message-create-params.ts
  var ContextMessageCreateParamsRoleEnum = {
    Assistant: "assistant",
    System: "system",
    User: "user"
  };

  // src/generated/model/create-persona-request.ts
  var CreatePersonaRequestGenderEnum = {
    Male: "male",
    Female: "female"
  };

  // src/generated/model/history-message.ts
  var HistoryMessageRoleEnum = {
    Assistant: "assistant",
    System: "system",
    User: "user"
  };

  // src/generated/model/persona.ts
  var PersonaGenderEnum = {
    Male: "male",
    Female: "female"
  };

  // src/generated/model/realtime-session.ts
  var RealtimeSessionStateEnum = {
    Ended: "ended",
    InProgress: "in_progress",
    NotStarted: "not_started"
  };

  // src/generated/model/realtime-session-timeline-item.ts
  var RealtimeSessionTimelineItemTypeEnum = {
    Silence: "silence",
    Agent: "agent",
    User: "user"
  };

  // src/generated/model/sdkagent-state.ts
  var SDKAgentState = {
    Warmup: "warmup",
    Listening: "listening",
    Thinking: "thinking",
    Speaking: "speaking",
    TimeLimitExceeded: "time_limit_exceeded",
    UsageLimitExceeded: "usage_limit_exceeded"
  };

  // src/generated/model/sdkconnection-state.ts
  var SDKConnectionState = {
    NotConnected: "not_connected",
    Connecting: "connecting",
    WaitingForAgent: "waiting_for_agent",
    Connected: "connected"
  };

  // src/generated/model/session.ts
  var SessionStateEnum = {
    Ended: "ended",
    InProgress: "in_progress",
    NotStarted: "not_started"
  };

  // src/generated/model/session-timeline-item.ts
  var SessionTimelineItemTypeEnum = {
    Silence: "silence",
    Agent: "agent",
    User: "user"
  };

  // src/generated/model/update-persona-request.ts
  var UpdatePersonaRequestGenderEnum = {
    Male: "male",
    Female: "female"
  };

  // src/generated/model/usage-type.ts
  var UsageType = {
    ConversationalSeconds: "conversational_seconds",
    VoiceSynthesisSeconds: "voice_synthesis_seconds",
    TokenCnt: "token_cnt"
  };

  // src/generated/model/webhook-message-usage-tracked.ts
  var WebhookMessageUsageTrackedTypeEnum = {
    UsageTracked: "usage.tracked"
  };

  // src/api.ts
  var Api = class {
    constructor(token) {
      const config = new Configuration({ accessToken: token });
      this.realtime = new RealtimeApi(config);
      this.persona = new PersonaApi(config);
      this.session = new SessionApi(config);
      this.voice = new VoiceApi(config);
      this.scenario = new ScenarioApi(config);
      this.llm = new LLMApi(config);
      this.usage = new UsageApi(config);
    }
  };

  // src/session.ts
  var RealtimeSessionEngine = class {
    constructor({
      onConnectionStateChanged,
      onMessagesChanged,
      onMicrophoneChanged,
      onAgentVolumeChanged,
      onUserVolumeChanged,
      onAgentStateChanged,
      onRemainingSecondsChanged,
      onAgentError,
      onCanPlayAudioChanged
    }) {
      this.agentParticipant = null;
      this.agentTrack = null;
      this._microphoneEnabledState = false;
      this.transcriptions = [];
      this._agentState = "warmup";
      this._remainingSeconds = null;
      this.id = null;
      this.livekitRoom = new Room();
      this.livekitRoom.on("connected", this.onRoomConnected.bind(this));
      this.livekitRoom.on("disconnected", this.onRoomDisconnected.bind(this));
      this.livekitRoom.on("trackSubscribed", this.onTrackSubscribed.bind(this));
      this.livekitRoom.on(
        "trackUnsubscribed",
        this.onTrackUnsubscribed.bind(this)
      );
      this.livekitRoom.on("dataReceived", this.onDataReceived.bind(this));
      this.livekitRoom.on(
        "participantMetadataChanged",
        this.onParticipantMetadataChanged.bind(this)
      );
      this.livekitRoom.on(
        "localTrackPublished",
        this.onLocalTrackPublished.bind(this)
      );
      this.livekitRoom.on(
        "localTrackUnpublished",
        this.onLocalTrackUnpublished.bind(this)
      );
      this.livekitRoom.on("trackMuted", this.onTrackMuted.bind(this));
      this.livekitRoom.on("trackUnmuted", this.onTrackUnmuted.bind(this));
      this.livekitRoom.on(
        "audioPlaybackChanged",
        this.onAudioPlaybackChangaed.bind(this)
      );
      this.divElement = document.createElement("div");
      document.body.appendChild(this.divElement);
      this.onConnectionStateChanged = onConnectionStateChanged;
      this.onMessagesChanged = onMessagesChanged;
      this.onMicrophoneChanged = onMicrophoneChanged;
      this.onAgentVolumeChanged = onAgentVolumeChanged;
      this.onUserVolumeChanged = onUserVolumeChanged;
      this.onAgentStateChanged = onAgentStateChanged;
      this.onRemainingSecondsChanged = onRemainingSecondsChanged;
      this.onAgentError = onAgentError;
      this.onCanPlayAudioChanged = onCanPlayAudioChanged;
      this.agentVolumeVisualizer = new TrackVolumeVisualizer({
        onTick: this.onAgentVolumeChanged.bind(this),
        bands: 10
      });
      this.userVolumeVisualizer = new TrackVolumeVisualizer({
        onTick: this.onUserVolumeChanged.bind(this),
        bands: 10
      });
    }
    async connect(opts) {
      let connectionDetails = void 0;
      if ("connection_details" in opts) {
        connectionDetails = opts.connection_details;
      } else if ("token" in opts && "config" in opts) {
        const api = new Api(opts.token);
        const res = await api.realtime.startRealtimeSession(opts);
        connectionDetails = {
          url: res.data.connection_details.url,
          token: res.data.connection_details.token
        };
      }
      if (!connectionDetails) {
        throw new Error("No connection details provided");
      }
      await this.livekitRoom.connect(
        connectionDetails.url,
        connectionDetails.token,
        {
          autoSubscribe: true
        }
      );
      this.onCanPlayAudioChanged(this.livekitRoom.canPlaybackAudio);
    }
    async disconnect() {
      await this.livekitRoom.disconnect();
    }
    async startAudio() {
      try {
        await this.livekitRoom.startAudio();
      } catch (e) {
        console.error("Error starting audio");
      }
    }
    async setMicrophoneEnabled(enabled) {
      await this.livekitRoom.localParticipant.setMicrophoneEnabled(enabled);
    }
    async sendChatMessage({ text }) {
      const te = new TextEncoder();
      const encoded = te.encode(JSON.stringify({ text }));
      await this.livekitRoom.localParticipant.publishData(encoded, {
        topic: "chat_input"
      });
    }
    set agentState(value) {
      if (value == this._agentState) {
        return;
      }
      this._agentState = value;
      this.onAgentStateChanged(value);
    }
    set remainingSeconds(value) {
      if (value === this._remainingSeconds) {
        return;
      }
      this._remainingSeconds = value;
      this.onRemainingSecondsChanged(value);
    }
    destroy() {
      document.body.removeChild(this.divElement);
      try {
        this.livekitRoom.removeAllListeners();
        this.livekitRoom.disconnect(true);
      } catch (e) {
        console.error("Error destroying session", e);
      }
    }
    set microphoneEnabledState(value) {
      if (this._microphoneEnabledState !== value) {
        this._microphoneEnabledState = value;
        this.onMicrophoneChanged(value);
      }
    }
    resolveMicrophoneState() {
      if (!this.livekitRoom.localParticipant) {
        this.microphoneEnabledState = false;
      }
      this.microphoneEnabledState = this.livekitRoom.localParticipant.isMicrophoneEnabled;
    }
    onTrackUnmuted(publication, participant) {
      console.log("Local track unmuted", publication, participant);
      if (!participant.isLocal) {
        return;
      }
      if (publication.kind === Track.Kind.Audio) {
        this.resolveMicrophoneState();
      }
    }
    onTrackMuted(publication, participant) {
      console.log("Local track muted", publication, participant);
      if (!participant.isLocal) {
        return;
      }
      if (publication.kind === Track.Kind.Audio) {
        this.resolveMicrophoneState();
      }
    }
    onLocalTrackPublished(publication, participant) {
      console.log("Local track published", publication, participant);
      if (publication.kind === Track.Kind.Audio) {
        this.userVolumeVisualizer.setTrack(
          publication.audioTrack
        );
        this.resolveMicrophoneState();
      }
    }
    onLocalTrackUnpublished(publication, participant) {
      console.log("Local track unpublished", publication, participant);
      if (publication.kind === Track.Kind.Audio) {
        this.resolveMicrophoneState();
      }
    }
    onAudioPlaybackChangaed(_) {
      this.onCanPlayAudioChanged(this.livekitRoom.canPlaybackAudio);
    }
    onRoomConnected() {
      console.log("Room connected");
      this.resolveMicrophoneState();
      const metadataString = this.livekitRoom.metadata || "{}";
      this.id = JSON.parse(metadataString)["session"] || null;
      this.onConnectionStateChanged("waiting_for_agent");
    }
    onRoomDisconnected() {
      console.log("Room disconnected");
      this.id = null;
      this.resolveMicrophoneState();
      this.onConnectionStateChanged("not_connected");
    }
    onTrackSubscribed(track, pub, participant) {
      console.log("Track subscribed", track, pub, participant);
      if (track.kind !== "audio") {
        return;
      }
      if (this.agentParticipant) {
        console.error("Already subscribed to an agent");
        return;
      }
      this.divElement.appendChild(track.attach());
      this.agentParticipant = participant;
      this.agentTrack = track;
      this.agentVolumeVisualizer.setTrack(track);
      this.onConnectionStateChanged("connected");
    }
    onTrackUnsubscribed(track, pub, participant) {
      console.log("Track unsubscribed", track, pub, participant);
      if (track.kind !== "audio") {
        return;
      }
      track.attachedElements.forEach((el) => {
        el.remove();
      });
      if (track !== this.agentTrack) {
        console.error("Unsubscribed from unknown track");
        return;
      }
      this.agentParticipant = null;
      this.agentTrack = null;
      if (this.livekitRoom.state === "connected") {
        this.onConnectionStateChanged("waiting_for_agent");
      }
    }
    onDataReceived(data, participant, _, topic) {
      if (participant !== this.agentParticipant) {
        return;
      }
      const decoded = new TextDecoder().decode(data);
      console.log("Data received", decoded, participant, topic);
      if (topic === "message") {
        const message = JSON.parse(decoded);
        for (let i = 0; i < this.transcriptions.length; i++) {
          if (this.transcriptions[i].id === message.id && this.transcriptions[i].agent == message.agent) {
            this.transcriptions[i] = message;
            this.onMessagesChanged(this.transcriptions);
            return;
          }
        }
        this.transcriptions.push(message);
        this.onMessagesChanged(this.transcriptions);
      } else if (topic === "error") {
        const payload = JSON.parse(decoded);
        this.onAgentError(payload.message);
      }
    }
    onParticipantMetadataChanged(_, participant) {
      if (!participant.metadata || !participant.isAgent) {
        return;
      }
      try {
        const md = JSON.parse(participant.metadata);
        if (md.remaining_seconds) {
          this.remainingSeconds = md.remaining_seconds;
        }
        const { agent_state } = md;
        if (agent_state != "speaking" && agent_state != "listening" && agent_state != "thinking" && agent_state != "warmup" && agent_state != "time_limit_exceeded") {
          console.error("Unrecognized agent_state", agent_state);
          return;
        }
        this.agentState = agent_state;
      } catch (e) {
        console.error("Error on participant metadata cb", e);
      }
    }
  };
  return __toCommonJS(src_exports);
})();
/*! Bundled license information:

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
//# sourceMappingURL=index.global.js.map
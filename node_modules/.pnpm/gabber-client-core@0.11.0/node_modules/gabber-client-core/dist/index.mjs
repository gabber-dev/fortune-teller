// src/session.ts
import {
  Room,
  Track
} from "livekit-client";

// src/TrackVolumeVisualizer.ts
import {
  createAudioAnalyser
} from "livekit-client";
var TrackVolumeVisualizer = class {
  constructor({ bands, onTick }) {
    this.cleanup = null;
    this.bands = bands;
    this.callback = onTick;
  }
  setTrack(track) {
    if (this.interval) {
      clearInterval(this.interval);
    }
    if (this.cleanup) {
      this.cleanup();
    }
    const { analyser, cleanup, calculateVolume } = createAudioAnalyser(track, {
      fftSize: 256,
      smoothingTimeConstant: 0.7
    });
    this.cleanup = cleanup;
    const dataArray = new Float32Array(this.bands);
    this.interval = setInterval(() => {
      analyser.getFloatFrequencyData(dataArray);
      const result = [];
      for (let i = 0; i < dataArray.length; i++) {
        result.push(Math.max(0, dataArray[i] + 140) / 140);
      }
      this.callback(result, calculateVolume());
    }, 1e3 / 100);
  }
};

// src/generated/api/credit-api.ts
import globalAxios2 from "axios";

// src/generated/base.ts
import globalAxios from "axios";
var BASE_PATH = "https://app.gabber.dev".replace(/\/+$/, "");
var BaseAPI = class {
  constructor(configuration, basePath = BASE_PATH, axios = globalAxios) {
    this.basePath = basePath;
    this.axios = axios;
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath ?? basePath;
    }
  }
};
var RequiredError = class extends Error {
  constructor(field, msg) {
    super(msg);
    this.field = field;
    this.name = "RequiredError";
  }
};
var operationServerMap = {};

// src/generated/common.ts
var DUMMY_BASE_URL = "https://example.com";
var assertParamExists = function(functionName, paramName, paramValue) {
  if (paramValue === null || paramValue === void 0) {
    throw new RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
  }
};
var setApiKeyToObject = async function(object, keyParamName, configuration) {
  if (configuration && configuration.apiKey) {
    const localVarApiKeyValue = typeof configuration.apiKey === "function" ? await configuration.apiKey(keyParamName) : await configuration.apiKey;
    object[keyParamName] = localVarApiKeyValue;
  }
};
var setBearerAuthToObject = async function(object, configuration) {
  if (configuration && configuration.accessToken) {
    const accessToken = typeof configuration.accessToken === "function" ? await configuration.accessToken() : await configuration.accessToken;
    object["Authorization"] = "Bearer " + accessToken;
  }
};
function setFlattenedQueryParams(urlSearchParams, parameter, key = "") {
  if (parameter == null) return;
  if (typeof parameter === "object") {
    if (Array.isArray(parameter)) {
      parameter.forEach((item) => setFlattenedQueryParams(urlSearchParams, item, key));
    } else {
      Object.keys(parameter).forEach(
        (currentKey) => setFlattenedQueryParams(urlSearchParams, parameter[currentKey], `${key}${key !== "" ? "." : ""}${currentKey}`)
      );
    }
  } else {
    if (urlSearchParams.has(key)) {
      urlSearchParams.append(key, parameter);
    } else {
      urlSearchParams.set(key, parameter);
    }
  }
}
var setSearchParams = function(url, ...objects) {
  const searchParams = new URLSearchParams(url.search);
  setFlattenedQueryParams(searchParams, objects);
  url.search = searchParams.toString();
};
var serializeDataIfNeeded = function(value, requestOptions, configuration) {
  const nonString = typeof value !== "string";
  const needsSerialization = nonString && configuration && configuration.isJsonMime ? configuration.isJsonMime(requestOptions.headers["Content-Type"]) : nonString;
  return needsSerialization ? JSON.stringify(value !== void 0 ? value : {}) : value || "";
};
var toPathString = function(url) {
  return url.pathname + url.search + url.hash;
};
var createRequestFunction = function(axiosArgs, globalAxios11, BASE_PATH2, configuration) {
  return (axios = globalAxios11, basePath = BASE_PATH2) => {
    const axiosRequestArgs = { ...axiosArgs.options, url: (axios.defaults.baseURL ? "" : configuration?.basePath ?? basePath) + axiosArgs.url };
    return axios.request(axiosRequestArgs);
  };
};

// src/generated/api/inference-api.ts
import globalAxios3 from "axios";

// src/generated/api/llmapi.ts
import globalAxios4 from "axios";
var LLMApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Create a new Context with the given configuration. 
     * @summary Create a new Context.
     * @param {ContextCreateRequest} contextCreateRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContext: async (contextCreateRequest, xHumanId, options = {}) => {
      assertParamExists("createContext", "contextCreateRequest", contextCreateRequest);
      const localVarPath = `/api/v1/llm/context`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(contextCreateRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Create a new ContextMessage with the given configuration. 
     * @summary Create a new ContextMessage.
     * @param {string} context The unique identifier of the Context.
     * @param {ContextMessageCreateParams} contextMessageCreateParams 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContextMessage: async (context, contextMessageCreateParams, xHumanId, options = {}) => {
      assertParamExists("createContextMessage", "context", context);
      assertParamExists("createContextMessage", "contextMessageCreateParams", contextMessageCreateParams);
      const localVarPath = `/api/v1/llm/context/{context}/message`.replace(`{${"context"}}`, encodeURIComponent(String(context)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(contextMessageCreateParams, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Retrieve the Context with the given identifier. 
     * @summary Retrieve a Context.
     * @param {string} context The unique identifier of the Context.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContext: async (context, xHumanId, options = {}) => {
      assertParamExists("getContext", "context", context);
      const localVarPath = `/api/v1/llm/context/{context}`.replace(`{${"context"}}`, encodeURIComponent(String(context)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Retrieve the ContextMessage with the given identifier. 
     * @summary Retrieve a ContextMessage.
     * @param {string} context The unique identifier of the Context.
     * @param {string} message The unique identifier of the ContextMessage.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContextMessage: async (context, message, xHumanId, options = {}) => {
      assertParamExists("getContextMessage", "context", context);
      assertParamExists("getContextMessage", "message", message);
      const localVarPath = `/api/v1/llm/context/{context}/message/{message}`.replace(`{${"context"}}`, encodeURIComponent(String(context))).replace(`{${"message"}}`, encodeURIComponent(String(message)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Get a list of llms
     * @param {string} llm 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLLM: async (llm, xHumanId, options = {}) => {
      assertParamExists("getLLM", "llm", llm);
      const localVarPath = `/api/v1/llm/{llm}`.replace(`{${"llm"}}`, encodeURIComponent(String(llm)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * List all ContextMessages associated with the given Context. 
     * @summary List ContextMessages.
     * @param {string} context The unique identifier of the Context.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listContextMessages: async (context, xHumanId, options = {}) => {
      assertParamExists("listContextMessages", "context", context);
      const localVarPath = `/api/v1/llm/context/{context}/message/list`.replace(`{${"context"}}`, encodeURIComponent(String(context)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Get a list of llms
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLLMs: async (xHumanId, options = {}) => {
      const localVarPath = `/api/v1/llm/list`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var LLMApiFp = function(configuration) {
  const localVarAxiosParamCreator = LLMApiAxiosParamCreator(configuration);
  return {
    /**
     * Create a new Context with the given configuration. 
     * @summary Create a new Context.
     * @param {ContextCreateRequest} contextCreateRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createContext(contextCreateRequest, xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createContext(contextCreateRequest, xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["LLMApi.createContext"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios4, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Create a new ContextMessage with the given configuration. 
     * @summary Create a new ContextMessage.
     * @param {string} context The unique identifier of the Context.
     * @param {ContextMessageCreateParams} contextMessageCreateParams 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createContextMessage(context, contextMessageCreateParams, xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createContextMessage(context, contextMessageCreateParams, xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["LLMApi.createContextMessage"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios4, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve the Context with the given identifier. 
     * @summary Retrieve a Context.
     * @param {string} context The unique identifier of the Context.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getContext(context, xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getContext(context, xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["LLMApi.getContext"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios4, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Retrieve the ContextMessage with the given identifier. 
     * @summary Retrieve a ContextMessage.
     * @param {string} context The unique identifier of the Context.
     * @param {string} message The unique identifier of the ContextMessage.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getContextMessage(context, message, xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getContextMessage(context, message, xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["LLMApi.getContextMessage"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios4, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 
     * @summary Get a list of llms
     * @param {string} llm 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLLM(llm, xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLLM(llm, xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["LLMApi.getLLM"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios4, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List all ContextMessages associated with the given Context. 
     * @summary List ContextMessages.
     * @param {string} context The unique identifier of the Context.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listContextMessages(context, xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listContextMessages(context, xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["LLMApi.listContextMessages"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios4, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 
     * @summary Get a list of llms
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listLLMs(xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listLLMs(xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["LLMApi.listLLMs"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios4, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    }
  };
};
var LLMApi = class extends BaseAPI {
  /**
   * Create a new Context with the given configuration. 
   * @summary Create a new Context.
   * @param {ContextCreateRequest} contextCreateRequest 
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LLMApi
   */
  createContext(contextCreateRequest, xHumanId, options) {
    return LLMApiFp(this.configuration).createContext(contextCreateRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Create a new ContextMessage with the given configuration. 
   * @summary Create a new ContextMessage.
   * @param {string} context The unique identifier of the Context.
   * @param {ContextMessageCreateParams} contextMessageCreateParams 
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LLMApi
   */
  createContextMessage(context, contextMessageCreateParams, xHumanId, options) {
    return LLMApiFp(this.configuration).createContextMessage(context, contextMessageCreateParams, xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieve the Context with the given identifier. 
   * @summary Retrieve a Context.
   * @param {string} context The unique identifier of the Context.
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LLMApi
   */
  getContext(context, xHumanId, options) {
    return LLMApiFp(this.configuration).getContext(context, xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieve the ContextMessage with the given identifier. 
   * @summary Retrieve a ContextMessage.
   * @param {string} context The unique identifier of the Context.
   * @param {string} message The unique identifier of the ContextMessage.
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LLMApi
   */
  getContextMessage(context, message, xHumanId, options) {
    return LLMApiFp(this.configuration).getContextMessage(context, message, xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Get a list of llms
   * @param {string} llm 
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LLMApi
   */
  getLLM(llm, xHumanId, options) {
    return LLMApiFp(this.configuration).getLLM(llm, xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * List all ContextMessages associated with the given Context. 
   * @summary List ContextMessages.
   * @param {string} context The unique identifier of the Context.
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LLMApi
   */
  listContextMessages(context, xHumanId, options) {
    return LLMApiFp(this.configuration).listContextMessages(context, xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Get a list of llms
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LLMApi
   */
  listLLMs(xHumanId, options) {
    return LLMApiFp(this.configuration).listLLMs(xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
};

// src/generated/api/persona-api.ts
import globalAxios5 from "axios";
var PersonaApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * 
     * @summary Get a persona
     * @param {CreatePersonaRequest} createPersonaRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPersona: async (createPersonaRequest, xHumanId, options = {}) => {
      assertParamExists("createPersona", "createPersonaRequest", createPersonaRequest);
      const localVarPath = `/api/v1/persona`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createPersonaRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Delete a persona
     * @param {string} personaId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePersona: async (personaId, xHumanId, options = {}) => {
      assertParamExists("deletePersona", "personaId", personaId);
      const localVarPath = `/api/v1/persona/{persona_id}`.replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Get a persona
     * @param {string} personaId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPersona: async (personaId, xHumanId, options = {}) => {
      assertParamExists("getPersona", "personaId", personaId);
      const localVarPath = `/api/v1/persona/{persona_id}`.replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Get a list of personas
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPersonas: async (xHumanId, options = {}) => {
      const localVarPath = `/api/v1/persona/list`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Update a persona
     * @param {string} personaId 
     * @param {UpdatePersonaRequest} updatePersonaRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePersona: async (personaId, updatePersonaRequest, xHumanId, options = {}) => {
      assertParamExists("updatePersona", "personaId", personaId);
      assertParamExists("updatePersona", "updatePersonaRequest", updatePersonaRequest);
      const localVarPath = `/api/v1/persona/{persona_id}`.replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(updatePersonaRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var PersonaApiFp = function(configuration) {
  const localVarAxiosParamCreator = PersonaApiAxiosParamCreator(configuration);
  return {
    /**
     * 
     * @summary Get a persona
     * @param {CreatePersonaRequest} createPersonaRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPersona(createPersonaRequest, xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPersona(createPersonaRequest, xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["PersonaApi.createPersona"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios5, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 
     * @summary Delete a persona
     * @param {string} personaId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePersona(personaId, xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletePersona(personaId, xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["PersonaApi.deletePersona"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios5, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 
     * @summary Get a persona
     * @param {string} personaId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPersona(personaId, xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPersona(personaId, xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["PersonaApi.getPersona"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios5, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 
     * @summary Get a list of personas
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listPersonas(xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listPersonas(xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["PersonaApi.listPersonas"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios5, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 
     * @summary Update a persona
     * @param {string} personaId 
     * @param {UpdatePersonaRequest} updatePersonaRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePersona(personaId, updatePersonaRequest, xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatePersona(personaId, updatePersonaRequest, xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["PersonaApi.updatePersona"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios5, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    }
  };
};
var PersonaApi = class extends BaseAPI {
  /**
   * 
   * @summary Get a persona
   * @param {CreatePersonaRequest} createPersonaRequest 
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersonaApi
   */
  createPersona(createPersonaRequest, xHumanId, options) {
    return PersonaApiFp(this.configuration).createPersona(createPersonaRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Delete a persona
   * @param {string} personaId 
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersonaApi
   */
  deletePersona(personaId, xHumanId, options) {
    return PersonaApiFp(this.configuration).deletePersona(personaId, xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Get a persona
   * @param {string} personaId 
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersonaApi
   */
  getPersona(personaId, xHumanId, options) {
    return PersonaApiFp(this.configuration).getPersona(personaId, xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Get a list of personas
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersonaApi
   */
  listPersonas(xHumanId, options) {
    return PersonaApiFp(this.configuration).listPersonas(xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Update a persona
   * @param {string} personaId 
   * @param {UpdatePersonaRequest} updatePersonaRequest 
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PersonaApi
   */
  updatePersona(personaId, updatePersonaRequest, xHumanId, options) {
    return PersonaApiFp(this.configuration).updatePersona(personaId, updatePersonaRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
};

// src/generated/api/realtime-api.ts
import globalAxios6 from "axios";
var RealtimeApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * End the RealtimeSession with the given identifier. 
     * @summary End a RealtimeSession.
     * @param {string} session The unique identifier of the RealtimeSession.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    endRealtimeSession: async (session, xHumanId, options = {}) => {
      assertParamExists("endRealtimeSession", "session", session);
      const localVarPath = `/api/v1/realtime/{session}/end`.replace(`{${"session"}}`, encodeURIComponent(String(session)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * End the RealtimeSession with the given identifier. 
     * @summary Get a RealtimeSession.
     * @param {string} session The unique identifier of the RealtimeSession.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRealtimeSession: async (session, xHumanId, options = {}) => {
      assertParamExists("getRealtimeSession", "session", session);
      const localVarPath = `/api/v1/realtime/{session}`.replace(`{${"session"}}`, encodeURIComponent(String(session)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get all ContextMessages associated with the given RealtimeSession. 
     * @summary Get a RealtimeSession messages.
     * @param {string} session The unique identifier of the RealtimeSession.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRealtimeSessionMessages: async (session, xHumanId, options = {}) => {
      assertParamExists("getRealtimeSessionMessages", "session", session);
      const localVarPath = `/api/v1/realtime/{session}/messages`.replace(`{${"session"}}`, encodeURIComponent(String(session)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get the timeline of the RealtimeSession with the given identifier. 
     * @summary Get a RealtimeSession timeline.
     * @param {string} session The unique identifier of the RealtimeSession.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRealtimeSessionTimeline: async (session, xHumanId, options = {}) => {
      assertParamExists("getRealtimeSessionTimeline", "session", session);
      const localVarPath = `/api/v1/realtime/{session}/timeline`.replace(`{${"session"}}`, encodeURIComponent(String(session)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * List all Realtime Sessions. 
     * @summary List Realtime Sessions.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRealtimeSessions: async (xHumanId, options = {}) => {
      const localVarPath = `/api/v1/realtime/list`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Start a new RealtimeSession with the given configuration. 
     * @summary Start a new RealtimeSession.
     * @param {StartRealtimeSessionRequest} startRealtimeSessionRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startRealtimeSession: async (startRealtimeSessionRequest, xHumanId, options = {}) => {
      assertParamExists("startRealtimeSession", "startRealtimeSessionRequest", startRealtimeSessionRequest);
      const localVarPath = `/api/v1/realtime/start`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(startRealtimeSessionRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Update the RealtimeSession with the given identifier. 
     * @summary Update a RealtimeSession.
     * @param {string} session The unique identifier of the RealtimeSession.
     * @param {RealtimeSessionConfigUpdate} realtimeSessionConfigUpdate 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRealtimeSession: async (session, realtimeSessionConfigUpdate, xHumanId, options = {}) => {
      assertParamExists("updateRealtimeSession", "session", session);
      assertParamExists("updateRealtimeSession", "realtimeSessionConfigUpdate", realtimeSessionConfigUpdate);
      const localVarPath = `/api/v1/realtime/{session}/update`.replace(`{${"session"}}`, encodeURIComponent(String(session)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(realtimeSessionConfigUpdate, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var RealtimeApiFp = function(configuration) {
  const localVarAxiosParamCreator = RealtimeApiAxiosParamCreator(configuration);
  return {
    /**
     * End the RealtimeSession with the given identifier. 
     * @summary End a RealtimeSession.
     * @param {string} session The unique identifier of the RealtimeSession.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async endRealtimeSession(session, xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.endRealtimeSession(session, xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["RealtimeApi.endRealtimeSession"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios6, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * End the RealtimeSession with the given identifier. 
     * @summary Get a RealtimeSession.
     * @param {string} session The unique identifier of the RealtimeSession.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRealtimeSession(session, xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRealtimeSession(session, xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["RealtimeApi.getRealtimeSession"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios6, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get all ContextMessages associated with the given RealtimeSession. 
     * @summary Get a RealtimeSession messages.
     * @param {string} session The unique identifier of the RealtimeSession.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRealtimeSessionMessages(session, xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRealtimeSessionMessages(session, xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["RealtimeApi.getRealtimeSessionMessages"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios6, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Get the timeline of the RealtimeSession with the given identifier. 
     * @summary Get a RealtimeSession timeline.
     * @param {string} session The unique identifier of the RealtimeSession.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRealtimeSessionTimeline(session, xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRealtimeSessionTimeline(session, xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["RealtimeApi.getRealtimeSessionTimeline"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios6, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * List all Realtime Sessions. 
     * @summary List Realtime Sessions.
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listRealtimeSessions(xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listRealtimeSessions(xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["RealtimeApi.listRealtimeSessions"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios6, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Start a new RealtimeSession with the given configuration. 
     * @summary Start a new RealtimeSession.
     * @param {StartRealtimeSessionRequest} startRealtimeSessionRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async startRealtimeSession(startRealtimeSessionRequest, xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.startRealtimeSession(startRealtimeSessionRequest, xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["RealtimeApi.startRealtimeSession"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios6, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Update the RealtimeSession with the given identifier. 
     * @summary Update a RealtimeSession.
     * @param {string} session The unique identifier of the RealtimeSession.
     * @param {RealtimeSessionConfigUpdate} realtimeSessionConfigUpdate 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRealtimeSession(session, realtimeSessionConfigUpdate, xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateRealtimeSession(session, realtimeSessionConfigUpdate, xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["RealtimeApi.updateRealtimeSession"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios6, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    }
  };
};
var RealtimeApi = class extends BaseAPI {
  /**
   * End the RealtimeSession with the given identifier. 
   * @summary End a RealtimeSession.
   * @param {string} session The unique identifier of the RealtimeSession.
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealtimeApi
   */
  endRealtimeSession(session, xHumanId, options) {
    return RealtimeApiFp(this.configuration).endRealtimeSession(session, xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * End the RealtimeSession with the given identifier. 
   * @summary Get a RealtimeSession.
   * @param {string} session The unique identifier of the RealtimeSession.
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealtimeApi
   */
  getRealtimeSession(session, xHumanId, options) {
    return RealtimeApiFp(this.configuration).getRealtimeSession(session, xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get all ContextMessages associated with the given RealtimeSession. 
   * @summary Get a RealtimeSession messages.
   * @param {string} session The unique identifier of the RealtimeSession.
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealtimeApi
   */
  getRealtimeSessionMessages(session, xHumanId, options) {
    return RealtimeApiFp(this.configuration).getRealtimeSessionMessages(session, xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get the timeline of the RealtimeSession with the given identifier. 
   * @summary Get a RealtimeSession timeline.
   * @param {string} session The unique identifier of the RealtimeSession.
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealtimeApi
   */
  getRealtimeSessionTimeline(session, xHumanId, options) {
    return RealtimeApiFp(this.configuration).getRealtimeSessionTimeline(session, xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * List all Realtime Sessions. 
   * @summary List Realtime Sessions.
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealtimeApi
   */
  listRealtimeSessions(xHumanId, options) {
    return RealtimeApiFp(this.configuration).listRealtimeSessions(xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Start a new RealtimeSession with the given configuration. 
   * @summary Start a new RealtimeSession.
   * @param {StartRealtimeSessionRequest} startRealtimeSessionRequest 
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealtimeApi
   */
  startRealtimeSession(startRealtimeSessionRequest, xHumanId, options) {
    return RealtimeApiFp(this.configuration).startRealtimeSession(startRealtimeSessionRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Update the RealtimeSession with the given identifier. 
   * @summary Update a RealtimeSession.
   * @param {string} session The unique identifier of the RealtimeSession.
   * @param {RealtimeSessionConfigUpdate} realtimeSessionConfigUpdate 
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RealtimeApi
   */
  updateRealtimeSession(session, realtimeSessionConfigUpdate, xHumanId, options) {
    return RealtimeApiFp(this.configuration).updateRealtimeSession(session, realtimeSessionConfigUpdate, xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
};

// src/generated/api/scenario-api.ts
import globalAxios7 from "axios";
var ScenarioApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * 
     * @summary Create a scenario
     * @param {CreateScenarioRequest} createScenarioRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createScenario: async (createScenarioRequest, options = {}) => {
      assertParamExists("createScenario", "createScenarioRequest", createScenarioRequest);
      const localVarPath = `/api/v1/scenario`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createScenarioRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Delete a scenario
     * @param {string} scenarioId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteScenario: async (scenarioId, xHumanId, options = {}) => {
      assertParamExists("deleteScenario", "scenarioId", scenarioId);
      const localVarPath = `/api/v1/scenario/{scenario_id}`.replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Get a scenario
     * @param {string} scenarioId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScenario: async (scenarioId, xHumanId, options = {}) => {
      assertParamExists("getScenario", "scenarioId", scenarioId);
      const localVarPath = `/api/v1/scenario/{scenario_id}`.replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Get a list of scenarios
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listScenarios: async (xHumanId, options = {}) => {
      const localVarPath = `/api/v1/scenario/list`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Update a scenario
     * @param {string} scenarioId 
     * @param {UpdateScenarioRequest} updateScenarioRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateScenario: async (scenarioId, updateScenarioRequest, xHumanId, options = {}) => {
      assertParamExists("updateScenario", "scenarioId", scenarioId);
      assertParamExists("updateScenario", "updateScenarioRequest", updateScenarioRequest);
      const localVarPath = `/api/v1/scenario/{scenario_id}`.replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(updateScenarioRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ScenarioApiFp = function(configuration) {
  const localVarAxiosParamCreator = ScenarioApiAxiosParamCreator(configuration);
  return {
    /**
     * 
     * @summary Create a scenario
     * @param {CreateScenarioRequest} createScenarioRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createScenario(createScenarioRequest, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createScenario(createScenarioRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["ScenarioApi.createScenario"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios7, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 
     * @summary Delete a scenario
     * @param {string} scenarioId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteScenario(scenarioId, xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScenario(scenarioId, xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["ScenarioApi.deleteScenario"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios7, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 
     * @summary Get a scenario
     * @param {string} scenarioId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getScenario(scenarioId, xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getScenario(scenarioId, xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["ScenarioApi.getScenario"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios7, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 
     * @summary Get a list of scenarios
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listScenarios(xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listScenarios(xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["ScenarioApi.listScenarios"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios7, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 
     * @summary Update a scenario
     * @param {string} scenarioId 
     * @param {UpdateScenarioRequest} updateScenarioRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateScenario(scenarioId, updateScenarioRequest, xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateScenario(scenarioId, updateScenarioRequest, xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["ScenarioApi.updateScenario"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios7, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    }
  };
};
var ScenarioApi = class extends BaseAPI {
  /**
   * 
   * @summary Create a scenario
   * @param {CreateScenarioRequest} createScenarioRequest 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenarioApi
   */
  createScenario(createScenarioRequest, options) {
    return ScenarioApiFp(this.configuration).createScenario(createScenarioRequest, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Delete a scenario
   * @param {string} scenarioId 
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenarioApi
   */
  deleteScenario(scenarioId, xHumanId, options) {
    return ScenarioApiFp(this.configuration).deleteScenario(scenarioId, xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Get a scenario
   * @param {string} scenarioId 
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenarioApi
   */
  getScenario(scenarioId, xHumanId, options) {
    return ScenarioApiFp(this.configuration).getScenario(scenarioId, xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Get a list of scenarios
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenarioApi
   */
  listScenarios(xHumanId, options) {
    return ScenarioApiFp(this.configuration).listScenarios(xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Update a scenario
   * @param {string} scenarioId 
   * @param {UpdateScenarioRequest} updateScenarioRequest 
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenarioApi
   */
  updateScenario(scenarioId, updateScenarioRequest, xHumanId, options) {
    return ScenarioApiFp(this.configuration).updateScenario(scenarioId, updateScenarioRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
};

// src/generated/api/session-api.ts
import globalAxios8 from "axios";
var SessionApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * This endpoint is deprecated. Use Realtime Apis instead.
     * @summary Get a list of sessions
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {string} [human] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    apiV1SessionListGet: async (xHumanId, human, options = {}) => {
      const localVarPath = `/api/v1/session/list`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (human !== void 0) {
        localVarQueryParameter["human"] = human;
      }
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary End a session
     * @param {string} sessionId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiV1SessionSessionIdEndPost: async (sessionId, xHumanId, options = {}) => {
      assertParamExists("apiV1SessionSessionIdEndPost", "sessionId", sessionId);
      const localVarPath = `/api/v1/session/{session_id}/end`.replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * This endpoint is deprecated. Use Realtime Apis instead.
     * @summary Get a session by id
     * @param {string} sessionId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    apiV1SessionSessionIdGet: async (sessionId, xHumanId, options = {}) => {
      assertParamExists("apiV1SessionSessionIdGet", "sessionId", sessionId);
      const localVarPath = `/api/v1/session/{session_id}`.replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * This endpoint is deprecated. Use Realtime Apis instead.
     * @summary Get session messages
     * @param {string} sessionId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    apiV1SessionSessionIdMessagesGet: async (sessionId, xHumanId, options = {}) => {
      assertParamExists("apiV1SessionSessionIdMessagesGet", "sessionId", sessionId);
      const localVarPath = `/api/v1/session/{session_id}/messages`.replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * This endpoint is deprecated. Use Realtime Apis instead.
     * @summary Update a session by id
     * @param {string} sessionId 
     * @param {UpdateSessionRequest} updateSessionRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    apiV1SessionSessionIdPut: async (sessionId, updateSessionRequest, options = {}) => {
      assertParamExists("apiV1SessionSessionIdPut", "sessionId", sessionId);
      assertParamExists("apiV1SessionSessionIdPut", "updateSessionRequest", updateSessionRequest);
      const localVarPath = `/api/v1/session/{session_id}`.replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(updateSessionRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * This endpoint is deprecated. Use Realtime Apis instead.
     * @summary Get a session timeline
     * @param {string} sessionId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    apiV1SessionSessionIdTimelineGet: async (sessionId, xHumanId, options = {}) => {
      assertParamExists("apiV1SessionSessionIdTimelineGet", "sessionId", sessionId);
      const localVarPath = `/api/v1/session/{session_id}/timeline`.replace(`{${"session_id"}}`, encodeURIComponent(String(sessionId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * This endpoint is deprecated. Use Realtime Apis instead.
     * @summary Create a new session
     * @param {SessionStartRequest} sessionStartRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    apiV1SessionStartPost: async (sessionStartRequest, xHumanId, options = {}) => {
      assertParamExists("apiV1SessionStartPost", "sessionStartRequest", sessionStartRequest);
      const localVarPath = `/api/v1/session/start`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(sessionStartRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var SessionApiFp = function(configuration) {
  const localVarAxiosParamCreator = SessionApiAxiosParamCreator(configuration);
  return {
    /**
     * This endpoint is deprecated. Use Realtime Apis instead.
     * @summary Get a list of sessions
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {string} [human] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async apiV1SessionListGet(xHumanId, human, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionListGet(xHumanId, human, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["SessionApi.apiV1SessionListGet"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios8, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 
     * @summary End a session
     * @param {string} sessionId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiV1SessionSessionIdEndPost(sessionId, xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdEndPost(sessionId, xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["SessionApi.apiV1SessionSessionIdEndPost"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios8, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * This endpoint is deprecated. Use Realtime Apis instead.
     * @summary Get a session by id
     * @param {string} sessionId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async apiV1SessionSessionIdGet(sessionId, xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdGet(sessionId, xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["SessionApi.apiV1SessionSessionIdGet"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios8, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * This endpoint is deprecated. Use Realtime Apis instead.
     * @summary Get session messages
     * @param {string} sessionId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async apiV1SessionSessionIdMessagesGet(sessionId, xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdMessagesGet(sessionId, xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["SessionApi.apiV1SessionSessionIdMessagesGet"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios8, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * This endpoint is deprecated. Use Realtime Apis instead.
     * @summary Update a session by id
     * @param {string} sessionId 
     * @param {UpdateSessionRequest} updateSessionRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async apiV1SessionSessionIdPut(sessionId, updateSessionRequest, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdPut(sessionId, updateSessionRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["SessionApi.apiV1SessionSessionIdPut"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios8, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * This endpoint is deprecated. Use Realtime Apis instead.
     * @summary Get a session timeline
     * @param {string} sessionId 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async apiV1SessionSessionIdTimelineGet(sessionId, xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionSessionIdTimelineGet(sessionId, xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["SessionApi.apiV1SessionSessionIdTimelineGet"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios8, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * This endpoint is deprecated. Use Realtime Apis instead.
     * @summary Create a new session
     * @param {SessionStartRequest} sessionStartRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async apiV1SessionStartPost(sessionStartRequest, xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1SessionStartPost(sessionStartRequest, xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["SessionApi.apiV1SessionStartPost"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios8, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    }
  };
};
var SessionApi = class extends BaseAPI {
  /**
   * This endpoint is deprecated. Use Realtime Apis instead.
   * @summary Get a list of sessions
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {string} [human] 
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof SessionApi
   */
  apiV1SessionListGet(xHumanId, human, options) {
    return SessionApiFp(this.configuration).apiV1SessionListGet(xHumanId, human, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary End a session
   * @param {string} sessionId 
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SessionApi
   */
  apiV1SessionSessionIdEndPost(sessionId, xHumanId, options) {
    return SessionApiFp(this.configuration).apiV1SessionSessionIdEndPost(sessionId, xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * This endpoint is deprecated. Use Realtime Apis instead.
   * @summary Get a session by id
   * @param {string} sessionId 
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof SessionApi
   */
  apiV1SessionSessionIdGet(sessionId, xHumanId, options) {
    return SessionApiFp(this.configuration).apiV1SessionSessionIdGet(sessionId, xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * This endpoint is deprecated. Use Realtime Apis instead.
   * @summary Get session messages
   * @param {string} sessionId 
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof SessionApi
   */
  apiV1SessionSessionIdMessagesGet(sessionId, xHumanId, options) {
    return SessionApiFp(this.configuration).apiV1SessionSessionIdMessagesGet(sessionId, xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * This endpoint is deprecated. Use Realtime Apis instead.
   * @summary Update a session by id
   * @param {string} sessionId 
   * @param {UpdateSessionRequest} updateSessionRequest 
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof SessionApi
   */
  apiV1SessionSessionIdPut(sessionId, updateSessionRequest, options) {
    return SessionApiFp(this.configuration).apiV1SessionSessionIdPut(sessionId, updateSessionRequest, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * This endpoint is deprecated. Use Realtime Apis instead.
   * @summary Get a session timeline
   * @param {string} sessionId 
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof SessionApi
   */
  apiV1SessionSessionIdTimelineGet(sessionId, xHumanId, options) {
    return SessionApiFp(this.configuration).apiV1SessionSessionIdTimelineGet(sessionId, xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * This endpoint is deprecated. Use Realtime Apis instead.
   * @summary Create a new session
   * @param {SessionStartRequest} sessionStartRequest 
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof SessionApi
   */
  apiV1SessionStartPost(sessionStartRequest, xHumanId, options) {
    return SessionApiFp(this.configuration).apiV1SessionStartPost(sessionStartRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
};

// src/generated/api/usage-api.ts
import globalAxios9 from "axios";
var UsageApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Requests a token for a human
     * @summary Request new human token
     * @param {UsageTokenRequest} usageTokenRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUsageToken: async (usageTokenRequest, xHumanId, options = {}) => {
      assertParamExists("createUsageToken", "usageTokenRequest", usageTokenRequest);
      const localVarPath = `/api/v1/usage/token`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(usageTokenRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets the usage limits of a token
     * @summary Get usage limits
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsageLimits: async (xHumanId, options = {}) => {
      const localVarPath = `/api/v1/usage/limits`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Updates the usage limits of a human
     * @summary Update limits on a usage token
     * @param {UpdateUsageLimitsRequest} updateUsageLimitsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUsageToken: async (updateUsageLimitsRequest, options = {}) => {
      assertParamExists("updateUsageToken", "updateUsageLimitsRequest", updateUsageLimitsRequest);
      const localVarPath = `/api/v1/usage/token`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(updateUsageLimitsRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var UsageApiFp = function(configuration) {
  const localVarAxiosParamCreator = UsageApiAxiosParamCreator(configuration);
  return {
    /**
     * Requests a token for a human
     * @summary Request new human token
     * @param {UsageTokenRequest} usageTokenRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUsageToken(usageTokenRequest, xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUsageToken(usageTokenRequest, xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["UsageApi.createUsageToken"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios9, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Gets the usage limits of a token
     * @summary Get usage limits
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsageLimits(xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsageLimits(xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["UsageApi.getUsageLimits"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios9, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Updates the usage limits of a human
     * @summary Update limits on a usage token
     * @param {UpdateUsageLimitsRequest} updateUsageLimitsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUsageToken(updateUsageLimitsRequest, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUsageToken(updateUsageLimitsRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["UsageApi.updateUsageToken"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios9, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    }
  };
};
var UsageApi = class extends BaseAPI {
  /**
   * Requests a token for a human
   * @summary Request new human token
   * @param {UsageTokenRequest} usageTokenRequest 
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsageApi
   */
  createUsageToken(usageTokenRequest, xHumanId, options) {
    return UsageApiFp(this.configuration).createUsageToken(usageTokenRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets the usage limits of a token
   * @summary Get usage limits
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsageApi
   */
  getUsageLimits(xHumanId, options) {
    return UsageApiFp(this.configuration).getUsageLimits(xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Updates the usage limits of a human
   * @summary Update limits on a usage token
   * @param {UpdateUsageLimitsRequest} updateUsageLimitsRequest 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsageApi
   */
  updateUsageToken(updateUsageLimitsRequest, options) {
    return UsageApiFp(this.configuration).updateUsageToken(updateUsageLimitsRequest, options).then((request) => request(this.axios, this.basePath));
  }
};

// src/generated/api/voice-api.ts
import globalAxios10 from "axios";
var VoiceApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new cloned voice based on the input audio file
     * @summary Clone a voice
     * @param {string} name Name of the new voice
     * @param {string} language Language of the voice (e.g., \\\&#39;en\\\&#39;, \\\&#39;es\\\&#39;, \\\&#39;fr\\\&#39;)
     * @param {File} file Audio file for voice cloning (MP3 format)
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cloneVoice: async (name, language, file, xHumanId, options = {}) => {
      assertParamExists("cloneVoice", "name", name);
      assertParamExists("cloneVoice", "language", language);
      assertParamExists("cloneVoice", "file", file);
      const localVarPath = `/api/v1/voice/clone`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      const localVarFormParams = new (configuration && configuration.formDataCtor || FormData)();
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      if (name !== void 0) {
        localVarFormParams.append("name", name);
      }
      if (language !== void 0) {
        localVarFormParams.append("language", language);
      }
      if (file !== void 0) {
        localVarFormParams.append("file", file);
      }
      localVarHeaderParameter["Content-Type"] = "multipart/form-data";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = localVarFormParams;
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Delete a voice
     * @param {string} voiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVoice: async (voiceId, options = {}) => {
      assertParamExists("deleteVoice", "voiceId", voiceId);
      const localVarPath = `/api/v1/voice/{voice_id}`.replace(`{${"voice_id"}}`, encodeURIComponent(String(voiceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Generates speech from input text and specified voice
     * @summary Generate voice
     * @param {GenerateVoiceRequest} generateVoiceRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateVoice: async (generateVoiceRequest, xHumanId, options = {}) => {
      assertParamExists("generateVoice", "generateVoiceRequest", generateVoiceRequest);
      const localVarPath = `/api/v1/voice/generate`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(generateVoiceRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Get a voice
     * @param {string} voiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVoice: async (voiceId, options = {}) => {
      assertParamExists("getVoice", "voiceId", voiceId);
      const localVarPath = `/api/v1/voice/{voice_id}`.replace(`{${"voice_id"}}`, encodeURIComponent(String(voiceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Get a list of voices
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listVoices: async (xHumanId, options = {}) => {
      const localVarPath = `/api/v1/voice/list`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xHumanId != null) {
        localVarHeaderParameter["x-human-id"] = String(xHumanId);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Updates a voice based on the input request data
     * @summary Update a voice
     * @param {string} voiceId 
     * @param {UpdateVoiceRequest} updateVoiceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateVoice: async (voiceId, updateVoiceRequest, options = {}) => {
      assertParamExists("updateVoice", "voiceId", voiceId);
      assertParamExists("updateVoice", "updateVoiceRequest", updateVoiceRequest);
      const localVarPath = `/api/v1/voice/{voice_id}`.replace(`{${"voice_id"}}`, encodeURIComponent(String(voiceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration);
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(updateVoiceRequest, localVarRequestOptions, configuration);
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var VoiceApiFp = function(configuration) {
  const localVarAxiosParamCreator = VoiceApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new cloned voice based on the input audio file
     * @summary Clone a voice
     * @param {string} name Name of the new voice
     * @param {string} language Language of the voice (e.g., \\\&#39;en\\\&#39;, \\\&#39;es\\\&#39;, \\\&#39;fr\\\&#39;)
     * @param {File} file Audio file for voice cloning (MP3 format)
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cloneVoice(name, language, file, xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cloneVoice(name, language, file, xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["VoiceApi.cloneVoice"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios10, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 
     * @summary Delete a voice
     * @param {string} voiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteVoice(voiceId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVoice(voiceId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["VoiceApi.deleteVoice"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios10, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Generates speech from input text and specified voice
     * @summary Generate voice
     * @param {GenerateVoiceRequest} generateVoiceRequest 
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateVoice(generateVoiceRequest, xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generateVoice(generateVoiceRequest, xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["VoiceApi.generateVoice"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios10, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 
     * @summary Get a voice
     * @param {string} voiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVoice(voiceId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getVoice(voiceId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["VoiceApi.getVoice"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios10, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 
     * @summary Get a list of voices
     * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listVoices(xHumanId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listVoices(xHumanId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["VoiceApi.listVoices"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios10, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Updates a voice based on the input request data
     * @summary Update a voice
     * @param {string} voiceId 
     * @param {UpdateVoiceRequest} updateVoiceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateVoice(voiceId, updateVoiceRequest, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateVoice(voiceId, updateVoiceRequest, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath = operationServerMap["VoiceApi.updateVoice"]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios10, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
    }
  };
};
var VoiceApi = class extends BaseAPI {
  /**
   * Creates a new cloned voice based on the input audio file
   * @summary Clone a voice
   * @param {string} name Name of the new voice
   * @param {string} language Language of the voice (e.g., \\\&#39;en\\\&#39;, \\\&#39;es\\\&#39;, \\\&#39;fr\\\&#39;)
   * @param {File} file Audio file for voice cloning (MP3 format)
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VoiceApi
   */
  cloneVoice(name, language, file, xHumanId, options) {
    return VoiceApiFp(this.configuration).cloneVoice(name, language, file, xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Delete a voice
   * @param {string} voiceId 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VoiceApi
   */
  deleteVoice(voiceId, options) {
    return VoiceApiFp(this.configuration).deleteVoice(voiceId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Generates speech from input text and specified voice
   * @summary Generate voice
   * @param {GenerateVoiceRequest} generateVoiceRequest 
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VoiceApi
   */
  generateVoice(generateVoiceRequest, xHumanId, options) {
    return VoiceApiFp(this.configuration).generateVoice(generateVoiceRequest, xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Get a voice
   * @param {string} voiceId 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VoiceApi
   */
  getVoice(voiceId, options) {
    return VoiceApiFp(this.configuration).getVoice(voiceId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Get a list of voices
   * @param {string} [xHumanId] When using x-api-key authentication, this header is used to scope requests to a specific human.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VoiceApi
   */
  listVoices(xHumanId, options) {
    return VoiceApiFp(this.configuration).listVoices(xHumanId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Updates a voice based on the input request data
   * @summary Update a voice
   * @param {string} voiceId 
   * @param {UpdateVoiceRequest} updateVoiceRequest 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VoiceApi
   */
  updateVoice(voiceId, updateVoiceRequest, options) {
    return VoiceApiFp(this.configuration).updateVoice(voiceId, updateVoiceRequest, options).then((request) => request(this.axios, this.basePath));
  }
};

// src/generated/configuration.ts
var Configuration = class {
  constructor(param = {}) {
    this.apiKey = param.apiKey;
    this.username = param.username;
    this.password = param.password;
    this.accessToken = param.accessToken;
    this.basePath = param.basePath;
    this.serverIndex = param.serverIndex;
    this.baseOptions = param.baseOptions;
    this.formDataCtor = param.formDataCtor;
  }
  /**
   * Check if the given MIME is a JSON MIME.
   * JSON MIME examples:
   *   application/json
   *   application/json; charset=UTF8
   *   APPLICATION/JSON
   *   application/vnd.company+json
   * @param mime - MIME (Multipurpose Internet Mail Extensions)
   * @return True if the given MIME is JSON, false otherwise.
   */
  isJsonMime(mime) {
    const jsonMime = new RegExp("^(application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(;.*)?$", "i");
    return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === "application/json-patch+json");
  }
};

// src/generated/model/chat-completion-request-message.ts
var ChatCompletionRequestMessageRoleEnum = {
  User: "user",
  Assistant: "assistant",
  System: "system"
};

// src/generated/model/chat-completion-request-message-content-part-audio.ts
var ChatCompletionRequestMessageContentPartAudioTypeEnum = {
  InputAudio: "input_audio"
};

// src/generated/model/chat-completion-request-message-content-part-audio-input-audio.ts
var ChatCompletionRequestMessageContentPartAudioInputAudioFormatEnum = {
  Wav: "wav",
  Mp3: "mp3",
  Ogg: "ogg"
};

// src/generated/model/chat-completion-request-message-content-part-text.ts
var ChatCompletionRequestMessageContentPartTextTypeEnum = {
  Text: "text"
};

// src/generated/model/chat-completion-response-gabber-message-data-inner.ts
var ChatCompletionResponseGabberMessageDataInnerTypeEnum = {
  AudioTranscript: "audio_transcript"
};

// src/generated/model/chat-completion-response-message.ts
var ChatCompletionResponseMessageRoleEnum = {
  Assistant: "assistant"
};

// src/generated/model/chat-completion-stream-response.ts
var ChatCompletionStreamResponseObjectEnum = {
  ChatCompletionChunk: "chat.completion.chunk"
};

// src/generated/model/chat-completion-stream-response-choices-inner.ts
var ChatCompletionStreamResponseChoicesInnerFinishReasonEnum = {
  Stop: "stop",
  Length: "length",
  ToolCalls: "tool_calls",
  ContentFilter: "content_filter",
  FunctionCall: "function_call"
};

// src/generated/model/chat-completion-stream-response-delta.ts
var ChatCompletionStreamResponseDeltaRoleEnum = {
  System: "system",
  User: "user",
  Assistant: "assistant"
};

// src/generated/model/chat-completion-stream-response-gabber-message-data-inner.ts
var ChatCompletionStreamResponseGabberMessageDataInnerTypeEnum = {
  AudioTranscript: "audio_transcript"
};

// src/generated/model/context-create-request-messages-inner.ts
var ContextCreateRequestMessagesInnerRoleEnum = {
  Assistant: "assistant",
  System: "system",
  User: "user"
};

// src/generated/model/context-message-create-params.ts
var ContextMessageCreateParamsRoleEnum = {
  Assistant: "assistant",
  System: "system",
  User: "user"
};

// src/generated/model/create-persona-request.ts
var CreatePersonaRequestGenderEnum = {
  Male: "male",
  Female: "female"
};

// src/generated/model/history-message.ts
var HistoryMessageRoleEnum = {
  Assistant: "assistant",
  System: "system",
  User: "user"
};

// src/generated/model/persona.ts
var PersonaGenderEnum = {
  Male: "male",
  Female: "female"
};

// src/generated/model/realtime-session.ts
var RealtimeSessionStateEnum = {
  Ended: "ended",
  InProgress: "in_progress",
  NotStarted: "not_started"
};

// src/generated/model/realtime-session-timeline-item.ts
var RealtimeSessionTimelineItemTypeEnum = {
  Silence: "silence",
  Agent: "agent",
  User: "user"
};

// src/generated/model/sdkagent-state.ts
var SDKAgentState = {
  Warmup: "warmup",
  Listening: "listening",
  Thinking: "thinking",
  Speaking: "speaking",
  TimeLimitExceeded: "time_limit_exceeded",
  UsageLimitExceeded: "usage_limit_exceeded"
};

// src/generated/model/sdkconnection-state.ts
var SDKConnectionState = {
  NotConnected: "not_connected",
  Connecting: "connecting",
  WaitingForAgent: "waiting_for_agent",
  Connected: "connected"
};

// src/generated/model/session.ts
var SessionStateEnum = {
  Ended: "ended",
  InProgress: "in_progress",
  NotStarted: "not_started"
};

// src/generated/model/session-timeline-item.ts
var SessionTimelineItemTypeEnum = {
  Silence: "silence",
  Agent: "agent",
  User: "user"
};

// src/generated/model/update-persona-request.ts
var UpdatePersonaRequestGenderEnum = {
  Male: "male",
  Female: "female"
};

// src/generated/model/usage-type.ts
var UsageType = {
  ConversationalSeconds: "conversational_seconds",
  VoiceSynthesisSeconds: "voice_synthesis_seconds",
  TokenCnt: "token_cnt"
};

// src/generated/model/webhook-message-usage-tracked.ts
var WebhookMessageUsageTrackedTypeEnum = {
  UsageTracked: "usage.tracked"
};

// src/api.ts
var Api = class {
  constructor(token) {
    const config = new Configuration({ accessToken: token });
    this.realtime = new RealtimeApi(config);
    this.persona = new PersonaApi(config);
    this.session = new SessionApi(config);
    this.voice = new VoiceApi(config);
    this.scenario = new ScenarioApi(config);
    this.llm = new LLMApi(config);
    this.usage = new UsageApi(config);
  }
};

// src/session.ts
var RealtimeSessionEngine = class {
  constructor({
    onConnectionStateChanged,
    onMessagesChanged,
    onMicrophoneChanged,
    onAgentVolumeChanged,
    onUserVolumeChanged,
    onAgentStateChanged,
    onRemainingSecondsChanged,
    onAgentError,
    onCanPlayAudioChanged
  }) {
    this.agentParticipant = null;
    this.agentTrack = null;
    this._microphoneEnabledState = false;
    this.transcriptions = [];
    this._agentState = "warmup";
    this._remainingSeconds = null;
    this.id = null;
    this.livekitRoom = new Room();
    this.livekitRoom.on("connected", this.onRoomConnected.bind(this));
    this.livekitRoom.on("disconnected", this.onRoomDisconnected.bind(this));
    this.livekitRoom.on("trackSubscribed", this.onTrackSubscribed.bind(this));
    this.livekitRoom.on(
      "trackUnsubscribed",
      this.onTrackUnsubscribed.bind(this)
    );
    this.livekitRoom.on("dataReceived", this.onDataReceived.bind(this));
    this.livekitRoom.on(
      "participantMetadataChanged",
      this.onParticipantMetadataChanged.bind(this)
    );
    this.livekitRoom.on(
      "localTrackPublished",
      this.onLocalTrackPublished.bind(this)
    );
    this.livekitRoom.on(
      "localTrackUnpublished",
      this.onLocalTrackUnpublished.bind(this)
    );
    this.livekitRoom.on("trackMuted", this.onTrackMuted.bind(this));
    this.livekitRoom.on("trackUnmuted", this.onTrackUnmuted.bind(this));
    this.livekitRoom.on(
      "audioPlaybackChanged",
      this.onAudioPlaybackChangaed.bind(this)
    );
    this.divElement = document.createElement("div");
    document.body.appendChild(this.divElement);
    this.onConnectionStateChanged = onConnectionStateChanged;
    this.onMessagesChanged = onMessagesChanged;
    this.onMicrophoneChanged = onMicrophoneChanged;
    this.onAgentVolumeChanged = onAgentVolumeChanged;
    this.onUserVolumeChanged = onUserVolumeChanged;
    this.onAgentStateChanged = onAgentStateChanged;
    this.onRemainingSecondsChanged = onRemainingSecondsChanged;
    this.onAgentError = onAgentError;
    this.onCanPlayAudioChanged = onCanPlayAudioChanged;
    this.agentVolumeVisualizer = new TrackVolumeVisualizer({
      onTick: this.onAgentVolumeChanged.bind(this),
      bands: 10
    });
    this.userVolumeVisualizer = new TrackVolumeVisualizer({
      onTick: this.onUserVolumeChanged.bind(this),
      bands: 10
    });
  }
  async connect(opts) {
    let connectionDetails = void 0;
    if ("connection_details" in opts) {
      connectionDetails = opts.connection_details;
    } else if ("token" in opts && "config" in opts) {
      const api = new Api(opts.token);
      const res = await api.realtime.startRealtimeSession(opts);
      connectionDetails = {
        url: res.data.connection_details.url,
        token: res.data.connection_details.token
      };
    }
    if (!connectionDetails) {
      throw new Error("No connection details provided");
    }
    await this.livekitRoom.connect(
      connectionDetails.url,
      connectionDetails.token,
      {
        autoSubscribe: true
      }
    );
    this.onCanPlayAudioChanged(this.livekitRoom.canPlaybackAudio);
  }
  async disconnect() {
    await this.livekitRoom.disconnect();
  }
  async startAudio() {
    try {
      await this.livekitRoom.startAudio();
    } catch (e) {
      console.error("Error starting audio");
    }
  }
  async setMicrophoneEnabled(enabled) {
    await this.livekitRoom.localParticipant.setMicrophoneEnabled(enabled);
  }
  async sendChatMessage({ text }) {
    const te = new TextEncoder();
    const encoded = te.encode(JSON.stringify({ text }));
    await this.livekitRoom.localParticipant.publishData(encoded, {
      topic: "chat_input"
    });
  }
  set agentState(value) {
    if (value == this._agentState) {
      return;
    }
    this._agentState = value;
    this.onAgentStateChanged(value);
  }
  set remainingSeconds(value) {
    if (value === this._remainingSeconds) {
      return;
    }
    this._remainingSeconds = value;
    this.onRemainingSecondsChanged(value);
  }
  destroy() {
    document.body.removeChild(this.divElement);
    try {
      this.livekitRoom.removeAllListeners();
      this.livekitRoom.disconnect(true);
    } catch (e) {
      console.error("Error destroying session", e);
    }
  }
  set microphoneEnabledState(value) {
    if (this._microphoneEnabledState !== value) {
      this._microphoneEnabledState = value;
      this.onMicrophoneChanged(value);
    }
  }
  resolveMicrophoneState() {
    if (!this.livekitRoom.localParticipant) {
      this.microphoneEnabledState = false;
    }
    this.microphoneEnabledState = this.livekitRoom.localParticipant.isMicrophoneEnabled;
  }
  onTrackUnmuted(publication, participant) {
    console.log("Local track unmuted", publication, participant);
    if (!participant.isLocal) {
      return;
    }
    if (publication.kind === Track.Kind.Audio) {
      this.resolveMicrophoneState();
    }
  }
  onTrackMuted(publication, participant) {
    console.log("Local track muted", publication, participant);
    if (!participant.isLocal) {
      return;
    }
    if (publication.kind === Track.Kind.Audio) {
      this.resolveMicrophoneState();
    }
  }
  onLocalTrackPublished(publication, participant) {
    console.log("Local track published", publication, participant);
    if (publication.kind === Track.Kind.Audio) {
      this.userVolumeVisualizer.setTrack(
        publication.audioTrack
      );
      this.resolveMicrophoneState();
    }
  }
  onLocalTrackUnpublished(publication, participant) {
    console.log("Local track unpublished", publication, participant);
    if (publication.kind === Track.Kind.Audio) {
      this.resolveMicrophoneState();
    }
  }
  onAudioPlaybackChangaed(_) {
    this.onCanPlayAudioChanged(this.livekitRoom.canPlaybackAudio);
  }
  onRoomConnected() {
    console.log("Room connected");
    this.resolveMicrophoneState();
    const metadataString = this.livekitRoom.metadata || "{}";
    this.id = JSON.parse(metadataString)["session"] || null;
    this.onConnectionStateChanged("waiting_for_agent");
  }
  onRoomDisconnected() {
    console.log("Room disconnected");
    this.id = null;
    this.resolveMicrophoneState();
    this.onConnectionStateChanged("not_connected");
  }
  onTrackSubscribed(track, pub, participant) {
    console.log("Track subscribed", track, pub, participant);
    if (track.kind !== "audio") {
      return;
    }
    if (this.agentParticipant) {
      console.error("Already subscribed to an agent");
      return;
    }
    this.divElement.appendChild(track.attach());
    this.agentParticipant = participant;
    this.agentTrack = track;
    this.agentVolumeVisualizer.setTrack(track);
    this.onConnectionStateChanged("connected");
  }
  onTrackUnsubscribed(track, pub, participant) {
    console.log("Track unsubscribed", track, pub, participant);
    if (track.kind !== "audio") {
      return;
    }
    track.attachedElements.forEach((el) => {
      el.remove();
    });
    if (track !== this.agentTrack) {
      console.error("Unsubscribed from unknown track");
      return;
    }
    this.agentParticipant = null;
    this.agentTrack = null;
    if (this.livekitRoom.state === "connected") {
      this.onConnectionStateChanged("waiting_for_agent");
    }
  }
  onDataReceived(data, participant, _, topic) {
    if (participant !== this.agentParticipant) {
      return;
    }
    const decoded = new TextDecoder().decode(data);
    console.log("Data received", decoded, participant, topic);
    if (topic === "message") {
      const message = JSON.parse(decoded);
      for (let i = 0; i < this.transcriptions.length; i++) {
        if (this.transcriptions[i].id === message.id && this.transcriptions[i].agent == message.agent) {
          this.transcriptions[i] = message;
          this.onMessagesChanged(this.transcriptions);
          return;
        }
      }
      this.transcriptions.push(message);
      this.onMessagesChanged(this.transcriptions);
    } else if (topic === "error") {
      const payload = JSON.parse(decoded);
      this.onAgentError(payload.message);
    }
  }
  onParticipantMetadataChanged(_, participant) {
    if (!participant.metadata || !participant.isAgent) {
      return;
    }
    try {
      const md = JSON.parse(participant.metadata);
      if (md.remaining_seconds) {
        this.remainingSeconds = md.remaining_seconds;
      }
      const { agent_state } = md;
      if (agent_state != "speaking" && agent_state != "listening" && agent_state != "thinking" && agent_state != "warmup" && agent_state != "time_limit_exceeded") {
        console.error("Unrecognized agent_state", agent_state);
        return;
      }
      this.agentState = agent_state;
    } catch (e) {
      console.error("Error on participant metadata cb", e);
    }
  }
};
export {
  Api,
  ChatCompletionRequestMessageContentPartAudioInputAudioFormatEnum,
  ChatCompletionRequestMessageContentPartAudioTypeEnum,
  ChatCompletionRequestMessageContentPartTextTypeEnum,
  ChatCompletionRequestMessageRoleEnum,
  ChatCompletionResponseGabberMessageDataInnerTypeEnum,
  ChatCompletionResponseMessageRoleEnum,
  ChatCompletionStreamResponseChoicesInnerFinishReasonEnum,
  ChatCompletionStreamResponseDeltaRoleEnum,
  ChatCompletionStreamResponseGabberMessageDataInnerTypeEnum,
  ChatCompletionStreamResponseObjectEnum,
  ContextCreateRequestMessagesInnerRoleEnum,
  ContextMessageCreateParamsRoleEnum,
  CreatePersonaRequestGenderEnum,
  HistoryMessageRoleEnum,
  PersonaGenderEnum,
  RealtimeSessionEngine,
  RealtimeSessionStateEnum,
  RealtimeSessionTimelineItemTypeEnum,
  SDKAgentState,
  SDKConnectionState,
  SessionStateEnum,
  SessionTimelineItemTypeEnum,
  UpdatePersonaRequestGenderEnum,
  UsageType,
  WebhookMessageUsageTrackedTypeEnum
};
//# sourceMappingURL=index.mjs.map